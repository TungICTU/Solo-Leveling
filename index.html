<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Solo Leveling</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --color-common: #9e9e9e;
      --color-uncommon: #4caf50;
      --color-rare: #2196f3;
      --color-epic: #9c27b0;
      --color-legendary: #ff9800;
      --color-mythic: #f44336;
      --bg-primary:#1a1410;
      --bg-secondary:#2a1f1a;
      --bg-tertiary:#3a2f2a;
      --accent-gold:#d4af37;
      --accent-gold-bright:#f4cf57;
      --accent-copper:#b87333;
      --text-primary:#f5e6d3;
      --text-secondary:#c5b5a3;
      --text-dim:#8a7a6a;
      --text-bonus:#4fc3f7;
      --border-radius:8px;
      --border-color: #444;
      --shadow-sm:0 2px 4px rgba(0,0,0,0.3);
      --shadow-md:0 4px 12px rgba(0,0,0,0.5);
      --shadow-lg:0 8px 24px rgba(0,0,0,0.7);
      --font-display:'Cinzel',serif;
      --font-body:'Merriweather',serif
    }

    body {
      font-family: "Crimson Text", Georgia, "Times New Roman", serif;
      background:linear-gradient(135deg,#1a1410 0%,#2a1f1a 50%,#1a1410 100%);
      background-attachment:fixed;
      color: var(--text-primary);
      overflow: hidden;
      touch-action: pan-y;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #game-root {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    #hud {
      background: var(--bg-secondary);
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      padding: 8px 12px;
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 36px;
      border-bottom: 2px solid var(--border-color);
      z-index: 100;
    }

    #resources {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    #coins::before { content: 'üí∞ '; }
    #gems::before { content: 'üíé '; }
    #world {
      background: var(--bg-tertiary);
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    #levelbar {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 100px;
    }

    #level {
      font-weight: bold;
      color: #ffd700;
      white-space: nowrap;
    }

    #expbar {
      flex: 1;
      height: 20px;
      background: #333;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      border: 1px solid #555;
    }

    #exp-fill {
      height: 100%;
      background:linear-gradient(90deg,var(--accent-copper) 0%,var(--accent-gold) 100%);
      width: 0%;
      transition: width 0.3s ease;
      box-shadow:0 0 8px var(--accent-gold);
    }

    #exp-text {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
      z-index: 1;
    }

    #btn-challenge-boss {
      padding:6px 12px;
      background:linear-gradient(135deg,#8b0000 0%,#dc143c 100%);
      border:2px solid #ff6347;
      border-radius:var(--border-radius);
      color:white;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      cursor:pointer;
      box-shadow:var(--shadow-sm);
      transition:all 0.2s;
      text-transform:uppercase;
    }

    #btn-challenge-boss:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    #btn-challenge-boss:active:not(:disabled) {
      transform: scale(0.95);
    }

    #stage {
      flex: 1;
      position: relative;
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      overflow: hidden;
      touch-action: none;
    }

    #player-container {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
    }

    #player {
      width: 56px;
      height: 56px;
      background: radial-gradient(circle, #4fc3f7, #0288d1);
      border-radius: 50%;
      border: 3px solid #01579b;
      box-shadow: 0 0 20px rgba(79, 195, 247, 0.6);
      position: relative;
      margin: 0 auto;
    }

    #attack-range-circle {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 2px solid;
      pointer-events: none;
      opacity: 0.3;
      z-index: 45;
      display: none;
    }

    #attack-range-circle.visible {
      display: block;
    }

    #player-hpbar {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      border: 2px solid #555;
      overflow: hidden;
    }

    #player-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #e74c3c, #c0392b);
      width: 100%;
      transition: width 0.2s ease;
    }

    #player-hp-text {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
    }

    #equip-ring {
      position: absolute;
      left: 50%;
      top: 28px;
      transform: translate(-50%, -50%);
      width: 160px;
      height: 160px;
      pointer-events: none;
    }

    .equipped-icon {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    #enemy-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .enemy {
      position: absolute;
      border-radius: 50%;
      border: 2px solid;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: transform 0.1s;
      cursor: pointer;
      pointer-events: auto;
      touch-action: manipulation;
    }

    .enemy:active {
      transform: scale(0.9);
    }

    .enemy.small {
      width: 32px;
      height: 32px;
      background: #9e9e9e;
      border-color: #757575;
      font-size: 14px;
    }

    .enemy.normal {
      width: 40px;
      height: 40px;
      background: #795548;
      border-color: #5d4037;
    }

    .enemy.big {
      width: 56px;
      height: 56px;
      background: #ff5722;
      border-color: #d84315;
      font-size: 24px;
    }

    .enemy.elite {
      width: 64px;
      height: 64px;
      background: #9c27b0;
      border-color: #7b1fa2;
      font-size: 28px;
      box-shadow: 0 0 20px rgba(156, 39, 176, 0.8);
    }

    .enemy.boss {
      width: 80px;
      height: 80px;
      background: #f44336;
      border-color: #c62828;
      font-size: 36px;
      box-shadow: 0 0 30px rgba(244, 67, 54, 0.9);
      animation: boss-pulse 1s infinite;
    }

    @keyframes boss-pulse {
      0%, 100% {
        box-shadow: 0 0 30px rgba(244, 67, 54, 0.9);
        filter: brightness(1);
      }
      50% {
        box-shadow: 0 0 45px rgba(244, 67, 54, 1);
        filter: brightness(1.2);
      }
    }

    .enemy-hpbar {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid #555;
    }

    .enemy-hp-fill {
      height: 100%;
      background: #4caf50;
      width: 100%;
      transition: width 0.2s ease;
    }

    #drop-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .drop-item {
      position: absolute;
      font-size: 20px;
      animation: dropFloat 2s ease-out forwards;
      pointer-events: none;
    }

    @keyframes dropFloat {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-60px) scale(1.5);
      }
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 16px;
      display: none;
    }

    .overlay[aria-hidden="false"] {
      display: block;
    }

    .overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      padding: 8px;
      border-radius:var(--border-radius);
      z-index: 10;
    }

    .overlay-title {
      font-size: 20px;
      font-weight: bold;
      color: #ffd700;
    }

    .btn, .btn-refresh, .tooltip-btn, .nav-btn {
      padding:14px 20px;
      background:linear-gradient(135deg,var(--accent-copper) 0%,var(--accent-gold) 100%);
      border:2px solid var(--accent-gold-bright);
      border-radius:var(--border-radius);
      color:var(--bg-primary);
      font-family:var(--font-display);
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      gap: 8px;
      box-shadow:var(--shadow-md);
      transition:all 0.2s;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    .btn:hover, .btn-refresh:hover {
      transform:translateY(-2px);
      box-shadow:0 6px 16px rgba(206, 196, 165, 0.4);
    }
    .btn-close {
      background: #e74c3c;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      touch-action: manipulation;
    }

    .btn-close:active {
      transform: scale(0.95);
    }

    .custom-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .custom-modal[aria-hidden="false"] {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-content {
      background: var(--bg-secondary);
      border: 3px solid var(--accent-gold);
      border-radius: var(--border-radius);
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: var(--shadow-lg);
      transform: scale(0.9);
      transition: transform 0.3s;
    }

    .custom-modal[aria-hidden="false"] .modal-content {
      transform: scale(1);
    }

    .modal-header {
      font-size: 20px;
      font-weight: bold;
      color: var(--accent-gold);
      margin-bottom: 16px;
      text-align: center;
      font-family: var(--font-display);
    }

    .modal-body {
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 20px;
      text-align: center;
      color: var(--text-primary);
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .modal-btn {
      padding: 10px 24px;
      border: none;
      border-radius: var(--border-radius);
      font-family: var(--font-display);
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .modal-btn-confirm {
      background: linear-gradient(135deg, #8b0000 0%, #dc143c 100%);
      color: white;
      border: 2px solid #ff6347;
    }

    .modal-btn-confirm:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(220, 20, 60, 0.5);
    }

    .modal-btn-cancel {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
    }

    .modal-btn-cancel:hover {
      background: var(--bg-secondary);
      border-color: var(--accent-gold);
    }

    .modal-btn:active {
      transform: scale(0.95);
    }

    .inventory-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 800px;
      margin: 0 auto;
    }

    @media (min-width: 768px) {
      .inventory-container {
        flex-direction: row;
      }
    }

    .inv-left-col {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .inv-player-label {
      font-size: 18px;
      font-weight: bold;
      color: #ffd700;
      text-align: center;
      margin-bottom: -4px;
    }

    .inv-player {
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, #4fc3f7, #0288d1);
      border-radius: 50%;
      border: 4px solid #01579b;
      box-shadow: 0 0 30px rgba(79, 195, 247, 0.6);
    }

    .stats-box {
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      border:2px solid var(--accent-copper);
      border-radius:var(--border-radius);
      padding: 12px;
      width: 200px;
      margin-top: 8px;
    }

    .inv-resources {
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      border:2px solid var(--accent-gold);
      border-radius:var(--border-radius);
      padding: 12px;
      width: 200px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
    }

    .inv-resource-line {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
      position: relative;
    }

    .inv-resource-line:last-child {
      border-bottom: none;
    }

    .inv-resource-label {
      font-weight: bold;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .inv-resource-value {
      color: #ffd700;
      font-weight: bold;
    }

    .inv-active-effects {
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      border:2px solid var(--accent-gold);
      border-radius:var(--border-radius);
      padding: 12px;
      width: 200px;
    }

    .active-effects-icons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      min-height: 60px;
      align-items: center;
    }

    .effect-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 64px;
      padding: 8px;
      background: rgba(212, 175, 55, 0.1);
      border: 2px solid var(--accent-gold);
      border-radius: 8px;
      transition: background 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }

    @keyframes bounce-once {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .effect-icon.bouncing {
      animation: bounce-once 0.3s ease;
    }

    .effect-icon:hover {
      box-shadow: 0 4px 8px rgba(212, 175, 55, 0.4);
      background: rgba(212, 175, 55, 0.2);
    }

    .effect-icon-image {
      font-size: 32px;
      margin-bottom: 4px;
    }

    .effect-icon-timer {
      font-size: 10px;
      color: var(--text-secondary);
      font-weight: bold;
    }

    .no-effects-message {
      color: #999;
      text-align: center;
      font-size: 12px;
      font-style: italic;
    }

    .stat-line {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .stat-line:last-child {
      border-bottom: none;
    }

    .stat-label {
      font-weight: bold;
      color: var(--text-secondary);
    }

    .stat-value {
      color: #ffd700;
      font-weight: bold;
    }

    .inv-right-col {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .inv-title {
      font-size: 24px;
      text-align: center;
      color: #ffd700;
      margin-bottom: 8px;
    }

    .equip-ring {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin: 0 auto;
      max-width: 600px;
      padding: 20px;
    }

    .equip-slot {
      aspect-ratio: 1;
      border: 3px solid var(--border-color);
      border-radius: 50%;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      touch-action: manipulation;
    }

    .equip-slot.dragging {
      opacity: 0.5;
    }

    .equip-slot.drag-over {
      border-color: #ffd700;
      background: var(--bg-secondary);
      transform: scale(1.05);
    }

    .equip-slot:hover {
      border-color: #ffd700;
      transform: scale(1.05);
    }

    .equip-slot.filled {
      background: var(--bg-secondary);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(4, 80px);
      gap: 8px;
      max-width: 400px;
      margin: 0 auto;
    }

    .inv-slot {
      width: 80px;
      height: 80px;
      aspect-ratio: 1;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      touch-action: manipulation;
    }

    .inv-slot.dragging {
      opacity: 0.5;
    }

    .inv-slot.drag-over {
      border-color: #ffd700;
      background: var(--bg-secondary);
    }

    .inv-slot:hover {
      border-color: #ffd700;
      transform: scale(1.05);
    }

    .inv-slot.filled {
      background: var(--bg-secondary);
    }

    .item-icon {
      font-size: inherit;
      pointer-events: none;
    }

    .item-level {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
      color: #ffd700;
      pointer-events: none;
    }

    .item-stars {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #ffd700;
      pointer-events: none;
    }

    .tooltip {
      position: fixed;
      background: var(--bg-secondary);
      border: 2px solid;
      border-radius: 8px;
      padding: 12px;
      max-width: 300px;
      z-index: 2000;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    /* Mobile tooltip adjustments */
    @media (max-width: 768px) {
      .tooltip {
        max-width: 85vw;
        padding: 8px;
        font-size: 11px;
        max-height: 70vh;
        overflow-y: auto;
      }

      .tooltip-header {
        font-size: 13px;
      }

      .tooltip-level {
        font-size: 11px;
      }

      .base-stat-value {
        font-size: 20px;
      }

      .base-stat-name {
        font-size: 10px;
      }

      .tooltip-content {
        font-size: 11px;
        line-height: 1.4;
      }

      .tooltip-attr {
        padding: 3px;
        margin: 3px 0;
      }

      .tooltip-btn {
        padding: 6px 8px;
        font-size: 11px;
        min-width: 60px;
      }

      .tooltip-actions {
        margin-top: 8px;
        gap: 4px;
      }
    }

    .tooltip[aria-hidden="false"] {
      opacity: 1;
      pointer-events: auto;
    }

    .tooltip-header-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
      gap: 16px;
    }

    .tooltip-header-left {
      flex: 1;
    }

    .tooltip-header {
      font-weight: bold;
      font-size: 16px;
    }

    .tooltip-level {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .tooltip-base-stat {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 60px;
    }

    .base-stat-name {
      font-size: 12px;
      font-weight: bold;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .base-stat-value {
      font-size: 28px;
      font-weight: bold;
      color: var(--text-primary);
      line-height: 1;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .tooltip-content {
      font-size: 13px;
      line-height: 1.5;
    }

    .tooltip-attr {
      margin: 4px 0;
      padding: 4px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    .tooltip-attr.locked {
      opacity: 0.6;
    }

    .tooltip-attr.locked::before {
      content: 'üîí ';
    }

    .tooltip-actions {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tooltip-btn {
      flex: 1;
      min-width: 70px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      touch-action: manipulation;
    }

    .tooltip-btn.primary {
      background: #4caf50;
      color: white;
    }

    .tooltip-btn.secondary {
      background: #2196f3;
      color: white;
    }

    .tooltip-btn.danger {
      background: #e74c3c;
      color: white;
    }

    .tooltip-btn:active {
      transform: scale(0.95);
    }

    .shop-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .shop-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 8px;
    }

    .shop-timer {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .btn-refresh {
      background: #2196f3;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      touch-action: manipulation;
    }

    .btn-refresh:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .btn-refresh:active:not(:disabled) {
      transform: scale(0.95);
    }

    .shop-section {
      margin-bottom: 24px;
    }

    .shop-section h3 {
      margin-bottom: 12px;
      color: #ffd700;
      font-size: 18px;
    }

    .shop-resources {
      display: flex;
      gap: 24px;
      justify-content: center;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      margin-bottom: 16px;
      font-size: 18px;
      font-weight: bold;
    }

    .shop-resource {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
    }

    .shop-resource span {
      color: #ffd700;
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
    }

    .shop-item {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
      position: relative;
    }

    .shop-item.sold-out {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }

    .shop-item.sold-out::after {
      content: 'SOLD OUT';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.9);
      color: white;
      padding: 6px 16px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
      letter-spacing: 1px;
    }

    .shop-item:hover {
      border-color: #ffd700;
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }

    .shop-item:active {
      transform: translateY(-2px);
    }

    .shop-item-icon {
      text-align: center;
      font-size: 48px;
      margin-bottom: 8px;
    }

    .shop-item-name {
      text-align: center;
      font-weight: bold;
      font-size: 13px;
      margin-bottom: 4px;
      min-height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shop-item-price {
      text-align: center;
      color: #ffd700;
      font-weight: bold;
      font-size: 14px;
    }

    .stats-container {
      max-width: 600px;
      margin: 0 auto;
    }

    .stats-section {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .stats-section h3 {
      color: #ffd700;
      margin-bottom: 12px;
      font-size: 18px;
    }

    .effect-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .effect-item {
      background: var(--bg-tertiary);
      padding: 8px;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .effect-name {
      font-weight: bold;
    }

    .effect-timer {
      color: var(--text-secondary);
      font-size: 13px;
    }

    .panel {
      position: fixed;
      top: 52px;
      right: 8px;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 8px 12px;
      width: auto;
      max-width: calc(100% - 16px);
      min-height: auto;
      max-height: fit-content;
      z-index: 500;
      display: none;
    }

    .panel.visible {
      display: block;
    }

    .panel h4 {
      color: #ffd700;
      margin-bottom: 4px;
      font-size: 18px;
    }

    .requirement {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 2px 0;
      font-size: 12px;
    }

    .requirement.met {
      color: #4caf50;
    }

    .requirement.not-met {
      color: #e74c3c;
    }

    .requirement::before {
      content: '‚úì';
      font-weight: bold;
      width: 16px;
    }

    .requirement.not-met::before {
      content: '‚úó';
    }

    #bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border-top: 2px solid var(--border-color);
      display: flex;
      gap: 8px;
      justify-content: space-around;
      padding: 8px;
      z-index: 100;
    }

    .nav-btn {
      flex: 1;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 12px 8px;
      font-size: 12px;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      touch-action: manipulation;
    }

    .nav-btn:active {
      background: var(--bg-primary);
      transform: scale(0.95);
    }

    .nav-btn-icon {
      font-size: 20px;
    }

    #debug-panel {
      position: fixed;
      top: 50%;
      right: 8px;
      transform: translateY(-50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ffd700;
      border-radius: 8px;
      padding: 12px;
      max-width: 250px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 9999;
      font-size: 11px;
    }

    #debug-panel h4 {
      color: #ffd700;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .debug-btn {
      width: 100%;
      margin: 4px 0;
      padding: 6px;
      background: #2196f3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      touch-action: manipulation;
    }

    .debug-btn:active {
      background: #1976d2;
    }

    #notification-container {
      position: fixed;
      top: 60px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 300px;
    }

    .notification {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: var(--shadow-lg);
      animation: slideIn 0.3s ease-out;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      font-weight: 500;
    }

    .notification.info {
      border-color: #2196f3;
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(33, 150, 243, 0.05));
    }

    .notification.success {
      border-color: #4caf50;
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
    }

    .notification.warning {
      border-color: #ff9800;
      background: linear-gradient(135deg, rgba(255, 152, 0, 0.1), rgba(255, 152, 0, 0.05));
    }

    .notification.danger {
      border-color: #f44336;
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(244, 67, 54, 0.05));
    }

    .notification.legendary {
      border-color: #ffd700;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
      animation: slideIn 0.3s ease-out, glow 2s ease-in-out infinite;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateX(400px);
      }
    }

    .rarity-common { border-color: var(--color-common) !important; }
    .rarity-uncommon { border-color: var(--color-uncommon) !important; }
    .rarity-rare { border-color: var(--color-rare) !important; }
    .rarity-epic { border-color: var(--color-epic) !important; }
    .rarity-legendary { border-color: var(--color-legendary) !important; }
    .rarity-mythic { border-color: var(--color-mythic) !important; }

    .text-common { color: var(--color-common); }
    .text-uncommon { color: var(--color-uncommon); }
    .text-rare { color: var(--color-rare); }
    .text-epic { color: var(--color-epic); }
    .text-legendary { color: var(--color-legendary); }
    .text-mythic { color: var(--color-mythic); }

    /* Floating coin/gem popup */
    .floating-change {
      position: absolute;
      pointer-events: none;
      font-weight: 700;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(0);
      opacity: 1;
      transition: transform 800ms cubic-bezier(.22,.9,.3,1), opacity 800ms ease-out;
      z-index: 9999;
      text-shadow: 0 1px 0 rgba(0,0,0,0.3);
    }

    /* colors for positive / negative */
    .floating-change.positive { color: #2ecc71; } /* green */
    .floating-change.negative { color: #e74c3c; } /* red */
    @media (max-width: 480px) {
      #hud {
        font-size: 12px;
      }

      #btn-challenge-boss {
        padding: 6px 12px;
        font-size: 11px;
      }

      .overlay {
        padding: 12px;
      }

      .shop-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
    }

    @media (min-width: 768px) {
      #debug-panel {
        right: 16px;
        max-width: 300px;
      }

      .panel {
        bottom: 16px;
        width: 400px;
      }
    }
    /* Death Screen */
    #death-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: none;
    }

    #death-screen.active {
      display: flex;
    }

    #death-message {
      font-family: var(--font-display);
      font-size: 48px;
      font-weight: bold;
      color: #e74c3c;
      text-shadow: 0 0 20px rgba(231, 76, 60, 0.8), 0 0 40px rgba(231, 76, 60, 0.5);
      margin-bottom: 20px;
      animation: pulse-death 1s ease-in-out infinite;
    }

    @keyframes pulse-death {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }

    #respawn-timer {
      font-family: var(--font-display);
      font-size: 24px;
      color: var(--text-primary);
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }

    /* Player flashing effect */
    #player.flashing {
      animation: flash-invincible 0.15s ease-in-out infinite;
    }

    @keyframes flash-invincible {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Respawn damage burst effect */
    .damage-burst {
      position: absolute;
      width: 600px;
      height: 600px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 253, 242, 0.6) 0%, rgba(255, 244, 225, 0.4) 30%, rgba(255, 177, 148, 0.2) 60%, transparent 100%);
      pointer-events: none;
      animation: burst-expand 0.8s ease-out forwards;
      z-index: 40;
    }

    @keyframes burst-expand {
      0% {
        transform: translate(-50%, -50%) scale(0.1);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 0;
      }
    }

    /* Boss Failure Screen */
    #boss-failure-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      pointer-events: none;
    }

    #boss-failure-screen.active {
      display: flex;
    }

    #boss-failure-message {
      font-family: var(--font-display);
      font-size: 56px;
      font-weight: bold;
      color: #ff4444;
      text-shadow: 0 0 30px rgba(255, 68, 68, 0.9), 0 0 60px rgba(255, 68, 68, 0.6);
      margin-bottom: 30px;
      animation: pulse-failure 1.2s ease-in-out infinite;
    }

    @keyframes pulse-failure {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.08); opacity: 0.7; }
    }

    #boss-failure-info {
      font-family: var(--font-display);
      font-size: 28px;
      color: var(--accent-gold);
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
    }

    #boss-failure-world {
      font-weight: bold;
      color: var(--accent-gold-bright);
    }


    @keyframes fire-pulse {
      0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
    }

    @keyframes wind-pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    #set-bonuses-display {
      display: none !important;
    }
</style>
</head>
<body>
  <div id="game-root">
    <header id="hud">
      <div id="resources">
        <span id="coins">0</span>
        <span id="gems">0</span>
      </div>
      <div id="levelbar">
        <span id="level">Lv 1</span>
        <div id="expbar">
          <div id="exp-fill"></div>
          <div id="exp-text">0 / 100</div>
        </div>
      </div>
      <div id="challenge-timer" style="display:none; font-size:16px; font-weight:bold; color:#ffd700; padding:4px 12px; background:rgba(0,0,0,0.6); border-radius:8px;">‚è±Ô∏è <span id="timer-text">1:00</span></div>
      <div id="world">World 1</div>
      <button id="btn-challenge-boss">Challenge Boss</button>
    </header>

    <main id="stage">
      <div id="attack-range-circle"></div>
      <div id="player-container">
        <div id="player" aria-label="player" role="img"></div>
        <div id="player-hpbar">
          <div id="player-hp-fill"></div>
          <div id="player-hp-text">100 / 100</div>
        </div>
        <div id="equip-ring"></div>
      </div>

      <div id="enemy-layer"></div>
      <div id="drop-layer"></div>
      <div id="death-screen">
        <div id="death-message">You Died!</div>
        <div id="respawn-timer">Respawning in 5 seconds...</div>
      </div>
      <div id="boss-failure-screen">
        <div id="boss-failure-message">Challenge Failed!</div>
        <div id="boss-failure-info">Return to World <span id="boss-failure-world">1</span></div>
      </div>
    </main>

    <section id="overlays">
      <div id="inventory-overlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Inventory">
        <div class="overlay-header">
          <h2 class="overlay-title">Inventory</h2>
          <button class="btn-close" onclick="closeOverlay('inventory-overlay')">‚úï Close</button>
        </div>
        <div class="inventory-container">
          <div class="inv-left-col">
            <div class="inv-player-label">Player</div>
            <div id="inv-player" class="inv-player" role="img" aria-label="Player"></div>
            <div id="player-stats-box" class="stats-box" role="region" aria-label="Player stats" tabindex="0" aria-live="polite">
              <div class="stat-line"><span class="stat-label">ATK</span><span class="stat-value" id="stat-atk">0</span></div>
              <div class="stat-line"><span class="stat-label">HP</span><span class="stat-value" id="stat-hp">0</span></div>
              <div class="stat-line"><span class="stat-label">SPD</span><span class="stat-value" id="stat-spd">0</span></div>
              <div class="stat-line"><span class="stat-label">DMG%</span><span class="stat-value" id="stat-dmg">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit Rate</span><span class="stat-value" id="stat-crit-rate">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit DMG</span><span class="stat-value" id="stat-crit-dmg">0%</span></div>
            </div>
            <div id="inv-resources" class="inv-resources">
              <div class="inv-resource-line">
                <span class="inv-resource-label">üí∞ Coins</span>
                <span class="inv-resource-value" id="inv-coins">0</span>
              </div>
              <div class="inv-resource-line">
                <span class="inv-resource-label">üíé Gems</span>
                <span class="inv-resource-value" id="inv-gems">0</span>
              </div>
            </div>

            <div id="inv-active-effects" class="inv-active-effects">
              <div id="active-effects-icons" class="active-effects-icons">
                <!-- Effects will be rendered here as icons -->
              </div>
            </div>

            <!-- Set Bonuses Display -->
            <div id="set-bonuses-display" style="margin-top: 12px;"></div>
          </div>

          <div class="inv-right-col">
            <div id="inv-equip-ring" class="equip-ring" aria-label="Equipment slots">
              <div class="equip-slot" data-slot="helmet" id="equip-helmet" aria-label="Helmet" tabindex="0"></div>
              <div class="equip-slot" data-slot="leggings" id="equip-leggings" aria-label="Leggings" tabindex="0"></div>
              <div class="equip-slot" data-slot="ring" id="equip-ring-slot" aria-label="Ring relic" tabindex="0"></div>

              <div class="equip-slot" data-slot="chestplate" id="equip-chestplate" aria-label="Chestplate" tabindex="0"></div>
              <div class="equip-slot" data-slot="boots" id="equip-boots" aria-label="Boots" tabindex="0"></div>
              <div class="equip-slot" data-slot="weapon" id="equip-weapon" aria-label="Weapon" tabindex="0"></div>
            </div>

            <div id="inventory-grid" class="inventory-grid" role="list" aria-label="Inventory slots">
              <div class="inv-slot" data-index="0" role="listitem" aria-label="Inventory slot 1" tabindex="0"></div>
              <div class="inv-slot" data-index="1" role="listitem" aria-label="Inventory slot 2" tabindex="0"></div>
              <div class="inv-slot" data-index="2" role="listitem" aria-label="Inventory slot 3" tabindex="0"></div>
              <div class="inv-slot" data-index="3" role="listitem" aria-label="Inventory slot 4" tabindex="0"></div>

              <div class="inv-slot" data-index="4" role="listitem" aria-label="Inventory slot 5" tabindex="0"></div>
              <div class="inv-slot" data-index="5" role="listitem" aria-label="Inventory slot 6" tabindex="0"></div>
              <div class="inv-slot" data-index="6" role="listitem" aria-label="Inventory slot 7" tabindex="0"></div>
              <div class="inv-slot" data-index="7" role="listitem" aria-label="Inventory slot 8" tabindex="0"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="shop-overlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Shop">
        <div class="overlay-header">
          <h2 class="overlay-title">Shop</h2>
          <button class="btn-close" onclick="closeOverlay('shop-overlay')">‚úï Close</button>
        </div>
        <div class="shop-resources">
          <div class="shop-resource">üí∞ <span id="shop-coins">0</span></div>
          <div class="shop-resource">üíé <span id="shop-gems">0</span></div>
        </div>
        <div class="shop-container">
          <div class="shop-controls">
            <div class="shop-timer" id="shop-timer">Next refresh in: 60s</div>
            <button class="btn-refresh" id="btn-manual-refresh">Refresh (5s cooldown)</button>
          </div>

          <div class="shop-section">
            <h3>Equipment</h3>
            <div class="shop-grid" id="shop-equipment-grid"></div>
          </div>

          <div class="shop-section">
            <h3>Consumables</h3>
            <div class="shop-grid" id="shop-consumables-grid"></div>
          </div>
        </div>
      </div>

      <div id="stats-overlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Stats">
        <div class="overlay-header">
          <h2 class="overlay-title">Stats</h2>
          <button class="btn-close" onclick="closeOverlay('stats-overlay')">‚úï Close</button>
        </div>
        <div class="stats-container">
          <div class="stats-section">
            <h3>Combat Stats</h3>
            <div id="detailed-stats" style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
              <div class="stat-line"><span class="stat-label">ATK</span><span class="stat-value" id="stat-atk-detail">0</span></div>
              <div class="stat-line"><span class="stat-label">HP</span><span class="stat-value" id="stat-hp-detail">0</span></div>
              <div class="stat-line"><span class="stat-label">SPD</span><span class="stat-value" id="stat-spd-detail">0</span></div>
              <div class="stat-line"><span class="stat-label">DMG%</span><span class="stat-value" id="stat-dmg-detail">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit Rate</span><span class="stat-value" id="stat-crit-rate-detail">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit Dmg</span><span class="stat-value" id="stat-crit-dmg-detail">0%</span></div>
            </div>

            <h3>Player Statistics</h3>
            <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px;">
              <div class="stat-line"><span class="stat-label">Total Kills</span><span class="stat-value" id="stat-total-kills">0</span></div>
              <div class="stat-line"><span class="stat-label">Bosses Defeated</span><span class="stat-value" id="stat-bosses">0</span></div>
              <div class="stat-line"><span class="stat-label">Worlds Completed</span><span class="stat-value" id="stat-worlds">0</span></div>
              <div class="stat-line"><span class="stat-label">Deaths</span><span class="stat-value" id="stat-deaths">0</span></div>
              <div class="stat-line"><span class="stat-label">Critical Hits</span><span class="stat-value" id="stat-crits">0</span></div>
              <div class="stat-line"><span class="stat-label">Damage Dealt</span><span class="stat-value" id="stat-dmg-dealt">0</span></div>
              <div class="stat-line"><span class="stat-label">Damage Taken</span><span class="stat-value" id="stat-dmg-taken">0</span></div>
              <div class="stat-line"><span class="stat-label">Coins Earned</span><span class="stat-value" id="stat-coins-earned">0</span></div>
              <div class="stat-line"><span class="stat-label">Gems Earned</span><span class="stat-value" id="stat-gems-earned">0</span></div>
              <div class="stat-line"><span class="stat-label">EXP Gained</span><span class="stat-value" id="stat-exp-gained">0</span></div>
              <div class="stat-line"><span class="stat-label">Items Found</span><span class="stat-value" id="stat-items-found">0</span></div>
              <div class="stat-line"><span class="stat-label">Items Purchased</span><span class="stat-value" id="stat-items-bought">0</span></div>
              <div class="stat-line"><span class="stat-label">Play Time</span><span class="stat-value" id="stat-playtime">0h 0m</span></div>
            </div>

            <button id="btn-reset-progress" style="width: 100%; margin-top: 16px; padding: 10px; background: linear-gradient(135deg, #8b0000 0%, #dc143c 100%); border: 2px solid #ff6347; border-radius: 8px; color: white; font-family: var(--font-display); font-weight: 600; font-size: 13px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: all 0.2s; text-transform: uppercase;">
              Reset All Progress
            </button>
          </div>
        </div>
      </div>

      <div id="boss-requirements" class="panel">
        <h4>Challenge Requirements</h4>
        <div class="requirement" id="req-enemies">
          <span>Enemies: <span id="req-enemies-text">0 / 0</span></span>
        </div>
        <div class="requirement" id="req-elites">
          <span>Elites: <span id="req-elites-text">0 / 0</span></span>
        </div>
        <div class="requirement" id="req-level">
          <span>Level: <span id="req-level-text">1 / 1</span></span>
        </div>
      </div>
    </section>

    <!-- Global tooltip for inventory and shop -->
    <div id="inventory-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>

    <!-- Custom confirmation modal -->
    <div id="reset-modal" class="custom-modal" aria-hidden="true">
      <div class="modal-content">
        <div class="modal-header">Reset All Progress</div>
        <div class="modal-body">
          This will delete ALL your progress and reset the game to the beginning. This action CANNOT be undone!
          <br><br>
          Are you absolutely sure you want to reset?
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-cancel" id="modal-cancel">Cancel</button>
          <button class="modal-btn modal-btn-confirm" id="modal-confirm">Reset Progress</button>
        </div>
      </div>
    </div>

    <div id="bottom-nav">
      <button class="nav-btn" onclick="openOverlay('inventory-overlay')">
        <span class="nav-btn-icon">üéí</span>
        <span>Inventory</span>
      </button>
      <button class="nav-btn" onclick="openOverlay('shop-overlay')">
        <span class="nav-btn-icon">üõí</span>
        <span>Shop</span>
      </button>
      <button class="nav-btn" onclick="openOverlay('stats-overlay')">
        <span class="nav-btn-icon">üìä</span>
        <span>Stats</span>
      </button>
    </div>

    <div id="debug-panel" style="display:none">
      <h4>Debug Panel</h4>
      <div id="debug-info"></div>
      <button class="debug-btn" onclick="DevTools.spawnEnemies(10, 'normal')">Spawn 10 Normal</button>
      <button class="debug-btn" onclick="DevTools.spawnEnemies(5, 'elite')">Spawn 5 Elite</button>
      <button class="debug-btn" onclick="DevTools.grantCoins(1000000)">+1m Coins</button>
      <button class="debug-btn" onclick="DevTools.grantGems(100)">+100 Gems</button>
      <button class="debug-btn" onclick="DevTools.levelUp()">Level Up</button>
      <button class="debug-btn" onclick="DevTools.clearSave()">Clear Save</button>
      <div style="border-top: 1px solid #444; margin: 8px 0; padding-top: 8px;">
        <div style="font-weight: bold; margin-bottom: 4px;">Grant Equipment Sets:</div>
        <button class="debug-btn" onclick="DevTools.grantSet('skywarden')">Skywarden</button>
        <button class="debug-btn" onclick="DevTools.grantSet('stormbreaker')">Stormbreaker</button>
        <button class="debug-btn" onclick="DevTools.grantSet('bastion')">Bastion</button>
        <button class="debug-btn" onclick="DevTools.grantSet('nightwing')">Nightwing</button>
        <button class="debug-btn" onclick="DevTools.grantSet('shade')">Shade</button>
        <button class="debug-btn" onclick="DevTools.grantSet('aegis')">Aegis</button>
        <button class="debug-btn" onclick="DevTools.grantSet('glacier')">Glacier</button>
        <button class="debug-btn" onclick="DevTools.grantSet('emberkin')">Emberkin</button>
        <button class="debug-btn" onclick="DevTools.grantSet('zephyr')">Zephyr</button>
      </div>
    </div>

    <div id="notification-container"></div>
  </div>

  <script>
// ========== Section 2: CONFIG ==========
const CONFIG = {
  TICK_INTERVAL_MS: 100,
  UI_UPDATE_MS: 250,
  SAVE_INTERVAL_MS: 10000,
  GAME_TIME_SCALE: 1,
  PLAYER_RADIUS_PX: 28,
  ENGAGE_RADIUS_PX: 120,
  EQUIP_RENDER_RADIUS_PX: 80,
  MAX_INVENTORY_SLOTS: 8,
  ATTACK_INTERVAL_DIVISOR: 100,
  MIN_ATTACK_INTERVAL_S: 0.001,
  SHOP_AUTO_REFRESH_SEC: 60,
  SHOP_MANUAL_COOLDOWN_SEC: 5,
  DEFAULT_CONSUMABLE_DURATION_S: 3600,
  TEST_CONSUMABLE_DURATION_S: 300,
  WAVE_INTERVAL_SEC: 10,
  MIN_WAVE_ENEMIES: 5,
  MAX_WAVE_ENEMIES: 200,
  RARITY_PROB: { common:0.45, uncommon:0.35, rare:0.10, epic:0.05, legendary:0.03, mythic:0.02 },
  EQUIP_BASE_UPGRADE_COST: { common:50, uncommon:200, rare:1000, epic:5000, legendary:25000, mythic:100000 },
  STAR_THRESHOLDS: [10,25,50,75,100],
  STAR_GEM_COSTS: { "10":0, "25":1, "50":3, "75":5, "100":10 },
  BASE_SHOP_PRICE: { common:500, uncommon:2000, rare:10000, epic:50000, legendary:200000, mythic:1000000 },
  ENEMY_BASE_COIN: { small:25, normal:50, big:150, elite:650, boss:7250 },
  ENEMY_HP_SCALE: 2.75,
  ENEMY_ATK_SCALE: 1.5,
  ENEMY_RESIST_BONUS_PER_WORLD: 0.5,
  BASE_EQUIP_DROP_CHANCE_PCT: { normal:0.5, small:0.25, big:2, elite:10 },
  LUCK_EFFECT_MULTIPLIER: 1.0,
  SAVE_KEY: "inc_rpg_v1",
  AUTO_ATTACK_SEED: null,
  DEV_MODE: false
};

// ========== EQUIPMENT SETS ==========
const EQUIPMENT_SETS = {
  skywarden: {
    name: 'Skywarden',
    element: 'wind',
    icon: 'üå™Ô∏è',
    weaponName: 'Aquila Longbow',
    weaponDesc: 'Deal 120% wind damage to an enemy, randomly pushes that enemy and 2 nearby enemies back a small distance, and deal 50% wind damage to them. After enemy dies to wind damage, creates an AOE wind explosion on the dead enemy area that deals 50% wind damage to surrounding enemies and push them back.',
    items: {
      helmet: { slot: 'helmet', name: 'Skywarden Helmet', icon: 'üåÄ' },
      chestplate: { slot: 'chestplate', name: 'Skywarden Chestplate', icon: 'üå¨Ô∏è' },
      leggings: { slot: 'leggings', name: 'Skywarden Leggings', icon: 'üçÉ' },
      boots: { slot: 'boots', name: 'Skywarden Boots', icon: 'ü™∂' },
      ring: { slot: 'ring', name: 'Skywarden Ring', icon: 'üí®' },
      weapon: { slot: 'weapon', name: 'Aquila Longbow', icon: 'üèπ', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Wind Storm: If enemy killed with wind damage, create 3 AOE wind explosions nearby that enemy that deals 50% wind damage to surrounding enemies.' },
      4: { desc: '+12% Wind DMG', WindDMG_pct: 12 },
      6: { desc: 'Aquila Tornado: For every 20 enemy killed with wind damage, create a tornado at a random enemy, pull every enemy nearby to the tornado, dealing 50% wind damage each tick for 5 seconds.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  stormbreaker: {
    name: 'Stormbreaker',
    element: 'lightning',
    icon: '‚ö°',
    weaponName: 'Storm Pike',
    weaponDesc: 'Deal 120% lightning damage to an enemy, there is a 50% chance to hit a nearby enemy, dealing 75% lightning damage to that enemy, then there is a 25% chance to hit another nearby enemy, dealing 50% lightning damage to that enemy.',
    items: {
      helmet: { slot: 'helmet', name: 'Stormbreaker Helmet', icon: '‚ö°' },
      chestplate: { slot: 'chestplate', name: 'Stormbreaker Chestplate', icon: 'üå©Ô∏è' },
      leggings: { slot: 'leggings', name: 'Stormbreaker Leggings', icon: '‚õàÔ∏è' },
      boots: { slot: 'boots', name: 'Stormbreaker Boots', icon: 'üí´' },
      ring: { slot: 'ring', name: 'Stormbreaker Ring', icon: '‚ö°' },
      weapon: { slot: 'weapon', name: 'Storm Pike', icon: 'üî±', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Lightning Surge: Lightning is guaranteed to hit at least 2 nearby enemies after hitting an enemy, 50% chance to hit the 4th and 25% chance to hit the 5th, lightning now deals consistent 75% lightning damage.' },
      4: { desc: '+12% Lightning DMG', LightningDMG_pct: 12 },
      6: { desc: 'Multishot: Creates 3 lightning arcs to that enemy and 2 nearby enemies, lightning now deals consistent 120% lightning damage.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  bastion: {
    name: 'Bastion',
    element: 'physical',
    icon: 'üõ°Ô∏è',
    weaponName: 'Titan Warhammer',
    weaponDesc: 'Deal 120% physical damage equal to 30% player HP and 80% physical damage equal to 20% player HP in surrounding area.',
    items: {
      helmet: { slot: 'helmet', name: 'Bastion Helmet', icon: 'üõ°Ô∏è' },
      chestplate: { slot: 'chestplate', name: 'Bastion Chestplate', icon: 'ü™®' },
      leggings: { slot: 'leggings', name: 'Bastion Leggings', icon: '‚õ∞Ô∏è' },
      boots: { slot: 'boots', name: 'Bastion Boots', icon: 'üóø' },
      ring: { slot: 'ring', name: 'Bastion Ring', icon: '‚öôÔ∏è' },
      weapon: { slot: 'weapon', name: 'Titan Warhammer', icon: 'üî®', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% HP', HP_pct: 12 },
      3: { desc: 'Shock Roar: Creates a giant shock area around the player every 1.5 seconds, dealing 180% damage equal to 50% of players HP.' },
      4: { desc: 'Reduce damage taken by 12%', DMG_reduction_pct: 12 },
      6: { desc: 'Metal Fierce: +20% DMG when player <50% HP, increase area of Shock Roar and the player\'s attack, change color of Shock Roar and player\'s attack to light red' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  nightwing: {
    name: 'Nightwing',
    element: 'physical',
    icon: 'ü¶á',
    weaponName: "Raven's Volley",
    weaponDesc: 'Deal 120% physical damage equal to 20% of players ATK, after hit an enemy, bounce 2 coins randomly 3 times, dealing 0.77% physical damage of players total coins (this damage appears yellow).',
    items: {
      helmet: { slot: 'helmet', name: 'Nightwing Helmet', icon: 'ü¶á' },
      chestplate: { slot: 'chestplate', name: 'Nightwing Chestplate', icon: 'üåô' },
      leggings: { slot: 'leggings', name: 'Nightwing Leggings', icon: 'üåë' },
      boots: { slot: 'boots', name: 'Nightwing Boots', icon: 'ü™ô' },
      ring: { slot: 'ring', name: 'Nightwing Ring', icon: 'üí∞' },
      weapon: { slot: 'weapon', name: "Raven's Volley", icon: 'üèπ', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Rich Man\'s Blow: For every enemy killed with coin damage, shoot 5 coins from the dead enemy in star pattern, each coin hit deals 0.99% physical yellow damage of players total coins. Increase coin obtained from enemies killed with coin damage by 50%.' },
      4: { desc: '+6% SPD', SPD_pct: 6 },
      6: { desc: 'Wealth: For every 20 enemy killed with coin damage, rains coins and each coin hit deals 1.88% physical yellow damage of players total coins to the enemies on the field, this rain lasts for 5 seconds, kills from rain coins do not count towards 20 enemy killed with coin damage.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  shade: {
    name: 'Shade',
    element: 'physical',
    icon: 'üíÄ',
    weaponName: 'Wraith Scythe',
    weaponDesc: 'Deal 50% physical damage to an enemy, lose 2% max HP, and deals extra 200% physical damage + 200% of HP lost to an enemy (this damage appears red), if an enemy dies, restores 5% max HP. If the player has lower than 2% max HP, set the player\'s HP to 1.',
    items: {
      helmet: { slot: 'helmet', name: 'Shade Helmet', icon: 'üíÄ' },
      chestplate: { slot: 'chestplate', name: 'Shade Chestplate', icon: 'ü©∏' },
      leggings: { slot: 'leggings', name: 'Shade Leggings', icon: '‚ò†Ô∏è' },
      boots: { slot: 'boots', name: 'Shade Boots', icon: 'ü¶¥' },
      ring: { slot: 'ring', name: 'Shade Ring', icon: 'üñ§' },
      weapon: { slot: 'weapon', name: 'Wraith Scythe', icon: '‚öîÔ∏è', isWeapon: true, multiplier: 0.50 }
    },
    bonuses: {
      2: { desc: '+12% HP', HP_pct: 12 },
      3: { desc: 'Bloodbath: Increase damage dealt by HP lost by 200%, create a small rain area lasts for 5 seconds, enemies entering or within the area takes damage equal to 300% of HP lost every tick for 5 seconds.' },
      4: { desc: 'Reduce damage taken by 12%', DMG_reduction_pct: 12 },
      6: { desc: 'Overflow: For every 2000 HP lost or healed, +50% DMG for 30 seconds. If the player has <50% HP, heals up to full HP and creates a giant red explosion, dealing 500% HP lost to surrounding enemies.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  aegis: {
    name: 'Aegis',
    element: 'aether',
    icon: '‚ú®',
    weaponName: 'Aether Scepter',
    weaponDesc: 'Launches a ball that continuously hover around the enemy, dealing 120% aether damage each enemy hit, if the enemy is dead, the ball launches to a random enemy, dealing 120% aether damage each hit, the ball lasts for 5 seconds.',
    items: {
      helmet: { slot: 'helmet', name: 'Aegis Helmet', icon: '‚ú®' },
      chestplate: { slot: 'chestplate', name: 'Aegis Chestplate', icon: 'üîÆ' },
      leggings: { slot: 'leggings', name: 'Aegis Leggings', icon: 'üí´' },
      boots: { slot: 'boots', name: 'Aegis Boots', icon: '‚≠ê' },
      ring: { slot: 'ring', name: 'Aegis Ring', icon: 'üí†' },
      weapon: { slot: 'weapon', name: 'Aether Scepter', icon: 'ü™Ñ', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% Aether DMG', AetherDMG_pct: 12 },
      3: { desc: 'Myth: For every enemy hit, there is a 20% chance to spawn another ball from the enemy, launches to a random enemy, that continuously hover around the enemy, dealing 120% aether damage each hit, the ball lasts for 3 seconds or after the enemy is dead' },
      4: { desc: 'Launches 2 balls that continuously hover around the enemy instead of 1, dealing 150% aether damage each enemy hit, if the enemy is dead, the balls move to a random enemy, dealing 150% aether damage each hit, the balls last for 8 seconds.' },
      6: { desc: 'Star Shooter: after the enemy is dead, the balls no longer moves to a random enemy, but instead spins around the dead enemy for 3 seconds, each ball deals 80% aether damage, then launch those balls to random enemies, explodes and dealing 200% aether damage to the enemy.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  glacier: {
    name: 'Glacier',
    element: 'cryo',
    icon: '‚ùÑÔ∏è',
    weaponName: 'Cryo Rod',
    weaponDesc: 'Immediately freezes the enemy for 2 seconds and deal 120% cryo damage to an enemy, if an enemy is already frozen before, they cant be frozen again for 10 seconds, after the enemy is dead, create a cryo AOE that any enemy moved or within the area will be freezed for 3 seconds, dealing 20% cryo damage every tick for 3 seconds.',
    items: {
      helmet: { slot: 'helmet', name: 'Glacier Helmet', icon: '‚ùÑÔ∏è' },
      chestplate: { slot: 'chestplate', name: 'Glacier Chestplate', icon: 'üßä' },
      leggings: { slot: 'leggings', name: 'Glacier Leggings', icon: 'üíé' },
      boots: { slot: 'boots', name: 'Glacier Boots', icon: 'üå®Ô∏è' },
      ring: { slot: 'ring', name: 'Glacier Ring', icon: 'üí†' },
      weapon: { slot: 'weapon', name: 'Cryo Rod', icon: 'ü™Ñ', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Frozen Spikes: After the enemy is unfrozen, create an explosion and deal 120% cryo damage to that enemy.' },
      4: { desc: 'Freezed enemies take +20% damage' },
      6: { desc: 'Ice Storm: If an enemy dies to cryo damage, freeze all enemies on the field for 5 seconds, this effect can only be activated every 30 seconds.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  emberkin: {
    name: 'Emberkin',
    element: 'fire',
    icon: 'üî•',
    weaponName: 'Inferno Blade',
    weaponDesc: 'Deals 120% fire damage, create a fire AOE for 10 seconds, enemy entering or within the fire AOE will immediately take fire damage over time equal to 20% fire damage every tick for 5 seconds.',
    items: {
      helmet: { slot: 'helmet', name: 'Emberkin Helmet', icon: 'üî•' },
      chestplate: { slot: 'chestplate', name: 'Emberkin Chestplate', icon: 'üåã' },
      leggings: { slot: 'leggings', name: 'Emberkin Leggings', icon: 'üí•' },
      boots: { slot: 'boots', name: 'Emberkin Boots', icon: 'üîÜ' },
      ring: { slot: 'ring', name: 'Emberkin Ring', icon: 'üåü' },
      weapon: { slot: 'weapon', name: 'Inferno Blade', icon: '‚öîÔ∏è', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Burn: Burning DoT scales by +8% of player ATK per tick.' },
      4: { desc: '+12% Fire DMG', FireDMG_pct: 12 },
      6: { desc: 'Ignite: After killing 10 enemies with fire damage, randomly creates 3 giant red pink-ish fire around the player that lasts for 10 seconds, enemy entering or within the fire AOE will immediately take fire damage over time equal to 65% fire damage every tick for 10 seconds.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  zephyr: {
    name: 'Zephyr',
    element: 'aether',
    icon: 'üåü',
    weaponName: 'Gale Daggers',
    weaponDesc: 'Deals 120% aether damage to an enemy, then split into 4 stars shooting randomly, each star deals 50% aether damage to enemy collide with the star.',
    items: {
      helmet: { slot: 'helmet', name: 'Zephyr Helmet', icon: 'ü™ñ' },
      chestplate: { slot: 'chestplate', name: 'Zephyr Chestplate', icon: 'ü¶∫' },
      leggings: { slot: 'leggings', name: 'Zephyr Leggings', icon: 'üëñ' },
      boots: { slot: 'boots', name: 'Zephyr Boots', icon: 'ü•æ' },
      ring: { slot: 'ring', name: 'Zephyr Ring', icon: 'üíç' },
      weapon: { slot: 'weapon', name: 'Gale Daggers', icon: 'üó°Ô∏è', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Blow: For each star collide to an enemy, create an explosion dealing 50% aether damage to surrounding enemies.' },
      4: { desc: '+2 stars' },
      6: { desc: 'Bounce: Stars after hit the first enemy, now bounces to another random enemy, for each enemy hit, deals 50% aether damage to enemy.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  }
};
// ========== RNG ==========
class RNG {
  constructor(seed) {
    this.useDeterministic = seed !== null && seed !== undefined;
    if (this.useDeterministic) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < seed.length; i++) {
        h = Math.imul(h ^ seed.charCodeAt(i), 16777619);
      }
      this.state = h >>> 0;
    }
  }

  rand() {
    if (!this.useDeterministic) return Math.random();
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }

  randInt(min, max) {
    return Math.floor(this.rand() * (max - min + 1)) + min;
  }

  randRange(a, b) {
    return a + this.rand() * (b - a);
  }

  weightedChoice(items, weights) {
    const total = weights.reduce((sum, w) => sum + w, 0);
    let r = this.rand() * total;
    for (let i = 0; i < items.length; i++) {
      r -= weights[i];
      if (r <= 0) return items[i];
    }
    return items[items.length - 1];
  }
}

// ========== Game State ==========
const GameState = {
  rng: null,
  player: null,
  enemies: [],
  shop: null,
  worldProgress: null,
  lastSaveTime: 0,
  waveTimer: 0,
  suspendWaves: false,
  autoAttackTimer: 0,
  enemyIdCounter: 0,
  itemIdCounter: 0,

  // Death system
  isDead: false,
  deathTimer: 0,
  isInvincible: false,
  invincibilityTimer: 0,
  canAttack: true,
  inBossChallenge: false,
  
  // Dynamic challenge system
  currentChallenge: null,
  challengeProgress: {
    enemiesKilled: 0,
    elitesKilled: 0,
    wavesCompleted: 0,
    bossKilled: false,
    died: false,
    startTime: 0,
    timeLimit: 60
  }
};

// ========== Data Models ==========
function createPlayer() {
  return {
    coins: 0,
    gems: 0,
    level: 1,
    exp: 0,
    world: 1,
    hp: 100,
    maxHp: 100,
    inventory: [],
    equipment: { helmet:null, chestplate:null, leggings:null, boots:null, ring:null, weapon:null },
    baseStats: { ATK:100, HP:100, SPD:10, DMG_PCT:100, CRIT_RATE_PCT:5, CRIT_DMG_PCT:100 },
    currentStats: {},
    activeEffects: [],
    luck: 0,
    statistics: {
      totalKills: 0,
      totalDamageDealt: 0,
      totalDamageTaken: 0,
      totalCoinsEarned: 0,
      totalGemsEarned: 0,
      totalExpGained: 0,
      bossesDefeated: 0,
      deaths: 0,
      criticalHits: 0,
      itemsFound: 0,
      itemsPurchased: 0,
      worldsCompleted: 0,
      totalPlayTime: 0,
      sessionStartTime: Date.now()
    }
  };
}

function createShop() {
  return {
    lastRefreshTs: Date.now(),
    offers: { equipment: [], consumables: [] },
    manualCooldownEndTs: 0
  };
}

function createWorldProgress() {
  return {
    enemiesKilledThisWorld: 0,
    elitesKilledThisWorld: 0,
    requiredEnemies: 25,
    requiredElites: 1,
    requiredLevel: 3,
    equipmentRequirement: { minRarity: 'rare', required: false }
  };
}

// ========== Derived Stats ==========
function computeDerivedStats() {
  const p = GameState.player;
  const base = p.baseStats;

  let sumFlatATK = 0, sumFlatHP = 0, sumFlatSPD = 0;
  let sumATKPct = 0, sumHPPct = 0, sumDMGPct = 0;
  let sumCritRate = 0, sumCritDmg = 0;
  let luck = 0;

  Object.values(p.equipment).forEach(item => {
    if (!item) return;

    // Add safety check for baseAttribute
    const attr = item.baseAttribute;
    if (attr && attr.name) {
      if (attr.name === 'ATK') sumFlatATK += attr.value;
      else if (attr.name === 'HP') sumFlatHP += attr.value;
      else if (attr.name === 'SPD') sumFlatSPD += attr.value;
      else if (attr.name === 'DMG%') sumDMGPct += attr.value;
      else if (attr.name === 'ATK%') sumATKPct += attr.value;
      else if (attr.name === 'HP%') sumHPPct += attr.value;
    }

    // Add from item.stats if baseAttribute doesn't exist (for debug-granted items)
    if (item.stats) {
      if (item.stats.ATK) sumFlatATK += item.stats.ATK;
      if (item.stats.HP) sumFlatHP += item.stats.HP;
      if (item.stats.SPD) sumFlatSPD += item.stats.SPD;
    }

    // Add safety check for affixes
    if (item.affixes && Array.isArray(item.affixes)) {
      item.affixes.forEach(affix => {
        if (affix.locked) return;

        if (affix.name === 'ATK') sumFlatATK += affix.value;
        else if (affix.name === 'HP') sumFlatHP += affix.value;
        else if (affix.name === 'SPD') sumFlatSPD += affix.value;
        else if (affix.name === 'DMG%') sumDMGPct += affix.value;
        else if (affix.name === 'ATK%') sumATKPct += affix.value;
        else if (affix.name === 'HP%') sumHPPct += affix.value;
        else if (affix.name === 'Crit Rate') sumCritRate += affix.value;
        else if (affix.name === 'Crit Damage') sumCritDmg += affix.value;
      });
    }
  });

  // Count equipped set pieces
  const setCounts = {};
  Object.values(p.equipment).forEach(item => {
    if (item && item.setId) {
      setCounts[item.setId] = (setCounts[item.setId] || 0) + 1;
    }
  });

  // Initialize set tracking
  p.activeSets = setCounts;
  p.elementalDMG = {};
  p.dmgReduction = 0;

  // Apply set bonuses
  Object.keys(setCounts).forEach(setId => {
    const count = setCounts[setId];
    // Safety check: Skip if set doesn't exist in EQUIPMENT_SETS
    if (!EQUIPMENT_SETS[setId]) return;
    const setData = EQUIPMENT_SETS[setId];
    if (!setData) return;

    // 2-piece bonus
    if (count >= 2 && setData.bonuses[2]) {
      const bonus = setData.bonuses[2];
      if (bonus.ATK_pct) sumATKPct += bonus.ATK_pct;
      if (bonus.HP_pct) sumHPPct += bonus.HP_pct;
      if (bonus.SPD_pct) sumFlatSPD *= (1 + bonus.SPD_pct / 100);
      if (bonus.DMG_reduction_pct) p.dmgReduction += bonus.DMG_reduction_pct / 100;
      if (bonus.AetherDMG_pct) p.elementalDMG.aether = (p.elementalDMG.aether || 0) + bonus.AetherDMG_pct / 100;
    }

    // 4-piece bonus
    if (count >= 4 && setData.bonuses[4]) {
      const bonus = setData.bonuses[4];
      if (bonus.WindDMG_pct) p.elementalDMG.wind = (p.elementalDMG.wind || 0) + bonus.WindDMG_pct / 100;
      if (bonus.LightningDMG_pct) p.elementalDMG.lightning = (p.elementalDMG.lightning || 0) + bonus.LightningDMG_pct / 100;
      if (bonus.FireDMG_pct) p.elementalDMG.fire = (p.elementalDMG.fire || 0) + bonus.FireDMG_pct / 100;
      if (bonus.DMG_reduction_pct) p.dmgReduction += bonus.DMG_reduction_pct / 100;
    }

    // 5-piece: Nightwing coin bonus
    if (count >= 5 && setId === 'nightwing') {
      const coinBonus = Math.min(Math.floor(p.coins / 2000), 5000);
      sumFlatATK += coinBonus;
    }
  });

  Object.keys(setCounts).forEach(setId => {
    const count = setCounts[setId];
    if (count >= 6 && setId === 'nightwing') {
      const wealthStacks = (p.setBonusTracking && p.setBonusTracking.nightwing && p.setBonusTracking.nightwing.wealthStacks) || 0;
      sumDMGPct += wealthStacks * 20;
    }
    if (count >= 6 && setId === 'bastion') {
      const currentHp = p.hp || 0;
      const maxHp = p.maxHp || p.HP_max || 1;
      if (currentHp < maxHp * 0.5) sumDMGPct += 20;
    }
    if (count >= 6 && setId === 'shade') {
      const bloodthirstStacks = (p.setBonusTracking && p.setBonusTracking.shade && p.setBonusTracking.shade.bloodthirstStacks) || 0;
      sumDMGPct += bloodthirstStacks * 2;
    }
  });

  p.activeEffects.forEach(effect => {
    if (effect.id === 'spd_boost_200') {
      sumFlatSPD *= effect.params.multiplier;
    }
    if (effect.id === 'luck_boost_50') {
      luck += effect.params.value;
    }
  });

  const finalATK = Math.floor((base.ATK + sumFlatATK) * (1 + sumATKPct / 100));
  const finalHP = Math.floor((base.HP + sumFlatHP) * (1 + sumHPPct / 100));
  const finalSPD = base.SPD + sumFlatSPD;
  const finalDMGPct = base.DMG_PCT + sumDMGPct;
  const finalCritRate = Math.max(0, Math.min(100, base.CRIT_RATE_PCT + sumCritRate));
  const finalCritDmg = Math.max(0, base.CRIT_DMG_PCT + sumCritDmg);

  // BASTION 6-PIECE: Metal Fierce - +20% DMG when player <50% HP
  let bastionDmgMultiplier = 1.0;
  if (getSetCount('bastion') >= 6) {
    const currentHP = getPlayerHP(p);
    const maxHP = p.maxHp || finalHP || 1;
    if (currentHP < maxHP * 0.50) {
      bastionDmgMultiplier = 1.20;
    }
  }

  // Calculate bonuses from items (difference from base stats)
  const atkBonus = finalATK - base.ATK;
  const hpBonus = finalHP - base.HP;
  const spdBonus = finalSPD - base.SPD;
  const dmgBonus = (finalDMGPct * bastionDmgMultiplier) - base.DMG_PCT;

  p.currentStats = { finalATK, finalHP, finalSPD, finalDMGPct: finalDMGPct * bastionDmgMultiplier, finalCritRate, finalCritDmg };
  p.statBonuses = { atkBonus, hpBonus, spdBonus, dmgBonus };
  p.luck = luck;

  p.maxHp = finalHP;
  if (p.hp > p.maxHp) p.hp = p.maxHp;
}

// ========== Attack & Damage ==========
function getAttackInterval() {
  const spd = GameState.player.currentStats.finalSPD;
  return Math.max(CONFIG.MIN_ATTACK_INTERVAL_S, CONFIG.ATTACK_INTERVAL_DIVISOR / spd);
}

function computeDamage(enemy) {
  const p = GameState.player;
  let baseDamage = p.currentStats.finalATK * (p.currentStats.finalDMGPct / 100);

  const dmgBoost = p.activeEffects.find(e => e.id === 'dmg_boost_200');
  if (dmgBoost) {
    baseDamage *= dmgBoost.params.multiplier;
  }

  const isCrit = GameState.rng.rand() < p.currentStats.finalCritRate / 100;
  if (isCrit) {
    baseDamage *= (1 + p.currentStats.finalCritDmg / 100);
    // Track critical hits
    if (p.statistics) {
      p.statistics.criticalHits++;
    }
  }

  const appliedDamage = Math.max(1, Math.floor(baseDamage * Math.max(0.05, 1 - enemy.resistancePct / 100)));

  // Track total damage dealt
  if (p.statistics) {
    p.statistics.totalDamageDealt += appliedDamage;
  }

  return { damage: appliedDamage, crit: isCrit };
}

function computePlayerDamage() {
  const p = GameState.player;
  let baseDamage = p.currentStats.finalATK * (p.currentStats.finalDMGPct / 100);

  const dmgBoost = p.activeEffects.find(e => e.id === 'dmg_boost_200');
  if (dmgBoost) {
    baseDamage *= dmgBoost.params.multiplier;
  }

  return Math.floor(baseDamage);
}

function dealDamageToPlayer(amount) {
  // Don't take damage if dead or invincible
  if (GameState.isDead || GameState.isInvincible) return;

  const oldHP = GameState.player.hp;
  GameState.player.hp = Math.max(0, GameState.player.hp - amount);
  trackShadeHPChange(GameState.player.hp - oldHP);

  // Track damage taken
  if (GameState.player.statistics) {
    GameState.player.statistics.totalDamageTaken += amount;
  }
  if (GameState.player.hp <= 0) {
    handlePlayerDeath();
  }
}

function handlePlayerDeath() {
  GameState.isDead = true;
  GameState.canAttack = false;
  GameState.player.hp = 0;

  // Track challenge death
  trackDeath();

  // Track death
  if (GameState.player.statistics) {
    GameState.player.statistics.deaths++;
  }

  // Check if in boss challenge
  if (GameState.inBossChallenge) {
    // Boss challenge failed
    GameState.deathTimer = 3; // 3 seconds for boss failure screen
    handleBossChallengeFailed();
  } else {
    // Normal death
    GameState.deathTimer = 5; // 5 seconds death screen

    // Show death screen
    const deathScreen = document.getElementById('death-screen');
    if (deathScreen) {
      deathScreen.classList.add('active');
    }
  }

  // Make player invisible
  const player = document.getElementById('player');
  if (player) {
    player.style.opacity = '0';
  }
}

function updateDeathSystem(dt) {
  // Update death timer
  if (GameState.isDead) {
    GameState.deathTimer -= dt;

    if (GameState.inBossChallenge) {
      // No need to update timer display for boss failure (handled separately)
      console.log('Boss challenge death timer:', GameState.deathTimer); // Debug log
    } else {
      // Update respawn timer display for normal death
      const respawnTimer = document.getElementById('respawn-timer');
      if (respawnTimer) {
        const seconds = Math.ceil(GameState.deathTimer);
        respawnTimer.textContent = `Respawning in ${seconds} second${seconds !== 1 ? 's' : ''}...`;
      }
    }

    if (GameState.deathTimer <= 0) {
      console.log('Death timer reached 0, inBossChallenge:', GameState.inBossChallenge); // Debug log
      if (GameState.inBossChallenge) {
        returnFromBossChallenge();
      } else {
        respawnPlayer();
      }
    }
  }

  // Update invincibility timer
  if (GameState.isInvincible) {
    GameState.invincibilityTimer -= dt;

    if (GameState.invincibilityTimer <= 0) {
      GameState.isInvincible = false;
      const player = document.getElementById('player');
      if (player) {
        player.classList.remove('flashing');
      }
    }
  }
}

function respawnPlayer() {
  // Restore player HP
  GameState.player.hp = GameState.player.maxHp;
  GameState.isDead = false;
  GameState.isInvincible = true;
  GameState.invincibilityTimer = 3; // 3 seconds of invincibility
  GameState.canAttack = true;

  // Hide death screen
  const deathScreen = document.getElementById('death-screen');
  if (deathScreen) {
    deathScreen.classList.remove('active');
  }

  // Make player visible and flashing
  const player = document.getElementById('player');
  if (player) {
    player.style.opacity = '1';
    player.classList.add('flashing');
  }

  // Create damage burst effect
  createDamageBurst();

  // Deal AOE damage to all enemies (300% of player damage)
  dealRespawnDamage();
}


function handleBossChallengeFailed() {
  // Clear boss challenge flags FIRST to prevent onBossDefeated from triggering
  GameState.suspendWaves = false;

  // Show boss failure screen
  const bossFailureScreen = document.getElementById('boss-failure-screen');
  if (bossFailureScreen) {
    bossFailureScreen.classList.add('active');
  }

  // Update world display
  const worldSpan = document.getElementById('boss-failure-world');
  if (worldSpan) {
    worldSpan.textContent = GameState.player.world;
  }

  // Remove all enemies (boss)
  GameState.enemies = [];

  showNotification('üíÄ Boss challenge failed!', 'danger');
}

function returnFromBossChallenge() {
  console.log('returnFromBossChallenge called'); // Debug log

  // Clear boss challenge state (suspendWaves already cleared in handleBossChallengeFailed)
  GameState.inBossChallenge = false;
  GameState.isDead = false;
  GameState.canAttack = true;

  // Restore player HP
  GameState.player.hp = GameState.player.maxHp;

  // Hide boss failure screen
  const bossFailureScreen = document.getElementById('boss-failure-screen');
  console.log('Boss failure screen element:', bossFailureScreen); // Debug log
  if (bossFailureScreen) {
    bossFailureScreen.classList.remove('active');
    console.log('Removed active class from boss failure screen'); // Debug log
  }

  // Make player visible
  const player = document.getElementById('player');
  if (player) {
    player.style.opacity = '1';
  }

  // Update world progress UI
  updateWorldProgress();

  // Resume normal wave spawning
  GameState.waveTimer = 0;
  spawnWave();

  showNotification(`Returned to World ${GameState.player.world}`, 'info');
}
function createDamageBurst() {
  const stage = document.getElementById('stage');
  const playerContainer = document.getElementById('player-container');

  if (!stage || !playerContainer) return;

  const rect = playerContainer.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const burst = document.createElement('div');
  burst.className = 'damage-burst';
  burst.style.left = (rect.left - stageRect.left + rect.width / 2) + 'px';
  burst.style.top = (rect.top - stageRect.top + rect.height / 2) + 'px';

  stage.appendChild(burst);

  // Remove after animation completes
  setTimeout(() => {
    if (burst.parentNode) {
      burst.parentNode.removeChild(burst);
    }
  }, 800);
}

function dealRespawnDamage() {
  const playerDamage = computePlayerDamage();
  const respawnDamage = Math.floor(playerDamage * 3); // 300% damage

  GameState.enemies.forEach(enemy => {
    // Visual feedback for each enemy
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`) ||
                    document.querySelector(`[data-boss-id="${enemy.id}"]`) ||
                    document.querySelector(`[data-entity-id="${enemy.id}"]`);

    if (enemyEl) {
      // Flash effect on enemy
      enemyEl.style.filter = 'brightness(2) saturate(0)';
      setTimeout(() => {
        enemyEl.style.filter = '';
      }, 200);
    }

    // Deal damage
    enemy.hp -= respawnDamage;

    // Show damage number
    if (enemyEl) {
      showFloatingDamage(respawnDamage, false, enemyEl);
    }
  });

  // Filter out dead enemies
  GameState.enemies = GameState.enemies.filter(enemy => {
    if (enemy.hp <= 0) {
      onEnemyDeath(enemy);
      return false;
    }
    return true;
  });
}

// ========== Equipment Generation ==========
const SLOT_ICONS = {
  helmet: '‚õëÔ∏è',
  chestplate: 'üõ°Ô∏è',
  leggings: 'üëñ',
  boots: 'üë¢',
  ring: 'üíç',
  weapon: '‚öîÔ∏è'
};

const RARITY_RANGES = {
  common: {
    HP: [10, 50], 'HP%': [2, 5], ATK: [10, 50], 'ATK%': [2, 5],
    SPD: [2, 5], 'DMG%': [5, 10], 'Crit Rate': [5, 10], 'Crit Damage': [10, 50]
  },
  uncommon: {
    HP: [75, 150], 'HP%': [5, 8], ATK: [75, 150], 'ATK%': [5, 8],
    SPD: [5, 10], 'DMG%': [10, 20], 'Crit Rate': [5, 15], 'Crit Damage': [25, 75]
  },
  rare: {
    HP: [250, 500], 'HP%': [8, 10], ATK: [250, 500], 'ATK%': [8, 10],
    SPD: [10, 15], 'DMG%': [20, 30], 'Crit Rate': [5, 20], 'Crit Damage': [50, 100]
  },
  epic: {
    HP: [500, 1000], 'HP%': [10, 15], ATK: [500, 1000], 'ATK%': [10, 15],
    SPD: [15, 20], 'DMG%': [30, 50], 'Crit Rate': [5, 25], 'Crit Damage': [75, 150]
  },
  legendary: {
    HP: [1250, 2500], 'HP%': [15, 25], ATK: [1250, 2500], 'ATK%': [15, 25],
    SPD: [20, 25], 'DMG%': [50, 75], 'Crit Rate': [5, 30], 'Crit Damage': [100, 200]
  },
  mythic: {
    HP: [2500, 5000], 'HP%': [25, 35], ATK: [2500, 5000], 'ATK%': [25, 35],
    SPD: [25, 35], 'DMG%': [75, 100], 'Crit Rate': [5, 35], 'Crit Damage': [100, 250]
  }
};

const AFFIX_POOL = [
  { name: 'HP', weight: 50 },
  { name: 'HP%', weight: 50 },
  { name: 'ATK', weight: 50 },
  { name: 'ATK%', weight: 50 },
  { name: 'SPD', weight: 35 },
  { name: 'DMG%', weight: 35 },
  { name: 'Crit Rate', weight: 15 },
  { name: 'Crit Damage', weight: 15 }
];

function generateEquipment(slot, rarity, world, setId = null) {
  const ranges = RARITY_RANGES[rarity];

  // If setId provided, generate set item
  if (setId && EQUIPMENT_SETS[setId]) {
    const setData = EQUIPMENT_SETS[setId];
    if (!setData) {
      console.warn(`Invalid setId "${setId}" in generateEquipment, falling back to normal item`);
      setId = null;
    } else {
    const setItem = setData.items[slot];

    if (setItem) {
      const item = {
        id: `item_${GameState.itemIdCounter++}`,
        type: 'equipment',
        slot: setItem.slot,
        name: setItem.name,
        icon: setItem.icon,
        rarity: rarity,
        level: 1,
        stars: 0,
        setId: setId,
        setName: setData.name,
        element: setData.element,
        baseAttribute: { name: slot === 'helmet' || slot === 'weapon' ? 'ATK' : slot === 'boots' ? 'SPD' : slot === 'ring' ? 'DMG%' : 'HP', value: 0 },
        affixes: [],
        buyPrice: 0,
        sellPrice: 0,
        createdAtWorld: world
      };

      // Generate base attribute value
      const baseAttrName = item.baseAttribute.name;
      const baseRange = ranges[baseAttrName];
      item.baseAttribute.value = GameState.rng.randInt(baseRange[0], baseRange[1]);

      // Generate affixes
      const availableAffixes = [...AFFIX_POOL];
      for (let i = 0; i < 4; i++) {
        const weights = availableAffixes.map(a => a.weight);
        const chosenAffix = GameState.rng.weightedChoice(availableAffixes, weights);
        const idx = availableAffixes.indexOf(chosenAffix);
        availableAffixes.splice(idx, 1);

        const range = ranges[chosenAffix.name];
        const value = GameState.rng.randInt(range[0], range[1]);
        const unlockLevel = (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS[i] !== undefined)
          ? CONFIG.STAR_THRESHOLDS[i]
          : (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS.length
              ? CONFIG.STAR_THRESHOLDS[CONFIG.STAR_THRESHOLDS.length - 1] + (i - (CONFIG.STAR_THRESHOLDS.length - 1)) * 10
              : 10 + i * 10);

        item.affixes.push({
          name: chosenAffix.name,
          value: value,
          locked: true,
          unlockLevel: unlockLevel
        });
      }

      // Set weapon properties
      if (setItem.isWeapon && setItem.multiplier) {
        item.isWeapon = true;
        item.weaponMultiplier = setItem.multiplier;
      }

      // Calculate prices (set items are more expensive)
      item.buyPrice = Math.floor(CONFIG.BASE_SHOP_PRICE[rarity] * 1.5 * (1 + world * 0.1) * GameState.rng.randRange(0.9, 1.1));
      item.sellPrice = Math.floor(item.buyPrice * 0.3);

      return item;
    }
    }
  }

  // Original random equipment generation
  let baseAttrName;
  if (slot === 'helmet') baseAttrName = 'ATK';
  else if (slot === 'chestplate') baseAttrName = 'HP';
  else if (slot === 'leggings') baseAttrName = 'HP';
  else if (slot === 'boots') baseAttrName = 'SPD';
  else if (slot === 'ring') baseAttrName = 'DMG%';
  else if (slot === 'weapon') baseAttrName = 'ATK';

  const baseRange = ranges[baseAttrName];
  const baseValue = GameState.rng.randInt(baseRange[0], baseRange[1]);

  const affixes = [];
  const availableAffixes = [...AFFIX_POOL];
  for (let i = 0; i < 4; i++) {
    const weights = availableAffixes.map(a => a.weight);
    const chosenAffix = GameState.rng.weightedChoice(availableAffixes, weights);
    const idx = availableAffixes.indexOf(chosenAffix);
    availableAffixes.splice(idx, 1);

    const range = ranges[chosenAffix.name];
    const value = GameState.rng.randInt(range[0], range[1]);
    const unlockLevel = (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS[i] !== undefined)
      ? CONFIG.STAR_THRESHOLDS[i]
      : (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS.length
          ? CONFIG.STAR_THRESHOLDS[CONFIG.STAR_THRESHOLDS.length - 1] + (i - (CONFIG.STAR_THRESHOLDS.length - 1)) * 10
          : 10 + i * 10);

    affixes.push({
      name: chosenAffix.name,
      value: value,
      locked: true,
      unlockLevel: unlockLevel
    });
  }

  const buyPrice = Math.floor(CONFIG.BASE_SHOP_PRICE[rarity] * (1 + world * 0.1) * GameState.rng.randRange(0.9, 1.1));
  const sellPrice = Math.floor(buyPrice * 0.3);

  return {
    id: `item_${GameState.itemIdCounter++}`,
    type: 'equipment',
    slot: slot,
    name: `${rarity.charAt(0).toUpperCase() + rarity.slice(1)} ${slot.charAt(0).toUpperCase() + slot.slice(1)}`,
    rarity: rarity,
    level: 1,
    stars: 0,
    baseAttribute: { name: baseAttrName, value: baseValue },
    affixes: affixes,
    buyPrice: buyPrice,
    sellPrice: sellPrice,
    createdAtWorld: world
  };
}


function rollRarity() {
  const probs = CONFIG.RARITY_PROB;
  const total = Object.values(probs).reduce((sum, p) => sum + p, 0);
  const r = GameState.rng.rand() * total;

  let cumulative = 0;
  for (const [rarity, prob] of Object.entries(probs)) {
    cumulative += prob;
    if (r <= cumulative) return rarity;
  }
  return 'common';
}

// ========== Enemy Creation ==========
const ENEMY_BASE_HP = { small: 120, normal: 360, big: 600, elite: 1000, boss: 6000 };
const ENEMY_BASE_ATK = { small: 1, normal: 3, big: 6, elite: 10, boss: 30 };
const ENEMY_BASE_RESIST = { small: 0, normal: 2, big: 5, elite: 8, boss: 10 };
const ENEMY_ATTACK_INTERVAL = { small: 3.0, normal: 3.5, big: 4.5, elite: 3.0, boss: 2.5 };
const ENEMY_BASE_EXP = { small: 5, normal: 10, big: 25, elite: 50, boss: 100 };
const ENEMY_ICONS = { small: 'üêÄ', normal: 'üßü', big: 'üëπ', elite: 'üëø', boss: 'üêâ' };

function createEnemy(type, world, position) {
  // Progressive scaling - starts easier (2.5 HP scale, 1.15 ATK scale for worlds 1-3), 
  // then gets much harder (uses config values 2.75 HP, 1.5 ATK)
  const hpScale = world <= 3 ? 2.5 : CONFIG.ENEMY_HP_SCALE;
  const atkScale = world <= 3 ? 1.15 : CONFIG.ENEMY_ATK_SCALE;
  
  const hp = Math.floor(ENEMY_BASE_HP[type] * Math.pow(hpScale, world - 1));
  const atk = Math.floor(ENEMY_BASE_ATK[type] * Math.pow(atkScale, world - 1));
  const resist = ENEMY_BASE_RESIST[type] + (world - 1) * CONFIG.ENEMY_RESIST_BONUS_PER_WORLD;

  return {
    id: `enemy_${GameState.enemyIdCounter++}`,
    type: type,
    world: world,
    hp: hp,
    maxHp: hp,
    atk: atk,
    resistancePct: Math.min(95, resist),
    attackInterval: ENEMY_ATTACK_INTERVAL[type],
    position: position || randomEdgePosition(),
    speed: type === 'small' ? 80 : type === 'normal' ? 60 : type === 'big' ? 50 : type === 'elite' ? 70 : 40,
    engaged: false,
    engageTimer: 0,
    expValue: ENEMY_BASE_EXP[type] * world,
    dropProfile: {
      coinBase: CONFIG.ENEMY_BASE_COIN[type],
      gemChancePct: type === 'elite' ? 20 : type === 'boss' ? 100 : 0
    }
  };
}

function randomEdgePosition() {
  const stage = document.getElementById('stage');
  const w = stage.clientWidth;
  const h = stage.clientHeight;
  const side = GameState.rng.randInt(0, 3);

  if (side === 0) return { x: GameState.rng.randRange(0, w), y: -50 };
  if (side === 1) return { x: w + 50, y: GameState.rng.randRange(0, h) };
  if (side === 2) return { x: GameState.rng.randRange(0, w), y: h + 50 };
  return { x: -50, y: GameState.rng.randRange(0, h) };
}

// Continue in next part...
// ========== Enemy Update Logic ==========
function updateEnemies(dt) {
  const stage = document.getElementById('stage');
  const playerX = stage.clientWidth / 2;
  const playerY = stage.clientHeight / 2;

  GameState.enemies.forEach(enemy => {
    // Handle frozen state
    if (enemy.frozen && enemy.frozenTimer !== undefined) {
      enemy.frozenTimer -= dt;
      if (enemy.frozenTimer <= 0) {
        enemy.frozen = false;
        enemy.speed = enemy.originalSpeed || enemy.speed;
        delete enemy.frozenTimer;

        // Remove frozen visual effect
        const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
        if (enemyEl) {
          enemyEl.style.filter = '';
        }

        // 3-piece Glacier: Frozen Bomb - explosion after unfreezing
        if (getSetCount('glacier') >= 3) {
          const explosionDmg = Math.floor((GameState.player.currentStats?.finalATK || GameState.player.ATK) * 1.20);
          applyDamageToEnemy(enemy, explosionDmg, { type: 'cryo', source: 'frozen_bomb', setId: 'glacier' });

          const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
          if (enemyEl) {
            const rect = enemyEl.getBoundingClientRect();
            spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 60, getElementColor('cryo'), 300);
          }
        }
      } else {
        // Apply frozen visual effect
        const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
        if (enemyEl && !enemyEl.style.filter.includes('brightness')) {
          enemyEl.style.filter = 'brightness(1.5) saturate(0.3) hue-rotate(180deg)';
        }
      }
    }

    // Visual indicator for freeze-immune enemies (on cooldown)
    const now = Date.now();
    if (enemy.freezeCooldownUntil && now < enemy.freezeCooldownUntil) {
      const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
      if (enemyEl && !enemy.frozen) {
        // Add a subtle red tint to show immunity
        enemyEl.style.boxShadow = '0 0 10px rgba(255, 100, 100, 0.6)';
      }
    } else if (enemy.freezeCooldownUntil && now >= enemy.freezeCooldownUntil) {
      // Remove immunity visual
      const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
      if (enemyEl) {
        enemyEl.style.boxShadow = '';
      }
    }

    const dx = playerX - enemy.position.x;
    const dy = playerY - enemy.position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > CONFIG.ENGAGE_RADIUS_PX) {
      enemy.engaged = false;
      const ndx = dx / distance;
      const ndy = dy / distance;
      enemy.position.x += ndx * enemy.speed * dt;
      enemy.position.y += ndy * enemy.speed * dt;
    } else {
      if (!enemy.engaged) {
        enemy.engaged = true;
        enemy.engageTimer = 0;
      }
      enemy.engageTimer += dt;
      if (enemy.engageTimer >= enemy.attackInterval) {
        enemy.engageTimer -= enemy.attackInterval;
        dealDamageToPlayer(enemy.atk);
      }
    }
  });

  GameState.enemies = GameState.enemies.filter(enemy => {
    if (enemy.hp <= 0) {
      onEnemyDeath(enemy);
      return false;
    }
    return true;
  });
}

// ========== Death & Drops ==========
function onEnemyDeath(enemy) {
  const p = GameState.player;

  // Track challenge progress
  trackChallengeProgress(enemy);

  // Track statistics
  if (p.statistics) {
    p.statistics.totalKills++;
    if (enemy.type === 'boss') {
      p.statistics.bossesDefeated++;
    }
  }

  p.exp += enemy.expValue;
  if (p.statistics) {
    p.statistics.totalExpGained += enemy.expValue;
  }

  let coins = Math.floor(
    enemy.dropProfile.coinBase *
    (1 + p.world * 0.5) *
    GameState.rng.randRange(0.8, 1.2) *
    (1 + p.luck / 100)
  );

  const coinsBoost = p.activeEffects.find(e => e.id === 'coins_boost_200');
  if (coinsBoost) coins *= coinsBoost.params.multiplier;

  if (getSetCount('nightwing') >= 3) coins *= 1.5;

  p.coins += Math.floor(coins);
  if (p.statistics) {
    p.statistics.totalCoinsEarned += Math.floor(coins);
  }
  showFloatingChange(coins, 'coins');

  if (enemy.type === 'elite' && GameState.rng.rand() < enemy.dropProfile.gemChancePct / 100) {
    const gemAmount = 1 + Math.floor(p.world / 5);
    p.gems += gemAmount;
    if (p.statistics) {
      p.statistics.totalGemsEarned += gemAmount;
    }
    showFloatingChange(gemAmount, 'gems');
  }
  if (enemy.type === 'boss') {
    const gemAmount = 1 + Math.floor(p.world / 5);
    p.gems += gemAmount;
    if (p.statistics) {
      p.statistics.totalGemsEarned += gemAmount;
    }
    showFloatingChange(gemAmount, 'gems');
  }

  const baseChance = CONFIG.BASE_EQUIP_DROP_CHANCE_PCT[enemy.type] || 0;
  const finalChance = (baseChance / 100) * (1 + p.luck / 100);

  if (GameState.rng.rand() < finalChance) {
    const rarity = rollRarity();
    const slots = ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon'];
    const slot = slots[GameState.rng.randInt(0, slots.length - 1)];
    const item = generateEquipment(slot, rarity, p.world);
    addToInventory(item);
    if (p.statistics) {
      p.statistics.itemsFound++;
    }
  }

  GameState.worldProgress.enemiesKilledThisWorld++;
  if (enemy.type === 'elite' || enemy.type === 'boss') {
    GameState.worldProgress.elitesKilledThisWorld++;
  }

  showDrop(enemy.position, 'üí∞');

  handleSetBonusOnKill(enemy);

  checkLevelUp();
  updateWorldProgress();
}

function checkLevelUp() {
  const p = GameState.player;
  const expNeeded = 100 * Math.pow(1.5, p.level - 1);

  while (p.exp >= expNeeded) {
    p.exp -= expNeeded;
    p.level++;
    p.baseStats.ATK += 10;
    p.baseStats.HP += 20;
    p.baseStats.SPD += 1;
    computeDerivedStats();
    p.hp = p.maxHp;
    showNotification(`‚≠ê Level Up! You are now level ${p.level}`, 'success');
  }
}

// ========== Wave Spawning ==========
function spawnWave() {
  if (GameState.suspendWaves) return;

  // Limit max enemies on screen to 50
  if (GameState.enemies.length >= 50) {
    return;
  }

  // Track wave completion for survival challenge (previous wave completed if no enemies)
  if (GameState.currentChallenge === 'SURVIVAL' && GameState.enemies.length === 0) {
    trackWaveCompletion();
  }

  const p = GameState.player;
  const count = Math.max(CONFIG.MIN_WAVE_ENEMIES, Math.min(
    CONFIG.MAX_WAVE_ENEMIES,
    CONFIG.MIN_WAVE_ENEMIES + p.world + Math.floor(p.level / 5)
  ));

  const typeWeights = { small: 30, normal: 50, big: 15, elite: 5 };

  // Only spawn enemies up to the 50 limit
  const maxToSpawn = Math.min(count, 50 - GameState.enemies.length);

  for (let i = 0; i < maxToSpawn; i++) {
    const type = GameState.rng.weightedChoice(
      Object.keys(typeWeights),
      Object.values(typeWeights)
    );
    const enemy = createEnemy(type, p.world);
    GameState.enemies.push(enemy);
  // initialize previous render position
  enemy.prevX = enemy.position.x;
  enemy.prevY = enemy.position.y;

  }
}

// ========== Inventory Management ==========
function cleanInventory() {
  // Don't compact the inventory - we use sparse arrays for visual positioning
  // Just ensure no undefined values cause issues
  // Keep the array sparse but valid
  if (GameState.player && GameState.player.inventory) {
    // Only remove completely invalid entries, keep the structure
    for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
      if (GameState.player.inventory[i] === null) {
        delete GameState.player.inventory[i];
      }
    }
  }
}

function getInventoryCount() {
  // Count actual items in inventory (non-null, non-undefined)
  if (!GameState.player || !GameState.player.inventory) return 0;
  let count = 0;
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] != null) {
      count++;
    }
  }
  return count;
}

function addToInventory(item) {
  cleanInventory();
  if (getInventoryCount() >= CONFIG.MAX_INVENTORY_SLOTS) {
    showNotification('‚ö†Ô∏è Inventory full!', 'warning');
    return false;
  }

  // Find first empty slot
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] == null) {
      GameState.player.inventory[i] = item;
      showNotification(`üì¶ Obtained: ${item.name}`, 'info');
      return true;
    }
  }

  showNotification('‚ö†Ô∏è Inventory full!', 'warning');
  return false;
}

function equipItem(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  const slot = item.slot;
  const currentItem = GameState.player.equipment[slot];

  // Find and remove the item from inventory (sparse array)
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      delete GameState.player.inventory[i];
      break;
    }
  }

  // Equip the new item
  GameState.player.equipment[slot] = item;

  // If there was an old equipped item, add it to first empty inventory slot
  if (currentItem) {
    for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
      if (GameState.player.inventory[i] == null) {
        GameState.player.inventory[i] = currentItem;
        break;
      }
    }
  }

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();
  hideTooltip();
}

function unequipItem(slot) {
  const item = GameState.player.equipment[slot];
  if (!item) return;

  cleanInventory();
  if (getInventoryCount() >= CONFIG.MAX_INVENTORY_SLOTS) {
    showNotification('‚ö†Ô∏è Inventory full!', 'warning');
    return;
  }

  // Find first empty slot
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] == null) {
      GameState.player.inventory[i] = item;
      GameState.player.equipment[slot] = null;

      computeDerivedStats();
      renderInventory();
      renderPlayerStats();
      hideTooltip();
      return;
    }
  }
}

function sellItem(itemId) {
  const item = findItem(itemId);
  if (!item) return;

  GameState.player.coins += item.sellPrice;
  showFloatingChange(item.sellPrice, 'coins');

  // Remove from sparse inventory
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      delete GameState.player.inventory[i];
      break;
    }
  }

  // Also check if item is equipped and remove it from equipment slot
  if (item.type === 'equipment') {
    for (const slot in GameState.player.equipment) {
      if (GameState.player.equipment[slot]?.id === itemId) {
        GameState.player.equipment[slot] = null;
        computeDerivedStats();
        renderPlayerStats();
        break;
      }
    }
  }

  renderInventory();
  hideTooltip();
  showNotification(`üí∞ Sold for ${item.sellPrice} coins`, 'success');
}

function upgradeItem(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  // cap item level at 100
  if (typeof item.level === 'number' && item.level >= 100) {
    showNotification('‚ö†Ô∏è Item is already at max level (100)!', 'warning');
    return;
  }

  const cost = getUpgradeCost(item);
  if (GameState.player.coins < cost.coins) {
    showNotification('‚ö†Ô∏è Not enough coins!', 'warning');
    return;
  }
  if (GameState.player.gems < cost.gems) {
    showNotification('‚ö†Ô∏è Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state BEFORE any operations
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  GameState.player.coins -= cost.coins;
  showFloatingChange(-cost.coins, 'coins');
  GameState.player.gems -= cost.gems;
  showFloatingChange(-cost.gems, 'gems');

  // increment, but do not exceed 100
  item.level = Math.min(100, (item.level || 0) + 1);

  if (CONFIG.STAR_THRESHOLDS.includes(item.level)) {
    item.stars++;
    showNotification(`‚≠ê ${item.name} reached ${item.stars} stars!`, 'legendary');
  }

  // Unlock affixes when their required level is reached
  item.affixes.forEach(aff => {
    if (aff.locked && typeof aff.unlockLevel === 'number' && item.level >= aff.unlockLevel) {
      aff.locked = false;
      showNotification(`üîì New attribute unlocked for ${item.name}: ${aff.name}!`, 'info');
    }
  });

  // Upgrade stat increase - balanced formula
  // Give a small base increase + a tiny percentage (2-3%) to scale moderately
  const rarityMultiplier = { common: 1, uncommon: 1.2, rare: 1.5, epic: 2, legendary: 2.5, mythic: 3 };
  const baseIncrease = Math.ceil(2 * (rarityMultiplier[item.rarity] || 1));
  const percentBoost = Math.floor(item.baseAttribute.value * 0.025); // 2.5% instead of 10%
  const totalIncrease = Math.max(1, baseIncrease + percentBoost);
  item.baseAttribute.value += totalIncrease;

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    // Use requestAnimationFrame to ensure DOM is fully updated
    requestAnimationFrame(() => {
      try {
        // Find the slot element for this item
        let slotEl = null;
        if (tooltipIsEquipped) {
          // Item is equipped - find the equipment slot
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          // Item is in inventory - find the inventory slot (need to search properly in sparse array)
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (GameState.player.inventory[i] && GameState.player.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex !== -1) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }

        // Re-show the tooltip to keep it visible
        if (slotEl) {
          showItemTooltip(item, slotEl, tooltipIsEquipped);
        }
      } catch (e) {
        console.warn('Failed to update tooltip after upgrade:', e);
      }
    });
  }
}

function getUpgradeCost(item) {
  const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
  const coins = Math.floor(baseCost * Math.pow(1.06, item.level - 1));

  const nextLevel = item.level + 1;
  let gems = 0;
  if (CONFIG.STAR_THRESHOLDS.includes(nextLevel)) {
    gems = CONFIG.STAR_GEM_COSTS[nextLevel.toString()] || 0;
  }

  return { coins, gems };
}

function useConsumable(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'consumable') return;

  // Remove from sparse inventory
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      delete GameState.player.inventory[i];
      break;
    }
  }

  const effect = {
    id: item.effectId,
    startedAtTs: Date.now(),
    durationSec: item.duration,
    params: item.params
  };
  GameState.player.activeEffects.push(effect);

  computeDerivedStats();
  renderInventory();
  hideTooltip();
  showNotification(`üß™ Consumed: ${item.name}`, 'success');
}

function findItem(itemId) {
  // Search in sparse inventory array
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      return GameState.player.inventory[i];
    }
  }

  // Search in equipment
  for (const slot in GameState.player.equipment) {
    if (GameState.player.equipment[slot]?.id === itemId) {
      return GameState.player.equipment[slot];
    }
  }

  return null;
}

// ========== Shop System ==========
const CONSUMABLES = [
  { id: 'exp_boost_200', name: 'EXP Boost x3', icon: 'üìö', effectId: 'exp_boost_200', params: { multiplier: 3 } },
  { id: 'dmg_boost_200', name: 'Damage Boost x3', icon: '‚ö°', effectId: 'dmg_boost_200', params: { multiplier: 3 } },
  { id: 'coins_boost_200', name: 'Coins Boost x3', icon: 'üí∞', effectId: 'coins_boost_200', params: { multiplier: 3 } }
];

function refreshShop() {
  const shop = GameState.shop;
  shop.offers.equipment = [];
  shop.offers.consumables = [];

  const slots = ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon'];
  const setIds = Object.keys(EQUIPMENT_SETS);
  for (let i = 0; i < 6; i++) {
    const slot = slots[i % slots.length];
    const rarity = rollRarity();
    // 30% chance to generate a set item
    const isSetItem = GameState.rng.rand() < 0.50; // Increased set item rate
    const setId = isSetItem ? setIds[Math.floor(GameState.rng.rand() * setIds.length)] : null;
    const item = generateEquipment(slot, rarity, GameState.player.world, setId);
    shop.offers.equipment.push(item);
  }


  CONSUMABLES.forEach(cons => {
    shop.offers.consumables.push({
      id: `cons_${GameState.itemIdCounter++}`,
      type: 'consumable',
      name: cons.name,
      icon: cons.icon,
      effectId: cons.effectId,
      params: cons.params,
      duration: CONFIG.DEFAULT_CONSUMABLE_DURATION_S,
      price: 10,
      slot: null
    });
  });

  shop.lastRefreshTs = Date.now();
}

function buyShopItem(itemId) {
  // Find the item in shop offers
  const shop = GameState.shop;
  let item = shop.offers.equipment.find(i => i.id === itemId);
  if (!item) {
    item = shop.offers.consumables.find(i => i.id === itemId);
  }
  if (!item) {
    showNotification('‚ö†Ô∏è Item not found!', 'warning');
    return;
  }

  const p = GameState.player;
  const cost = item.type === 'consumable' ? item.price : item.buyPrice;
  const currency = item.type === 'consumable' ? 'gems' : 'coins';

  // Check if already sold out
  if (item.soldOut) {
    showNotification('‚ö†Ô∏è Item already sold!', 'warning');
    return;
  }

  if (currency === 'coins' && p.coins < cost) {
    showNotification('‚ö†Ô∏è Not enough coins!', 'warning');
    return;
  }
  if (currency === 'gems' && p.gems < cost) {
    showNotification('‚ö†Ô∏è Not enough gems!', 'warning');
    return;
  }

  cleanInventory();  // Clean before checking
  if (getInventoryCount() >= CONFIG.MAX_INVENTORY_SLOTS) {
    showNotification('‚ö†Ô∏è Inventory full!', 'warning');
    return;
  }

  if (currency === 'coins') {
    p.coins -= cost;
    showFloatingChange(-cost, 'coins');
  }
  else {
    p.gems -= cost;
    showFloatingChange(-cost, 'gems');
  }

  const itemCopy = { ...item, id: `item_${GameState.itemIdCounter++}` };

  // Find first empty slot
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (p.inventory[i] == null) {
      p.inventory[i] = itemCopy;
      break;
    }
  }

  // Track purchase
  if (p.statistics) {
    p.statistics.itemsPurchased++;
  }

  // Mark item as sold out
  item.soldOut = true;

  showNotification(`üõí Purchased: ${item.name}`, 'success');
  hideTooltip();
  renderShop();
  renderInventory();
}

// Continue in part 3...
// ========== UI Rendering ==========
function renderUI() {
  const p = GameState.player;

  document.getElementById('coins').textContent = Math.floor(p.coins).toLocaleString();
  document.getElementById('gems').textContent = Math.floor(p.gems).toLocaleString();
  document.getElementById('level').textContent = `Lv ${p.level}`;
  document.getElementById('world').textContent = `World ${p.world}`;

  const expNeeded = 100 * Math.pow(1.5, p.level - 1);
  const expPct = Math.min(100, (p.exp / expNeeded) * 100);
  document.getElementById('exp-fill').style.width = `${expPct}%`;
  document.getElementById('exp-text').textContent = `${Math.floor(p.exp)} / ${Math.floor(expNeeded)}`;

  const hpPct = Math.max(0, (p.hp / p.maxHp) * 100);
  document.getElementById('player-hp-fill').style.width = `${hpPct}%`;
  document.getElementById('player-hp-text').textContent = `${Math.floor(p.hp)} / ${Math.floor(p.maxHp)}`;

  renderEquipmentRing();
  updateActiveEffects();
  updateAttackRangeCircle();
}

function renderEquipmentRing() {
  const ring = document.getElementById('equip-ring');
  ring.innerHTML = '';

  const slots = ['helmet', 'weapon', 'chestplate', 'boots', 'leggings', 'ring'];
  const angleStep = (Math.PI * 2) / slots.length;

  slots.forEach((slot, i) => {
    const item = GameState.player.equipment[slot];
    if (!item) return;

    const angle = angleStep * i - Math.PI / 2;
    const x = Math.cos(angle) * CONFIG.EQUIP_RENDER_RADIUS_PX;
    const y = Math.sin(angle) * CONFIG.EQUIP_RENDER_RADIUS_PX;

    const icon = document.createElement('div');
    icon.className = `equipped-icon rarity-${item.rarity}`;
    // Use item.icon if available (for set items), otherwise fall back to SLOT_ICONS
    icon.textContent = item.icon || SLOT_ICONS[slot];
    icon.style.left = `${80 + x}px`;
    icon.style.top = `${80 + y}px`;
    icon.style.transform = 'translate(-50%, -50%)';
    ring.appendChild(icon);
  });
}

function updateAttackRangeCircle() {
  const p = GameState.player;
  const weaponItem = p.equipment && p.equipment.weapon;
  const circle = document.getElementById('attack-range-circle');

  if (!circle) return;

  // Show attack range circle if player has a weapon equipped
  if (weaponItem) {
    circle.classList.add('visible');

    // Get weapon range - use increased range for set weapons
    let range = CONFIG.ENGAGE_RADIUS_PX;
    if (weaponItem.setId) {
      // Set weapons have increased range (50% more)
      range = CONFIG.ENGAGE_RADIUS_PX * 1.5;
    }

    // Set circle size (diameter = 2 * radius)
    const diameter = range * 2;
    circle.style.width = `${diameter}px`;
    circle.style.height = `${diameter}px`;

    // Set circle color based on weapon rarity
    const rarityColors = {
      common: 'var(--color-common)',
      uncommon: 'var(--color-uncommon)',
      rare: 'var(--color-rare)',
      epic: 'var(--color-epic)',
      legendary: 'var(--color-legendary)',
      mythic: 'var(--color-mythic)'
    };

    const color = rarityColors[weaponItem.rarity] || '#888';
    circle.style.borderColor = color;
  } else {
    // No weapon equipped - hide the circle
    circle.classList.remove('visible');
  }
}

function renderSetBonuses() {
  const p = GameState.player;
  const container = document.getElementById('set-bonuses-display');
  if (!container) return;

  if (!p.activeSets || Object.keys(p.activeSets).length === 0) {
    container.innerHTML = '';
    container.style.display = 'none';
    return;
  }

  container.style.display = 'block';
  let html = '<div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin: 12px 0; border: 2px solid var(--accent-gold);">';
  html += '<div style="font-family: var(--font-display); font-size: 14px; font-weight: 700; color: var(--accent-gold); margin-bottom: 8px;">‚ö° Set Bonuses</div>';

  Object.keys(p.activeSets).forEach(setId => {
    const count = p.activeSets[setId];
    // Safety check: Skip if set doesn't exist in EQUIPMENT_SETS
    if (!EQUIPMENT_SETS[setId]) return;
    const setData = EQUIPMENT_SETS[setId];
    if (!setData) return;

    html += `<div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">`;
    html += `<div style="font-weight: 700; color: var(--accent-gold); margin-bottom: 4px;">${setData.name} (${count}/6)</div>`;

    [2, 3, 4, 6].forEach(tier => {
      const bonus = setData.bonuses[tier];
      if (!bonus) return;

      const active = count >= tier;
      const color = active ? 'var(--text-primary)' : 'var(--text-dim)';
      const weight = active ? '600' : '400';
      html += `<div style="font-size: 11px; color: ${color}; font-weight: ${weight}; padding: 2px 0;">`;
      html += `<span style="color: ${active ? '#4fc3f7' : 'var(--text-dim)'};">${tier}:</span> ${bonus.desc}`;
      html += `</div>`;
    });

    html += `</div>`;
  });

  html += '</div>';
  container.innerHTML = html;
}

function renderInventory() {
  const p = GameState.player;
  cleanInventory();  // Clean inventory before rendering

  Object.keys(p.equipment).forEach(slot => {
    const slotEl = document.getElementById(`equip-${slot === 'ring' ? 'ring-slot' : slot}`);
    const item = p.equipment[slot];

    if (item) {
      slotEl.innerHTML = `
        <span class="item-icon">${item.icon || SLOT_ICONS[slot]}</span>
        <span class="item-level">L${item.level}</span>
        ${item.stars > 0 ? `<span class="item-stars">${'‚≠ê'.repeat(item.stars)}</span>` : ''}
      `;
      slotEl.className = `equip-slot filled rarity-${item.rarity}`;
      slotEl.onclick = () => showItemTooltip(item, slotEl, true);
      slotEl.draggable = true;
    } else {
      slotEl.innerHTML = SLOT_ICONS[slot];
      slotEl.className = 'equip-slot';
      slotEl.onclick = null;
      slotEl.draggable = false;
    }
  });

  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    const slotEl = document.querySelector(`.inv-slot[data-index="${i}"]`);
    const item = p.inventory[i];

    if (item) {
      const icon = item.type === 'equipment' ? (item.icon || SLOT_ICONS[item.slot]) : item.icon;
      slotEl.innerHTML = `
        <span class="item-icon">${icon}</span>
        ${item.level ? `<span class="item-level">L${item.level}</span>` : ''}
        ${item.stars > 0 ? `<span class="item-stars">${'‚≠ê'.repeat(item.stars)}</span>` : ''}
      `;
      slotEl.className = `inv-slot filled ${item.rarity ? `rarity-${item.rarity}` : ''}`;
      slotEl.onclick = () => showItemTooltip(item, slotEl, false);
      slotEl.draggable = true;
    } else {
      slotEl.innerHTML = '';
      slotEl.className = 'inv-slot';
      slotEl.onclick = null;
      slotEl.draggable = false;
    }
  }

  // Update inventory resources display (only if elements exist)
  const invCoinsEl = document.getElementById('inv-coins');
  const invGemsEl = document.getElementById('inv-gems');
  if (invCoinsEl) invCoinsEl.textContent = Math.floor(p.coins).toLocaleString();
  if (invGemsEl) invGemsEl.textContent = Math.floor(p.gems).toLocaleString();

  // Update active effects display in inventory
  updateActiveEffects();

  // Set bonuses are now shown in tooltips, no separate display needed
}

// Drag and drop handlers for inventory
let draggedSlotIndex = null;
let draggedEquipSlot = null;

document.addEventListener('dragstart', (e) => {
  // Handle inventory slots
  if (e.target.classList.contains('inv-slot') && e.target.classList.contains('filled')) {
    draggedSlotIndex = parseInt(e.target.dataset.index);
    draggedEquipSlot = null;
    e.target.classList.add('dragging');
  }
  // Handle equipment slots
  else if (e.target.classList.contains('equip-slot') && e.target.classList.contains('filled')) {
    draggedEquipSlot = e.target.dataset.slot;
    draggedSlotIndex = null;
    e.target.classList.add('dragging');
  }
});

document.addEventListener('dragend', (e) => {
  if (e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')) {
    e.target.classList.remove('dragging');
    draggedSlotIndex = null;
    draggedEquipSlot = null;
  }
});

document.addEventListener('dragover', (e) => {
  const slot = e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')
    ? e.target
    : e.target.closest('.inv-slot') || e.target.closest('.equip-slot');

  if (slot) {
    e.preventDefault();
    slot.classList.add('drag-over');
  }
});

document.addEventListener('dragleave', (e) => {
  const slot = e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')
    ? e.target
    : e.target.closest('.inv-slot') || e.target.closest('.equip-slot');

  if (slot) {
    slot.classList.remove('drag-over');
  }
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  const targetSlot = e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')
    ? e.target
    : e.target.closest('.inv-slot') || e.target.closest('.equip-slot');

  if (!targetSlot) return;

  targetSlot.classList.remove('drag-over');
  const p = GameState.player;

  // Case 1: Dragging from inventory to inventory (swap/reorder)
  if (draggedSlotIndex !== null && targetSlot.classList.contains('inv-slot')) {
    const targetIndex = parseInt(targetSlot.dataset.index);

    if (draggedSlotIndex !== targetIndex) {
      const draggedItem = p.inventory[draggedSlotIndex];
      const targetItem = p.inventory[targetIndex];

      // Only proceed if there is actually an item to drag
      if (draggedItem) {
        // Swap the items (or move to empty slot)
        if (targetIndex < CONFIG.MAX_INVENTORY_SLOTS) {
          // Perform the swap
          p.inventory[draggedSlotIndex] = targetItem;  // Put target item (or undefined) at source
          p.inventory[targetIndex] = draggedItem;      // Put dragged item at target

          // Clean up undefined at source if target was empty
          if (!targetItem) {
            delete p.inventory[draggedSlotIndex];
          }
        } else {
          // Target beyond max slots, place at last slot
          p.inventory[CONFIG.MAX_INVENTORY_SLOTS - 1] = draggedItem;
          delete p.inventory[draggedSlotIndex];
        }
      }

      renderInventory();
      hideTooltip();
    }
  }
  // Case 2: Dragging from inventory to equipment (equip)
  else if (draggedSlotIndex !== null && targetSlot.classList.contains('equip-slot')) {
    const item = p.inventory[draggedSlotIndex];
    const targetEquipSlot = targetSlot.dataset.slot;

    if (item && item.type === 'equipment' && item.slot === targetEquipSlot) {
      // Remove item from sparse inventory
      delete p.inventory[draggedSlotIndex];

      // Swap: unequip current item to inventory, equip new item
      const oldEquipped = p.equipment[targetEquipSlot];
      p.equipment[targetEquipSlot] = item;

      // If there was an old equipped item, put it at the same inventory slot
      if (oldEquipped) {
        p.inventory[draggedSlotIndex] = oldEquipped;
      }

      computeDerivedStats();
      renderInventory();
      renderPlayerStats();
      hideTooltip();
    }
  }
  // Case 3: Dragging from equipment to inventory (unequip)
  else if (draggedEquipSlot !== null && targetSlot.classList.contains('inv-slot')) {
    const targetIndex = parseInt(targetSlot.dataset.index);
    const equippedItem = p.equipment[draggedEquipSlot];

    if (equippedItem) {
      cleanInventory();
      const invItem = p.inventory[targetIndex];

      if (!invItem) {
        // Simple unequip to empty slot - check if there is space
        if (getInventoryCount() < CONFIG.MAX_INVENTORY_SLOTS) {
          // Place at the target slot
          p.inventory[targetIndex] = equippedItem;
          p.equipment[draggedEquipSlot] = null;
        } else {
          showNotification('‚ö†Ô∏è Inventory full!', 'warning');
          computeDerivedStats();
          renderInventory();
          renderPlayerStats();
          hideTooltip();
          return;
        }
      } else if (invItem.type === 'equipment' && invItem.slot === draggedEquipSlot) {
        // Swap compatible equipment
        p.equipment[draggedEquipSlot] = invItem;  // Equip the inventory item
        p.inventory[targetIndex] = equippedItem;  // Put equipped item in inventory slot
      } else {
        // Can't swap - target slot has incompatible item
        showNotification('‚ö†Ô∏è Cannot swap incompatible items', 'warning');
        computeDerivedStats();
        renderInventory();
        renderPlayerStats();
        hideTooltip();
        return;
      }

      computeDerivedStats();
      renderInventory();
      renderPlayerStats();
      hideTooltip();
    }
  }
  // Case 4: Dragging from equipment to equipment (swap slots)
  else if (draggedEquipSlot !== null && targetSlot.classList.contains('equip-slot')) {
    const targetEquipSlot = targetSlot.dataset.slot;

    if (draggedEquipSlot !== targetEquipSlot) {
      const item1 = p.equipment[draggedEquipSlot];
      const item2 = p.equipment[targetEquipSlot];

      // Only swap if both items match their target slots
      if (item1 && item1.slot === targetEquipSlot && (!item2 || item2.slot === draggedEquipSlot)) {
        p.equipment[draggedEquipSlot] = item2;
        p.equipment[targetEquipSlot] = item1;

        computeDerivedStats();
        renderInventory();
        renderPlayerStats();
        hideTooltip();
      }
    }
  }
});

function renderPlayerStats() {
  const stats = GameState.player.currentStats;
  const bonuses = GameState.player.statBonuses || { atkBonus: 0, hpBonus: 0, spdBonus: 0, dmgBonus: 0 };
  const playerStats = GameState.player.statistics;

  // Helper function to format stat with bonus
  const formatStatWithBonus = (value, bonus) => {
    if (bonus > 0) {
      return `${Math.floor(value)} <span style="color: var(--text-bonus);">(+${Math.floor(bonus)})</span>`;
    }
    return Math.floor(value).toString();
  };

  // Update inventory stats (combat only)
  document.getElementById('stat-atk').innerHTML = formatStatWithBonus(stats.finalATK, bonuses.atkBonus);
  document.getElementById('stat-hp').innerHTML = formatStatWithBonus(stats.finalHP, bonuses.hpBonus);
  document.getElementById('stat-spd').innerHTML = formatStatWithBonus(stats.finalSPD, bonuses.spdBonus);
  document.getElementById('stat-dmg').innerHTML = formatStatWithBonus(stats.finalDMGPct, bonuses.dmgBonus) + '%';
  document.getElementById('stat-crit-rate').textContent = `${Math.floor(stats.finalCritRate)}%`;
  document.getElementById('stat-crit-dmg').textContent = `${Math.floor(stats.finalCritDmg)}%`;

  // Update stats overlay - combat stats
  const atkDetail = document.getElementById('stat-atk-detail');
  const hpDetail = document.getElementById('stat-hp-detail');
  const spdDetail = document.getElementById('stat-spd-detail');
  const dmgDetail = document.getElementById('stat-dmg-detail');
  const critRateDetail = document.getElementById('stat-crit-rate-detail');
  const critDmgDetail = document.getElementById('stat-crit-dmg-detail');

  if (atkDetail) atkDetail.innerHTML = formatStatWithBonus(stats.finalATK, bonuses.atkBonus);
  if (hpDetail) hpDetail.innerHTML = formatStatWithBonus(stats.finalHP, bonuses.hpBonus);
  if (spdDetail) spdDetail.innerHTML = formatStatWithBonus(stats.finalSPD, bonuses.spdBonus);
  if (dmgDetail) dmgDetail.innerHTML = formatStatWithBonus(stats.finalDMGPct, bonuses.dmgBonus) + '%';
  if (critRateDetail) critRateDetail.textContent = `${Math.floor(stats.finalCritRate)}%`;
  if (critDmgDetail) critDmgDetail.textContent = `${Math.floor(stats.finalCritDmg)}%`;

  // Update player statistics
  if (playerStats) {
    const totalKillsEl = document.getElementById('stat-total-kills');
    const bossesEl = document.getElementById('stat-bosses');
    const worldsEl = document.getElementById('stat-worlds');
    const deathsEl = document.getElementById('stat-deaths');
    const critsEl = document.getElementById('stat-crits');
    const dmgDealtEl = document.getElementById('stat-dmg-dealt');
    const dmgTakenEl = document.getElementById('stat-dmg-taken');
    const coinsEarnedEl = document.getElementById('stat-coins-earned');
    const gemsEarnedEl = document.getElementById('stat-gems-earned');
    const expGainedEl = document.getElementById('stat-exp-gained');
    const itemsFoundEl = document.getElementById('stat-items-found');
    const itemsBoughtEl = document.getElementById('stat-items-bought');
    const playtimeEl = document.getElementById('stat-playtime');

    if (totalKillsEl) totalKillsEl.textContent = playerStats.totalKills.toLocaleString();
    if (bossesEl) bossesEl.textContent = playerStats.bossesDefeated.toLocaleString();
    if (worldsEl) worldsEl.textContent = playerStats.worldsCompleted.toLocaleString();
    if (deathsEl) deathsEl.textContent = playerStats.deaths.toLocaleString();
    if (critsEl) critsEl.textContent = playerStats.criticalHits.toLocaleString();
    if (dmgDealtEl) dmgDealtEl.textContent = Math.floor(playerStats.totalDamageDealt).toLocaleString();
    if (dmgTakenEl) dmgTakenEl.textContent = Math.floor(playerStats.totalDamageTaken).toLocaleString();
    if (coinsEarnedEl) coinsEarnedEl.textContent = Math.floor(playerStats.totalCoinsEarned).toLocaleString();
    if (gemsEarnedEl) gemsEarnedEl.textContent = Math.floor(playerStats.totalGemsEarned).toLocaleString();
    if (expGainedEl) expGainedEl.textContent = Math.floor(playerStats.totalExpGained).toLocaleString();
    if (itemsFoundEl) itemsFoundEl.textContent = playerStats.itemsFound.toLocaleString();
    if (itemsBoughtEl) itemsBoughtEl.textContent = playerStats.itemsPurchased.toLocaleString();

    // Calculate and display play time
    if (playtimeEl) {
      const currentSession = (Date.now() - playerStats.sessionStartTime) / 1000;
      const totalSeconds = Math.floor(playerStats.totalPlayTime + currentSession);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      playtimeEl.textContent = `${hours}h ${minutes}m`;
    }
  }
}

function renderShop() {
  const shop = GameState.shop;
  const p = GameState.player;

  // Update coins and gems display
  const shopCoinsEl = document.getElementById('shop-coins');
  const shopGemsEl = document.getElementById('shop-gems');
  if (shopCoinsEl) shopCoinsEl.textContent = Math.floor(p.coins).toLocaleString();
  if (shopGemsEl) shopGemsEl.textContent = Math.floor(p.gems).toLocaleString();

  const equipGrid = document.getElementById('shop-equipment-grid');
  equipGrid.innerHTML = '';
  shop.offers.equipment.forEach(item => {
    const div = document.createElement('div');
    const isSoldOut = item.soldOut || false;
    div.className = `shop-item rarity-${item.rarity}${isSoldOut ? ' sold-out' : ''}`;
    div.innerHTML = `
      <div class="shop-item-icon">${item.icon || SLOT_ICONS[item.slot]}</div>
      <div class="shop-item-name text-${item.rarity}">${item.name}</div>
      <div class="shop-item-price">üí∞ ${item.buyPrice.toLocaleString()}</div>
    `;
    if (!isSoldOut) {
      div.onclick = () => showShopItemTooltip(item, div);
    }
    equipGrid.appendChild(div);
  });

  const consGrid = document.getElementById('shop-consumables-grid');
  consGrid.innerHTML = '';
  shop.offers.consumables.forEach(item => {
    const div = document.createElement('div');
    const isSoldOut = item.soldOut || false;
    div.className = `shop-item${isSoldOut ? ' sold-out' : ''}`;
    div.innerHTML = `
      <div class="shop-item-icon">${item.icon}</div>
      <div class="shop-item-name">${item.name}</div>
      <div class="shop-item-price">üíé ${item.price}</div>
    `;
    if (!isSoldOut) {
      div.onclick = () => showShopItemTooltip(item, div);
    }
    consGrid.appendChild(div);
  });
}

function renderEnemies() {
  const layer = document.getElementById('enemy-layer');
  const existing = new Set(Array.from(layer.children).map(el => el.dataset.enemyId));

  GameState.enemies.forEach(enemy => {
    let el = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (!el) {
      el = document.createElement('div');
      el.className = `enemy ${enemy.type}`;
      el.dataset.enemyId = enemy.id;
      el.innerHTML = `
        ${ENEMY_ICONS[enemy.type]}
        <div class="enemy-hpbar"><div class="enemy-hp-fill"></div></div>
      `;
      el.onclick = () => attackEnemy(enemy);
      layer.appendChild(el);
      // Set initial position for newly created enemies
      el.style.transform = `translate(${enemy.position.x}px, ${enemy.position.y}px)`;
    }

    // Don't update transform here - smooth per-frame renderer handles all position updates

    const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
    el.querySelector('.enemy-hp-fill').style.width = `${hpPct}%`;

    existing.delete(enemy.id);
  });

  existing.forEach(id => {
    const el = document.querySelector(`[data-enemy-id="${id}"]`);
    if (el) el.remove();
  });
}

// ------------------- new helpers for weapon attacks & VFX -------------------
function getElementColor(el) {
  const map = {
    wind: '#2ecc71',         // green
    lightning: '#9b59b6',    // purple
    fire: '#ff8a4b',
    aether: '#fff8c2',       // light yellow
    cryo: '#5bc0ff',
    physical: '#ffffff'
  };
  return map[el] || '#ffffff';
}
function showElementDamage(damage, elementType, enemyEl, isCrit, customColor = null) {
  if (!enemyEl) return;
  const stage = document.getElementById('stage');
  if (!stage) return;

  // measure
  const rect = enemyEl.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const dmgEl = document.createElement('div');
  dmgEl.className = 'drop-item';
  dmgEl.textContent = isCrit ? `${damage}!` : `${damage}`;
  dmgEl.style.left = `${rect.left - stageRect.left + rect.width / 2}px`;
  dmgEl.style.top = `${rect.top - stageRect.top - 30}px`;
  dmgEl.style.color = customColor || getElementColor(elementType);
  dmgEl.style.fontWeight = 'bold';
  dmgEl.style.fontSize = '18px';
  dmgEl.style.textShadow = '0 1px 0 rgba(0,0,0,0.6)';

  const dropLayer = document.getElementById('drop-layer');
  if (dropLayer) {
    dropLayer.appendChild(dmgEl);
    setTimeout(() => dmgEl.remove(), 1800);
  }
}

/* ---------- Helper utilities ---------- */

function findEnemiesInRadius(x, y, radius) {
  // GameState.enemies expected to have .x/.y positions (or .position.x/.position.y)
  return GameState.enemies.filter(e => {
    const ex = (e.position && e.position.x) || e.x || 0;
    const ey = (e.position && e.position.y) || e.y || 0;
    const dx = ex - x, dy = ey - y;
    return (dx*dx + dy*dy) <= (radius * radius);
  });
}

function applyDamageToEnemy(enemy, dmg, ctx = {}) {
  if (!enemy || enemy.hp <= 0) return;
  enemy.hp -= dmg;
  // attach lastHit context for on-death detection
  enemy.lastHit = Object.assign({}, ctx, { damage: dmg, timestamp: Date.now() });

  // floating damage display: color by element (special-case aether & wind etc)
  const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
  if (enemyEl) {
    // Use yellow for coin damage, red for HP loss damage
    let customColor = null;
    if (ctx.source && (ctx.source.includes('coin') || ctx.source === 'rich_mans_blow' || ctx.source === 'wealth_rain')) {
      customColor = '#ffd700'; // Yellow for coins
    } else if (ctx.source && ctx.source.includes('hp_loss')) {
      customColor = '#ff3b3b'; // Red for HP loss
    }
    showElementDamage(Math.floor(dmg), ctx.type || 'physical', enemyEl, !!ctx.crit, customColor);
  }

  if (enemy.hp <= 0) {
    // spawn skywarden explosion if kill was wind + source set = skywarden and not spawned by explosion
    if (ctx.type === 'wind' && ctx.setId === 'skywarden' && !ctx.source?.includes?.('explosion')) {
      // spawn big explosion centered on enemy
      if (typeof spawnAoE === 'function') {
        const R = window.R_windExplosion || 80;
        spawnAoE(enemy.position?.x || enemy.x || 0, enemy.position?.y || enemy.y || 0, R, Math.floor((GameState.player.currentStats?.finalATK || GameState.player.ATK) * 0.35), 'wind', { source: 'skywarden_explosion' });
      } else {
        // fallback: shockwave visual
        const enemyElRect = enemyEl.getBoundingClientRect();
        spawnShockwave(enemyElRect.left + enemyElRect.width/2, enemyElRect.top + enemyElRect.height/2, 90, getElementColor('wind'), 360);
        // apply AoE damage manually
        const hits = findEnemiesInRadius(enemy.position?.x||enemy.x||0, enemy.position?.y||enemy.y||0, 80);
        for (const h of hits) {
          if (h.id === enemy.id) continue;
          applyDamageToEnemy(h, Math.floor((GameState.player.currentStats?.finalATK || GameState.player.ATK) * 0.35), { type:'wind', source:'skywarden_explosion', setId:'skywarden', isAoE:true });
        }
      }
    }
    // call onEnemyDeath as before
    onEnemyDeath(enemy);
    GameState.enemies = GameState.enemies.filter(e => e.id !== enemy.id);
  }
}

function applyStatus(enemy, statusName, data) {
  enemy.status = enemy.status || {};
  enemy.status[statusName] = Object.assign({ appliedAt: Date.now() }, data);
}

/* Lightweight projectile VFX factory (returns DOM node for additional control) */
function createProjectile(options) {
  // options: {fromX, fromY, toX, toY, color, size, travelMs, onArrive(callback(enemyHit)), pierce:false}
  const stage = document.getElementById('stage');
  if (!stage) return null;
  const stageRect = stage.getBoundingClientRect();
  const p = document.createElement('div');
  p.className = 'weapon-proj';
  Object.assign(p.style, {
    position: 'absolute',
    left: `${options.fromX - stageRect.left}px`,
    top: `${options.fromY - stageRect.top}px`,
    width: `${options.size||12}px`,
    height: `${options.size||12}px`,
    borderRadius: '50%',
    background: options.color || '#fff',
    boxShadow: `0 0 12px ${options.color||'#fff'}`,
    transform: 'translate(-50%,-50%)',
    zIndex: 60,
    pointerEvents: 'none',
    transition: `transform ${options.travelMs||260}ms linear, opacity 180ms linear`
  });
  stage.appendChild(p);

  // compute translation
  const dx = (options.toX - options.fromX);
  const dy = (options.toY - options.fromY);
  requestAnimationFrame(() => { p.style.transform = `translate(${dx}px, ${dy}px)`; });

  setTimeout(() => {
    // on arrive
    if (typeof options.onArrive === 'function') options.onArrive();
    // small impact flash
    const impact = document.createElement('div');
    Object.assign(impact.style, {
      position: 'absolute',
      left: `${options.toX - stageRect.left}px`,
      top: `${options.toY - stageRect.top}px`,
      transform: 'translate(-50%,-50%)',
      width: `${(options.size||12)*3}px`,
      height: `${(options.size||12)*3}px`,
      borderRadius: '50%',
      background: options.color || '#fff',
      opacity: 0.85,
      boxShadow: `0 0 22px ${options.color||'#fff'}`,
      zIndex: 61,
      pointerEvents: 'none'
    });
    stage.appendChild(impact);
    setTimeout(()=> impact.remove(), 280);
    p.remove();
  }, options.travelMs || 260);

  // safety remove
  setTimeout(()=>{ if(p.parentNode) p.remove(); }, (options.travelMs||260)+600);
  return p;
}

function spawnShockwave(x, y, radius, color, durationMs = 380) {
  const stage = document.getElementById('stage');
  if (!stage) return;
  const stageRect = stage.getBoundingClientRect();
  const w = document.createElement('div');
  Object.assign(w.style, {
    position: 'absolute',
    left: `${x - stageRect.left}px`,
    top: `${y - stageRect.top}px`,
    width: `4px`,
    height: `4px`,
    borderRadius: '50%',
    transform: 'translate(-50%,-50%)',
    zIndex: 59,
    pointerEvents: 'none',
    background: color,
    boxShadow: `0 0 22px ${color}`,
    opacity: '0.9',
    transition: `width ${durationMs}ms ease-out, height ${durationMs}ms ease-out, opacity ${durationMs}ms linear`
  });
  stage.appendChild(w);
  requestAnimationFrame(()=>{
    w.style.width = `${radius*2}px`;
    w.style.height = `${radius*2}px`;
    w.style.opacity = '0';
  });
  setTimeout(()=> w.remove(), durationMs+40);
}


/* ---------- safe player HP getters/setters ---------- */
function getPlayerHP(p) {
  return p.HP_current ?? p.currentHP ?? p.hp ?? (p.currentStats && p.currentStats.HP_current) ?? (p.HP_max ?? 0);
}
function setPlayerHP(p, value) {
  if (p.HP_current !== undefined) p.HP_current = value;
  else if (p.currentHP !== undefined) p.currentHP = value;
  else if (p.hp !== undefined) p.hp = value;
  else if (p.currentStats && p.currentStats.HP_current !== undefined) p.currentStats.HP_current = value;
  else p.HP_current = value;
}

/* ---------- SVG lightning arc (nice purple lightning) ---------- */
function createLightningArc(fromX, fromY, toX, toY, color, duration = 260) {
  // create an SVG path with jaggedness randomized to feel like lightning
  const stage = document.getElementById('stage');
  if (!stage) return;
  // create svg overlay if none
  let svg = document.getElementById('vfx-svg-overlay');
  if (!svg) {
    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('id','vfx-svg-overlay');
    svg.style.position = 'absolute';
    svg.style.left = '0';
    svg.style.top = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '999';
    stage.appendChild(svg);
  }
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  const dx = toX - fromX, dy = toY - fromY;
  const dist = Math.sqrt(dx*dx + dy*dy) || 1;
  // generate jagged midpoints
  const spikes = Math.max(2, Math.floor(dist / 60));
  const pts = [{x:fromX,y:fromY}];
  for (let i=1;i<spikes;i++){
    const t = i/spikes;
    const nx = fromX + dx * t + (Math.random()*40 - 20);
    const ny = fromY + dy * t + (Math.random()*40 - 20);
    pts.push({x:nx,y:ny});
  }
  pts.push({x:toX,y:toY});
  // build smooth polyline into path string
  let d = `M ${pts[0].x} ${pts[0].y}`;
  for (let i=1;i<pts.length;i++){
    d += ` L ${pts[i].x} ${pts[i].y}`;
  }
  path.setAttribute('d', d);
  path.setAttribute('stroke', color);
  path.setAttribute('stroke-width', 3);
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke-linecap', 'round');
  path.setAttribute('stroke-linejoin', 'round');
  path.style.opacity = '0.95';
  path.style.filter = 'drop-shadow(0 0 8px ' + color + ')';
  svg.appendChild(path);

  // animate fade out
  setTimeout(()=> {
    path.style.transition = `opacity ${Math.max(150,duration)}ms ease-out, stroke-width 180ms ease-out`;
    path.style.opacity = '0';
    path.setAttribute('stroke-width', 1);
    setTimeout(()=> path.remove(), Math.max(300,duration+80));
  }, duration);
  // return path node if caller wants to remove earlier
  return path;
}

/* ---------- Status tick processor (burn, slow expirations, etc) ----------
   Call processEnemyStatusTicks(deltaMs) from your main game tick loop.
*/
let _burnTickAcc = {}; // track last tick times per enemy for precise ticks if needed
function processEnemyStatusTicks(deltaMs) {
  // for each enemy
  const now = Date.now();
  for (const enemy of (GameState.enemies || [])) {
    if (!enemy.status) continue;
    // BURN: apply tick damage
    if (enemy.status.burn) {
      const s = enemy.status.burn;
      const elapsed = now - (s._lastTickAt || s.appliedAt || now);
      // tick every s.tickInterval (ms)
      if (elapsed >= (s.tickInterval || 1000)) {
        // compute number of ticks passed
        const ticks = Math.floor(elapsed / (s.tickInterval || 1000));
        for (let i=0;i<ticks;i++){
          // 3-piece: Burn - DoT scales by +8% of player ATK per tick
          let tickDmg = Math.floor(s.tickDamage || 0);
          if (getSetCount('emberkin') >= 3 && s.sourceSet === 'emberkin') {
            const atkScaling = Math.floor((GameState.player.currentStats?.finalATK || 0) * 0.08);
            tickDmg += atkScaling;
          }
          applyDamageToEnemy(enemy, tickDmg, { type: 'fire', source: 'dot', setId: s.sourceSet || null });
        }
        s._lastTickAt = (s._lastTickAt || s.appliedAt || now) + ticks * (s.tickInterval || 1000);
      }
      // expire burn after duration
      if (now - (s.appliedAt || now) >= (s.duration || 5000)) {
        delete enemy.status.burn;
      }
    }

    // SLOW: visual and expiration
    if (enemy.status.slow) {
      const s = enemy.status.slow;
      // add visual to indicate slow
      addSlowVisual(enemy);
      if (now - (s.appliedAt || now) >= (s.duration || 3000)) {
        // remove slow
        delete enemy.status.slow;
        removeSlowVisual(enemy);
      }
    } else {
      // ensure visual removed if no slow
      removeSlowVisual(enemy);
    }
  }
}

/* slow visual functions (blue tint) */
function addSlowVisual(enemy) {
  const el = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
  if (!el) return;
  if (!el.classList.contains('vfx-slow')) {
    el.classList.add('vfx-slow');
    // define vfx-slow style if not already present (inject)
    if (!document.getElementById('vfx-slow-style')) {
      const st = document.createElement('style');
      st.id = 'vfx-slow-style';
      st.innerHTML = `
        .vfx-slow { filter: hue-rotate(200deg) saturate(120%) brightness(85%); transition: filter 180ms; box-shadow: 0 0 8px rgba(90,160,255,0.6); }
      `;
      document.head.appendChild(st);
    }
  }
}
function removeSlowVisual(enemy) {
  const el = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
  if (!el) return;
  el.classList.remove('vfx-slow');
}

/* ---------- Aegis orbiters system ---------- */
GameState.orbiters = GameState.orbiters || []; // global array for orbiters

function ensureAegisOrbiters(player) {
  // determine number of orbiters from equipped Aegis set pieces
  const weapon = player.equipment && player.equipment.weapon;
  if (!weapon || weapon.setId !== 'aegis') return; // only when Aegis equipped
  // base orb count = number of Aegis pieces equipped (we'll read computeDerivedStats or count)
  const piecesCount = (() => {
    const slots = ['helmet','chestplate','leggings','boots','ring','weapon'];
    let c = 0;
    for (const s of slots) {
      const it = player.equipment && player.equipment[s];
      if (it && it.setId === 'aegis') c++;
    }
    return c;
  })();
  const add = (piecesCount >= 4) ? 2 : 0;
  const orbCount = Math.max(1, piecesCount + add);

  // if existing orbiters match, do nothing
  if (GameState.orbiters.length >= orbCount) return;

  // spawn missing orbiters
  for (let i = GameState.orbiters.length; i < orbCount; i++) {
    GameState.orbiters.push({
      angle: (i / orbCount) * Math.PI * 2,
      radius: 80 + (i * 6),
      speed: 0.01 + (i * 0.002),
      size: 14,
      damage: Math.floor((player.currentStats?.finalATK || player.ATK) * 0.20),
      lastHitIds: new Set(), // to avoid repeated hits in same orbit tick
      createdAt: Date.now()
    });
  }
}

function updateOrbiters(deltaMs) {
  // called each tick. Move orbiters around player and check collisions
  const player = GameState.player;
  if (!player) return;
  // if player does not have Aegis equipped, clear orbiters
  const weapon = player.equipment && player.equipment.weapon;
  if (!weapon || weapon.setId !== 'aegis') {
    GameState.orbiters = [];
    return;
  }
  ensureAegisOrbiters(player);
  const playerEl = document.getElementById('player-container');
  if (!playerEl) return;

  const pRect = playerEl.getBoundingClientRect();
  const cx = pRect.left + pRect.width / 2;
  const cy = pRect.top + pRect.height / 2;

  // update each orb
  for (const orb of GameState.orbiters) {
    orb.angle += orb.speed * deltaMs;
    // compute position
    const ox = cx + Math.cos(orb.angle) * orb.radius;
    const oy = cy + Math.sin(orb.angle) * orb.radius;
    // draw DOM node for orb (create if not existing)
    if (!orb.el) {
      const el = document.createElement('div');
      el.className = 'aegis-orb';
      Object.assign(el.style, {
        position: 'absolute',
        left: `${ox}px`,
        top: `${oy}px`,
        width: `${orb.size}px`,
        height: `${orb.size}px`,
        transform: 'translate(-50%,-50%)',
        borderRadius: '50%',
        background: getElementColor('aether'),
        boxShadow: `0 0 12px ${getElementColor('aether')}`,
        pointerEvents: 'none',
        zIndex: 70
      });
      orb.el = el;
      document.getElementById('stage').appendChild(el);
    } else {
      orb.el.style.left = `${ox}px`;
      orb.el.style.top = `${oy}px`;
    }

    // collision with enemies: find any enemy whose center is within a small radius
    const hits = (GameState.enemies || []).filter(e => {
      const ex = (e.position?.x||e.x||0), ey = (e.position?.y||e.y||0);
      const dx = ex - ox, dy = ey - oy;
      return dx*dx + dy*dy <= ( (orb.size/2 + 18) * (orb.size/2 + 18) ); // collision radius
    });

    for (const en of hits) {
      if (orb.lastHitIds.has(en.id)) continue; // avoid repeating in same orb instance frequently
      applyDamageToEnemy(en, orb.damage, { type:'aether', source:'aegis_orb', setId:'aegis' });
      orb.lastHitIds.add(en.id);
      // clear the set after short timeout so orb can hit again later
      setTimeout(()=> orb.lastHitIds.delete(en.id), 600);
    }
  }
}

/* ---------- star projectile style helper (for Zephyr) ---------- */
function createStarProjectile(options) {
  // like createProjectile but star-shaped using clip-path + CSS
  const stage = document.getElementById('stage');
  if (!stage) return null;
  const stageRect = stage.getBoundingClientRect();
  const s = document.createElement('div');
  s.className = 'weapon-star';
  Object.assign(s.style, {
    position: 'absolute',
    left: `${options.fromX - stageRect.left}px`,
    top: `${options.fromY - stageRect.top}px`,
    width: `${options.size||14}px`,
    height: `${options.size||14}px`,
    pointerEvents: 'none',
    zIndex: 60,
    transform: 'translate(-50%,-50%)',
    transition: `transform ${options.travelMs||260}ms linear, opacity 180ms linear`,
    background: options.color || '#fff',
    clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
    boxShadow: `0 0 12px ${options.color||'#fff'}`
  });
  stage.appendChild(s);
  const dx = (options.toX - options.fromX);
  const dy = (options.toY - options.fromY);
  requestAnimationFrame(() => s.style.transform = `translate(${dx}px, ${dy}px)`);
  setTimeout(()=> {
    if (typeof options.onArrive === 'function') options.onArrive();
    s.remove();
  }, options.travelMs || 260);
  // safety remove
  setTimeout(()=> { if (s.parentNode) s.remove(); }, (options.travelMs||260) + 600);
}


/* ---------- Aegis circle spawner ---------- */
function spawnAegisCircle(centerX, centerY, index, totalCircles, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const radius = 60;
  const angleOffset = (index / totalCircles) * Math.PI * 2;
  const rotationSpeed = 2000; // ms per rotation

  const circle = document.createElement('div');
  circle.className = 'aegis-circle';
  Object.assign(circle.style, {
    position: 'absolute',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, #fff8c2, #f0e68c)',
    boxShadow: '0 0 15px #fff8c2',
    pointerEvents: 'none',
    zIndex: 55,
    left: `${centerX}px`,
    top: `${centerY}px`,
    transform: 'translate(-50%, -50%)'
  });

  stage.appendChild(circle);

  const startTime = Date.now();
  const duration = 3000; // circles last 3 seconds

  const animate = () => {
    const elapsed = Date.now() - startTime;
    if (elapsed > duration) {
      circle.remove();
      return;
    }

    const angle = angleOffset + (elapsed / rotationSpeed) * Math.PI * 2;
    const x = centerX + Math.cos(angle) * radius;
    const y = centerY + Math.sin(angle) * radius;

    circle.style.left = `${x}px`;
    circle.style.top = `${y}px`;

    // Check for enemy collisions
    const circleDmg = Math.floor((player.currentStats?.finalATK || player.ATK) * 0.10);
    GameState.enemies.forEach(enemy => {
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;
      const dist = Math.sqrt((x - enemyX)**2 + (y - enemyY)**2);
      if (dist < 30) { // collision radius
        applyDamageToEnemy(enemy, circleDmg, { type: 'aether', source: 'aegis_circle', setId: 'aegis' });
      }
    });

    requestAnimationFrame(animate);
  };

  animate();
}

/* ---------- Fire zone creator ---------- */
function createFireZone(centerX, centerY, burnTick, duration, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const zone = document.createElement('div');
  zone.className = 'fire-zone';
  Object.assign(zone.style, {
    position: 'absolute',
    width: '120px',
    height: '120px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, rgba(255,138,75,0.4), rgba(255,69,0,0.2))',
    border: '2px solid rgba(255,138,75,0.6)',
    boxShadow: '0 0 20px rgba(255,138,75,0.5), inset 0 0 20px rgba(255,69,0,0.3)',
    pointerEvents: 'none',
    zIndex: 45,
    left: `${centerX}px`,
    top: `${centerY}px`,
    transform: 'translate(-50%, -50%)',
    animation: 'fire-pulse 1s infinite'
  });

  stage.appendChild(zone);

  // Track zone for damage ticks (applied in updateSetBonusesPeriodic like Bloodbath)
  const zoneData = {
    x: centerX,
    y: centerY,
    radius: 60,
    baseDamage: burnTick,
    startTime: Date.now(),
    duration: 10000, // Zone lasts 10 seconds
    burnDuration: 5000, // Each enemy burns for 5 seconds after entering
    element: zone,
    affectedEnemies: new Map() // enemyId -> { enteredAt, lastTickAt }
  };

  if (!player.emberkinFireZones) player.emberkinFireZones = [];
  player.emberkinFireZones.push(zoneData);

  // Remove zone after duration
  setTimeout(() => {
    if (zone.parentNode) zone.remove();
    player.emberkinFireZones = player.emberkinFireZones.filter(z => z !== zoneData);
  }, duration);
}

function spawnAegisHoveringBall(targetEnemy, ballDmg, duration, player, has3Piece, has6Piece) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const ball = document.createElement('div');
  Object.assign(ball.style, {
    position: 'absolute',
    width: '24px',
    height: '24px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, rgba(147,112,219,0.9), rgba(138,43,226,0.6))',
    border: '2px solid rgba(186,85,211,0.8)',
    boxShadow: '0 0 15px rgba(147,112,219,0.8)',
    pointerEvents: 'none',
    zIndex: 50
  });

  stage.appendChild(ball);

  let currentEnemy = targetEnemy;
  const startTime = Date.now();
  const hitInterval = 500; // Hit every 0.5 seconds
  let enemyDied = false;
  let deathPosition = null;

  const updateBall = setInterval(() => {
    const elapsed = Date.now() - startTime;

    // Check if ball should expire
    if (elapsed >= duration) {
      clearInterval(updateBall);
      ball.remove();
      return;
    }

    // Check if current enemy is still alive
    if (!GameState.enemies.find(e => e.id === currentEnemy.id)) {
      if (!enemyDied && has6Piece) {
        // Enemy just died - trigger 6-piece effect
        enemyDied = true;
        deathPosition = { x: currentEnemy.position?.x || currentEnemy.x || 0, y: currentEnemy.position?.y || currentEnemy.y || 0 };
        clearInterval(updateBall);
        ball.remove();

        // Spawn 2 balls that spin around the dead enemy for 3 seconds
        spawnAegis6PieceSpinBalls(deathPosition.x, deathPosition.y, player);
        return;
      }

      // Enemy died, find a random new enemy (if not 6-piece or already handled)
      const availableEnemies = GameState.enemies.filter(e => e.hp > 0);
      if (availableEnemies.length === 0) {
        clearInterval(updateBall);
        ball.remove();
        return;
      }
      currentEnemy = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
    }

    // Position ball to hover around current enemy
    const enemyEl = document.querySelector(`[data-enemy-id="${currentEnemy.id}"]`);
    if (enemyEl) {
      const rect = enemyEl.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      const angle = (elapsed / 1000) * Math.PI * 2; // Rotate around enemy
      const radius = 40;
      const offsetX = Math.cos(angle) * radius;
      const offsetY = Math.sin(angle) * radius;

      ball.style.left = `${rect.left - stageRect.left + rect.width/2 + offsetX}px`;
      ball.style.top = `${rect.top - stageRect.top + rect.height/2 + offsetY}px`;
    }
  }, 50);

  // Deal damage every hitInterval
  const damageInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    if (elapsed >= duration) {
      clearInterval(damageInterval);
      return;
    }

    // Check if current enemy still exists
    const enemy = GameState.enemies.find(e => e.id === currentEnemy.id);
    if (enemy) {
      applyDamageToEnemy(enemy, ballDmg, { type: 'aether', source: 'weapon_ball', setId: 'aegis' });

      // 3-piece: Myth - 20% chance to spawn another ball (lasts 3 seconds)
      if (has3Piece && Math.random() < 0.20) {
        const mythBallDmg = Math.floor(ballDmg);
        setTimeout(() => {
          spawnAegisHoveringBall(enemy, mythBallDmg, 3000, player, false, false);
        }, 100);
      }
    } else {
      clearInterval(damageInterval);
    }
  }, hitInterval);
}

function spawnAegis6PieceSpinBalls(deathX, deathY, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const balls = [];
  const spinDuration = 3000;
  const startTime = Date.now();

  // Create 2 balls
  for (let i = 0; i < 2; i++) {
    const ball = document.createElement('div');
    Object.assign(ball.style, {
      position: 'absolute',
      width: '28px',
      height: '28px',
      borderRadius: '50%',
      background: 'radial-gradient(circle, rgba(186,85,211,1), rgba(138,43,226,0.7))',
      border: '2px solid rgba(147,112,219,1)',
      boxShadow: '0 0 20px rgba(147,112,219,1)',
      pointerEvents: 'none',
      zIndex: 52
    });
    stage.appendChild(ball);
    balls.push(ball);
  }

  const stageRect = stage.getBoundingClientRect();

  // Spin balls around death position
  const spinInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;

    if (elapsed >= spinDuration) {
      clearInterval(spinInterval);

      // Launch balls to random enemies and explode
      balls.forEach((ball, index) => {
        setTimeout(() => {
          const availableEnemies = GameState.enemies.filter(e => e.hp > 0);
          if (availableEnemies.length > 0) {
            const targetEnemy = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
            const targetX = targetEnemy.position?.x || targetEnemy.x || 0;
            const targetY = targetEnemy.position?.y || targetEnemy.y || 0;

            // Animate ball moving to target
            ball.style.transition = 'all 0.5s ease-out';
            ball.style.left = `${targetX}px`;
            ball.style.top = `${targetY}px`;

            setTimeout(() => {
              // Explode and deal 200% aether damage
              const explosionDmg = Math.floor((player.currentStats?.finalATK || player.ATK) * 2.00);
              applyDamageToEnemy(targetEnemy, explosionDmg, { type: 'aether', source: 'aegis_6piece_explosion', setId: 'aegis' });

              // Visual explosion
              const enemyEl = document.querySelector(`[data-enemy-id="${targetEnemy.id}"]`);
              if (enemyEl) {
                const rect = enemyEl.getBoundingClientRect();
                spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 80, '#9370db', 400);
              }

              ball.remove();
            }, 500);
          } else {
            ball.remove();
          }
        }, index * 100);
      });
      return;
    }

    // Spin balls around death position
    balls.forEach((ball, index) => {
      const angle = (elapsed / 1000) * Math.PI * 2 + (index * Math.PI); // Opposite sides
      const radius = 50;
      const offsetX = Math.cos(angle) * radius;
      const offsetY = Math.sin(angle) * radius;

      ball.style.left = `${deathX + offsetX}px`;
      ball.style.top = `${deathY + offsetY}px`;

      // Deal 80% damage every 500ms while spinning
      if (elapsed % 500 < 50) {
        const spinDmg = Math.floor((player.currentStats?.finalATK || player.ATK) * 0.80);
        const nearbyEnemies = findEnemiesInRadius(deathX + offsetX, deathY + offsetY, 40);
        nearbyEnemies.forEach(e => {
          applyDamageToEnemy(e, spinDmg, { type: 'aether', source: 'aegis_6piece_spin', setId: 'aegis' });
        });
      }
    });
  }, 50);
}

function createCryoZone(centerX, centerY, aoeDmg, duration, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const zone = document.createElement('div');
  zone.className = 'cryo-zone';
  Object.assign(zone.style, {
    position: 'absolute',
    width: '140px',
    height: '140px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, rgba(135,206,250,0.4), rgba(70,130,180,0.2))',
    border: '2px solid rgba(135,206,250,0.6)',
    boxShadow: '0 0 25px rgba(135,206,250,0.6), inset 0 0 25px rgba(70,130,180,0.3)',
    pointerEvents: 'none',
    zIndex: 45,
    left: `${centerX}px`,
    top: `${centerY}px`,
    transform: 'translate(-50%, -50%)',
    animation: 'fire-pulse 1.5s infinite'
  });

  stage.appendChild(zone);

  // Track which enemies are in the zone and apply freeze + DoT
  const affectedEnemies = new Map(); // enemyId -> { frozenAt, lastTickAt }

  // Check for enemies in zone every 100ms
  const checkInterval = setInterval(() => {
    GameState.enemies.forEach(enemy => {
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;
      const dist = Math.sqrt((centerX - enemyX)**2 + (centerY - enemyY)**2);

      if (dist < 70) { // zone radius
        const now = Date.now();

        // If enemy just entered zone, freeze them for 3 seconds
        if (!affectedEnemies.has(enemy.id)) {
          affectedEnemies.set(enemy.id, { frozenAt: now, lastTickAt: now });

          // Actually freeze the enemy (set frozen flag and stop movement)
          enemy.frozen = true;
          enemy.frozenTimer = 3.0; // 3 second freeze
          enemy.frozenAt = now;
          enemy.originalSpeed = enemy.speed;
          enemy.speed = 0;

          // Apply freeze visual (handled by updateEnemies now)
          const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
          if (enemyEl) {
            enemyEl.style.filter = 'brightness(1.5) saturate(0.3) hue-rotate(180deg)';
          }
        }

        // Deal damage every tick (1 second) for 3 seconds
        const enemyData = affectedEnemies.get(enemy.id);
        if (enemyData && now - enemyData.lastTickAt >= 1000 && now - enemyData.frozenAt < 3000) {
          applyDamageToEnemy(enemy, aoeDmg, { type: 'cryo', source: 'weapon_zone', setId: 'glacier' });
          enemyData.lastTickAt = now;
        }
      }
    });
  }, 100);

  // Remove zone after duration
  setTimeout(() => {
    clearInterval(checkInterval);
    zone.remove();
  }, duration);
}

const WEAPON_HANDLERS = {
  // Aquila Longbow (Skywarden) - wind green, pushback, big explosion on kill
  skywarden: (p, enemy, weapon) => {
    const element = 'wind';
    const windDmg = Math.floor((p.currentStats?.finalATK || p.ATK || 0) * 1.20);
    // arrow projectile (green)
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    const playerEl = document.getElementById('player-container');
    if (playerEl && enemyEl) {
      const fromR = playerEl.getBoundingClientRect();
      const toR = enemyEl.getBoundingClientRect();
      createProjectile({
        fromX: fromR.left + fromR.width/2, fromY: fromR.top + fromR.height/2,
        toX: toR.left + toR.width/2, toY: toR.top + toR.height/2,
        color: getElementColor(element), size: 36, travelMs: 200,
        onArrive: ()=> spawnShockwave(toR.left + toR.width/2, toR.top + toR.height/2, 24, getElementColor(element), 180)
      });
    }
    applyDamageToEnemy(enemy, windDmg, { type: element, source: 'weapon', setId: 'skywarden' });

    // Randomly pushes that enemy and 2 nearby enemies back and deal 50% wind damage to them
    const pushbackRadius = 150;
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;
    const playerX = playerEl ? (playerEl.getBoundingClientRect().left + playerEl.getBoundingClientRect().width/2) : 0;
    const playerY = playerEl ? (playerEl.getBoundingClientRect().top + playerEl.getBoundingClientRect().height/2) : 0;

    // Find 2 nearby enemies (excluding the main target)
    const nearbyEnemies = findEnemiesInRadius(enemyX, enemyY, pushbackRadius).filter(e => e.id !== enemy.id);
    const shuffled = nearbyEnemies.sort(() => 0.5 - Math.random());
    const pushTargets = [enemy, ...shuffled.slice(0, 2)]; // Main target + 2 nearby
    const pushDmg = Math.floor((p.currentStats?.finalATK || p.ATK || 0) * 0.50);

    pushTargets.forEach(target => {
      // Apply 50% wind damage to all 3 targets
      if (target.id !== enemy.id) {
        applyDamageToEnemy(target, pushDmg, { type: element, source: 'weapon_pushback', setId: 'skywarden' });
      }

      // Push enemy away from player
      const dx = (target.position?.x || target.x || 0) - playerX;
      const dy = (target.position?.y || target.y || 0) - playerY;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const pushDistance = 20;
      target.position.x += (dx / dist) * pushDistance;
      target.position.y += (dy / dist) * pushDistance;
    });

    // After enemy dies to wind damage, create AOE explosion (150% wind damage to surrounding enemies)
    if (enemy.hp <= 0) {
      const explosionDmg = Math.floor((p.currentStats?.finalATK || p.ATK || 0) * 0.50);
      const explosionRadius = 120;

      if (enemyEl) {
        const eR = enemyEl.getBoundingClientRect();
        const centerX = eR.left + eR.width/2;
        const centerY = eR.top + eR.height/2;

        // Create expanding wind shockwave explosion
        spawnShockwave(centerX, centerY, 120, getElementColor(element), 500);

        // Add a second smaller shockwave for depth
        setTimeout(() => {
          spawnShockwave(centerX, centerY, 80, getElementColor(element), 300);
        }, 100);
      }

      const nearbyEnemiesExplosion = findEnemiesInRadius(enemyX, enemyY, explosionRadius);
      nearbyEnemiesExplosion.forEach(e => {
        if (e.id !== enemy.id) {
          applyDamageToEnemy(e, explosionDmg, { type: element, source: 'weapon_explosion', setId: 'skywarden' });

          // Push enemies away from explosion center
          const dx = (e.position?.x || e.x || 0) - enemyX;
          const dy = (e.position?.y || e.y || 0) - enemyY;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const pushDistance = 80;
          e.position.x += (dx / dist) * pushDistance;
          e.position.y += (dy / dist) * pushDistance;
        }
      });
    }
  },

  // Storm Pike (Stormbreaker) - purple lightning arc & chaining arcs
  stormbreaker: (p, enemy, weapon) => {
    const element = 'lightning';
    const main = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
    const playerEl = document.getElementById('player-container');
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    let px = 0, py = 0, ex = 0, ey = 0;
    if (playerEl && enemyEl) {
      const pr = playerEl.getBoundingClientRect();
      const er = enemyEl.getBoundingClientRect();
      px = pr.left + pr.width/2; py = pr.top + pr.height/2;
      ex = er.left + er.width/2; ey = er.top + er.height/2;
      createLightningArc(px, py, ex, ey, getElementColor(element), 220);
    } else {
      createProjectile({ fromX: px, fromY: py, toX: ex, toY: ey, color: getElementColor(element), size: 10, travelMs: 200 });
    }
    applyDamageToEnemy(enemy, main, { type: element, source: 'weapon', setId: 'stormbreaker' });

    const has3Piece = getSetCount('stormbreaker') >= 3;
    const has6Piece = getSetCount('stormbreaker') >= 6;
    const chainRadius = 200;
    const centerX = enemy.position?.x || enemy.x || 0;
    const centerY = enemy.position?.y || enemy.y || 0;

    if (has6Piece) {
      // Multishot: Create 3 lightning arcs to that enemy and 2 random enemies not nearby each other, 120% damage each
      const allEnemies = GameState.enemies.filter(e => e.id !== enemy.id && e.hp > 0);
      const multishotTargets = [];
      const usedIds = new Set([enemy.id]);

      // Select first random enemy
      if (allEnemies.length > 0) {
        const first = allEnemies[Math.floor(Math.random() * allEnemies.length)];
        multishotTargets.push(first);
        usedIds.add(first.id);

        // Select second random enemy NOT nearby the first one
        const firstX = first.position?.x || first.x || 0;
        const firstY = first.position?.y || first.y || 0;
        const minDistance = 200; // Minimum distance to be considered "not nearby"

        const farEnemies = allEnemies.filter(e => {
          if (usedIds.has(e.id)) return false;
          const ex = e.position?.x || e.x || 0;
          const ey = e.position?.y || e.y || 0;
          const dist = Math.sqrt((ex - firstX)**2 + (ey - firstY)**2);
          return dist >= minDistance;
        });

        if (farEnemies.length > 0) {
          const second = farEnemies[Math.floor(Math.random() * farEnemies.length)];
          multishotTargets.push(second);
          usedIds.add(second.id);
        } else if (allEnemies.length > 1) {
          // If no far enemies, just pick another random one
          const remaining = allEnemies.filter(e => !usedIds.has(e.id));
          if (remaining.length > 0) {
            const second = remaining[Math.floor(Math.random() * remaining.length)];
            multishotTargets.push(second);
            usedIds.add(second.id);
          }
        }
      }

      // Fire lightning arcs to the multishot targets
      multishotTargets.forEach((target, index) => {
        setTimeout(() => {
          const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
          if (playerEl && targetEl) {
            const pr = playerEl.getBoundingClientRect();
            const tr = targetEl.getBoundingClientRect();
            createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                             tr.left + tr.width/2, tr.top + tr.height/2,
                             getElementColor(element), 220);
          }
          const multishotDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
          applyDamageToEnemy(target, multishotDmg, { type: element, source:'multishot', setId:'stormbreaker' });
        }, (index + 1) * 100);
      });

      // Then continue with guaranteed chains from 3-piece (from the multishot targets)
      if (multishotTargets.length > 0) {
        setTimeout(() => {
          const lastTarget = multishotTargets[multishotTargets.length - 1];
          const chainFrom = lastTarget;
          const chainFromPos = { x: chainFrom.position?.x || chainFrom.x || 0, y: chainFrom.position?.y || chainFrom.y || 0 };

          // At least 1 more guaranteed chain (total 4 hits including main + 2 multishot + 1 chain)
          const chainCandidates = findEnemiesInRadius(chainFromPos.x, chainFromPos.y, chainRadius).filter(e => !usedIds.has(e.id));
          if (chainCandidates.length > 0) {
            chainCandidates.sort((a,b) => {
              const ax = (a.position?.x||a.x||0)-chainFromPos.x, ay = (a.position?.y||a.y||0)-chainFromPos.y;
              const bx = (b.position?.x||b.x||0)-chainFromPos.x, by = (b.position?.y||b.y||0)-chainFromPos.y;
              return (ax*ax+ay*ay) - (bx*bx+by*by);
            });
            const chainTarget = chainCandidates[0];
            const chainTargetEl = document.querySelector(`[data-enemy-id="${chainTarget.id}"]`);
            const chainFromEl = document.querySelector(`[data-enemy-id="${chainFrom.id}"]`);

            if (chainFromEl && chainTargetEl) {
              const fr = chainFromEl.getBoundingClientRect();
              const tr = chainTargetEl.getBoundingClientRect();
              createLightningArc(fr.left + fr.width/2, fr.top + fr.height/2,
                               tr.left + tr.width/2, tr.top + tr.height/2,
                               getElementColor(element), 200);
              const chainDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
              applyDamageToEnemy(chainTarget, chainDmg, { type: element, source:'multishot_chain', setId:'stormbreaker' });
            }
          }
        }, 400);
      }
    } else if (has3Piece) {
      // Lightning Surge: Guaranteed 2+ hits, 75% damage, 50% for 4th, 25% for 5th
      const usedIds = new Set([enemy.id]);
      let prevEnemy = enemy;
      const surgeDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.75);

      // Guaranteed 2 hits
      for (let i = 0; i < 2; i++) {
        const candidates = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
        if (candidates.length === 0) break;

        candidates.sort((a,b) => {
          const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
          const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
          return (ax*ax+ay*ay) - (bx*bx+by*by);
        });
        const target = candidates[0];
        const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
        const prevEl = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);

        if (prevEl && targetEl) {
          const pr = prevEl.getBoundingClientRect();
          const tr = targetEl.getBoundingClientRect();
          setTimeout(() => {
            createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                             tr.left + tr.width/2, tr.top + tr.height/2,
                             getElementColor(element), 200);
            applyDamageToEnemy(target, surgeDmg, { type: element, source:'lightning_surge', setId:'stormbreaker' });
          }, (i + 1) * 150);
        }

        usedIds.add(target.id);
        prevEnemy = target;
      }

      // 50% chance for 4th enemy
      if (Math.random() < 0.50) {
        const candidates = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
        if (candidates.length > 0) {
          candidates.sort((a,b) => {
            const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
            const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
            return (ax*ax+ay*ay) - (bx*bx+by*by);
          });
          const target = candidates[0];
          const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
          const prevEl = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
          if (prevEl && targetEl) {
            const pr = prevEl.getBoundingClientRect();
            const tr = targetEl.getBoundingClientRect();
            setTimeout(() => {
              createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                               tr.left + tr.width/2, tr.top + tr.height/2,
                               getElementColor(element), 200);
              applyDamageToEnemy(target, surgeDmg, { type: element, source:'lightning_surge', setId:'stormbreaker' });
            }, 450);
          }
          usedIds.add(target.id);
          prevEnemy = target;

          // 25% chance for 5th enemy
          if (Math.random() < 0.25) {
            const candidates2 = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
            if (candidates2.length > 0) {
              candidates2.sort((a,b) => {
                const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
                const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
                return (ax*ax+ay*ay) - (bx*bx+by*by);
              });
              const target2 = candidates2[0];
              const target2El = document.querySelector(`[data-enemy-id="${target2.id}"]`);
              const prevEl2 = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
              if (prevEl2 && target2El) {
                const pr = prevEl2.getBoundingClientRect();
                const tr = target2El.getBoundingClientRect();
                setTimeout(() => {
                  createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                                   tr.left + tr.width/2, tr.top + tr.height/2,
                                   getElementColor(element), 200);
                  applyDamageToEnemy(target2, surgeDmg, { type: element, source:'lightning_surge', setId:'stormbreaker' });
                }, 600);
              }
            }
          }
        }
      }
    } else {
      // Original chaining: 50% for 2nd (75%), 25% for 3rd (50%)
      const usedIds = new Set([enemy.id]);
      let prevEnemy = enemy;

      if (Math.random() < 0.50) {
        const candidates = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
        if (candidates.length > 0) {
          candidates.sort((a,b) => {
            const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
            const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
            return (ax*ax+ay*ay) - (bx*bx+by*by);
          });
          const target = candidates[0];
          const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
          const prevEl = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
          let fromX = centerX, fromY = centerY, toX = target.position?.x||target.x||0, toY = target.position?.y||target.y||0;
          if (prevEl) {
            const r = prevEl.getBoundingClientRect(); fromX = r.left + r.width/2; fromY = r.top + r.height/2;
          }
          if (targetEl) { const rr = targetEl.getBoundingClientRect(); toX = rr.left + rr.width/2; toY = rr.top + rr.height/2; }
          createLightningArc(fromX, fromY, toX, toY, getElementColor(element), 200);
          const chainDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.75);
          applyDamageToEnemy(target, chainDmg, { type: element, source:'weapon_chain', setId:'stormbreaker' });
          usedIds.add(target.id);
          prevEnemy = target;

          if (Math.random() < 0.25) {
            const centerX2 = target.position?.x || target.x || 0;
            const centerY2 = target.position?.y || target.y || 0;
            const candidates2 = findEnemiesInRadius(centerX2, centerY2, chainRadius).filter(e => !usedIds.has(e.id));
            if (candidates2.length > 0) {
              candidates2.sort((a,b) => {
                const ax = (a.position?.x||a.x||0)-centerX2, ay = (a.position?.y||a.y||0)-centerY2;
                const bx = (b.position?.x||b.x||0)-centerX2, by = (b.position?.y||b.y||0)-centerY2;
                return (ax*ax+ay*ay) - (bx*bx+by*by);
              });
              const target2 = candidates2[0];
              const target2El = document.querySelector(`[data-enemy-id="${target2.id}"]`);
              const prev2El = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
              let fromX2 = centerX2, fromY2 = centerY2, toX2 = target2.position?.x||target2.x||0, toY2 = target2.position?.y||target2.y||0;
              if (prev2El) {
                const r = prev2El.getBoundingClientRect(); fromX2 = r.left + r.width/2; fromY2 = r.top + r.height/2;
              }
              if (target2El) { const rr = target2El.getBoundingClientRect(); toX2 = rr.left + rr.width/2; toY2 = rr.top + rr.height/2; }
              createLightningArc(fromX2, fromY2, toX2, toY2, getElementColor(element), 230);
              const chainDmg2 = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.50);
              applyDamageToEnemy(target2, chainDmg2, { type: element, source:'weapon_chain', setId:'stormbreaker' });
            }
          }
        }
      }
    }
  },

  bastion: (p, enemy, weapon) => {
    const element = 'physical';
    const atkComponent = (p.currentStats?.finalATK || p.ATK) * 1.20;
    const hpComponent = (getPlayerHP(p) || 0) * 0.30;
    const total = Math.floor(atkComponent + hpComponent);
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    const cx = enemyEl ? (enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2) : (enemy.x||0);
    const cy = enemyEl ? (enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2) : (enemy.y||0);
    spawnShockwave(cx, cy, 48, getElementColor('physical'), 360);
    applyDamageToEnemy(enemy, total, { type: element, source:'weapon', setId:'bastion' });

    // AoE damage: 80% physical damage equal to 20% player HP
    const aoeHpComponent = (getPlayerHP(p) || 0) * 0.20;
    const aoeDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.80 + aoeHpComponent);
    const aoeRadius = 100;
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;

    const nearbyEnemies = findEnemiesInRadius(enemyX, enemyY, aoeRadius);
    nearbyEnemies.forEach(e => {
      if (e.id !== enemy.id) {
        applyDamageToEnemy(e, aoeDmg, { type: element, source: 'weapon_aoe', setId: 'bastion' });
      }
    });
  },

  // Raven's Volley - Repeating crossbow with bouncing coins
  nightwing: (p, enemy, weapon) => {
    const element = 'physical';
    const atkComp = (p.currentStats?.finalATK || p.ATK) * 1.20;
    const mainDmg = Math.floor(atkComp);

    // Main attack visual and damage
    const playerEl = document.getElementById('player-container');
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (playerEl && enemyEl) {
      const pR = playerEl.getBoundingClientRect();
      const eR = enemyEl.getBoundingClientRect();
      createProjectile({ fromX:pR.left+pR.width/2, fromY:pR.top+pR.height/2, toX:eR.left+eR.width/2, toY:eR.top+eR.height/2, color: getElementColor('physical'), size:10, travelMs:220 });
    }
    applyDamageToEnemy(enemy, mainDmg, { type: element, source:'weapon', setId:'nightwing' });

    // After hit, spawn 2 bouncing coins that bounce 3 times each
    const coins = (p.coins || 0);
    const coinDmg = Math.floor(coins * 0.0077);

    for (let coinNum = 0; coinNum < 2; coinNum++) {
      let currentEnemy = enemy;
      const usedIds = new Set([enemy.id]);

      for (let bounce = 0; bounce < 3; bounce++) {
        setTimeout(() => {
          const candidates = GameState.enemies.filter(e => !usedIds.has(e.id));
          if (candidates.length === 0) return;

          const nextEnemy = candidates[Math.floor(Math.random() * candidates.length)];
          usedIds.add(nextEnemy.id);

          const fromEl = document.querySelector(`[data-enemy-id="${currentEnemy.id}"]`);
          const toEl = document.querySelector(`[data-enemy-id="${nextEnemy.id}"]`);

          if (fromEl && toEl) {
            const fromR = fromEl.getBoundingClientRect();
            const toR = toEl.getBoundingClientRect();
            createProjectile({
              fromX: fromR.left + fromR.width/2,
              fromY: fromR.top + fromR.height/2,
              toX: toR.left + toR.width/2,
              toY: toR.top + toR.height/2,
              color: '#ffd700',
              size: 12,
              travelMs: 200,
              onArrive: () => {
                applyDamageToEnemy(nextEnemy, coinDmg, { type: element, source: 'weapon_coin', setId: 'nightwing' });
                showElementDamage(coinDmg, 'physical', toEl, false, '#ffd700');
              }
            });
          }

          currentEnemy = nextEnemy;
        }, bounce * 250 + coinNum * 100);
      }
    }
  },

  // Wraith Scythe - HP sacrifice with execute and lifesteal on kill
  shade: (p, enemy, weapon) => {
    const element = 'physical';
    const small = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.50);

    // Lose 2% max HP, but if player has lower than 2% max HP, set HP to 1
    const hpMax = p.maxHp || p.HP_max || 1;
    const currentHP = getPlayerHP(p);
    const twoPercentHP = Math.floor(hpMax * 0.02);

    let hpLost = twoPercentHP;
    let newHP = currentHP - hpLost;

    // If current HP is lower than 2% max HP or would go below 1, set to 1
    if (currentHP <= twoPercentHP || newHP < 1) {
      hpLost = Math.max(0, currentHP - 1);
      newHP = 1;
    }

    setPlayerHP(p, newHP);

    // Track HP loss for Overflow stacks
    if (!p.lossAccumulator) p.lossAccumulator = 0;
    p.lossAccumulator += hpLost;

    // Deal 200% physical damage + 200% of HP lost
    // 3-piece: Bloodbath - increase damage dealt by HP lost by 200% (so 200% becomes 400% total)
    let hpLostMultiplier = 2.00;
    if (getSetCount('shade') >= 3) {
      hpLostMultiplier = 4.00; // 200% base + 200% bonus = 400%
    }
    const execDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 2.00 + hpLostMultiplier * hpLost);

    // Red execute VFX
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      createProjectile({
        fromX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2 + 120,
        fromY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2 - 40,
        toX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2,
        toY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2,
        color: '#ff3b3b', size: 26, travelMs: 180,
        onArrive: ()=> spawnShockwave(
          enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2,
          enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2,
          44, '#ff3b3b', 300
        )
      });
    }

    applyDamageToEnemy(enemy, execDmg, { type: element, source:'weapon_hp_loss', setId:'shade' });

    // 3-piece: Bloodbath - create rain area for 5 seconds dealing 300% of HP lost every tick
    if (getSetCount('shade') >= 3) {
      const rainDmg = Math.floor(hpLost * 3.00);
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;

      // Create visual rain zone
      const stage = document.getElementById('stage');
      if (stage) {
        const rainZone = document.createElement('div');
        rainZone.style.cssText = `position:absolute;left:${enemyX}px;top:${enemyY}px;width:100px;height:100px;border-radius:50%;background:radial-gradient(circle,rgba(255,59,59,0.4),rgba(139,0,0,0.2));border:2px solid #8b0000;transform:translate(-50%,-50%);pointer-events:none;z-index:40;`;
        document.getElementById('enemy-layer').appendChild(rainZone);

        // Add rain particles
        const particleInterval = setInterval(() => {
          if (!rainZone.parentNode) {
            clearInterval(particleInterval);
            return;
          }

          for (let i = 0; i < 3; i++) {
            const particle = document.createElement('div');
            const offsetX = (Math.random() - 0.5) * 80;
            const offsetY = (Math.random() - 0.5) * 80;
            particle.style.cssText = `position:absolute;left:${enemyX + offsetX}px;top:${enemyY + offsetY - 60}px;width:2px;height:12px;background:linear-gradient(180deg,rgba(255,59,59,0.8),rgba(139,0,0,0.4));transform:translate(-50%,0);pointer-events:none;z-index:41;transition:all 0.6s linear;opacity:1;`;
            document.getElementById('enemy-layer').appendChild(particle);

            setTimeout(() => {
              particle.style.top = `${enemyY + offsetY + 40}px`;
              particle.style.opacity = '0';
            }, 10);

            setTimeout(() => particle.remove(), 650);
          }
        }, 150);

        setTimeout(() => clearInterval(particleInterval), 5000);

        // Track zone for damage ticks
        const zoneData = {
          x: enemyX,
          y: enemyY,
          radius: 50,
          damage: rainDmg,
          startTime: Date.now(),
          duration: 5000,
          element: rainZone
        };

        if (!p.shadeRainZones) p.shadeRainZones = [];
        p.shadeRainZones.push(zoneData);

        setTimeout(() => {
          if (rainZone.parentNode) rainZone.remove();
          p.shadeRainZones = p.shadeRainZones.filter(z => z !== zoneData);
        }, 5000);
      }
    }

    // If enemy dies, restore 5% max HP
    if (enemy.hp <= 0) {
      const healAmount = Math.floor(hpMax * 0.05);
      const newHPAfterHeal = Math.min(hpMax, getPlayerHP(p) + healAmount);
      setPlayerHP(p, newHPAfterHeal);

      // Track healing for Overflow stacks
      if (!p.healAccumulator) p.healAccumulator = 0;
      p.healAccumulator += healAmount;

      // Show heal visual
      showFloatingChange(healAmount, 'heal');
    }

    // 6-piece: Overflow - if player <50% HP, heal to full and create explosion
    if (getSetCount('shade') >= 6) {
      const currentHP = getPlayerHP(p);
      const halfHP = hpMax * 0.50;

      if (currentHP < halfHP) {
        setPlayerHP(p, hpMax);
        showFloatingChange(hpMax - currentHP, 'heal');

        // Create giant red explosion
        const stage = document.getElementById('stage');
        const playerEl = document.getElementById('player-container');
        if (playerEl && stage) {
          const rect = playerEl.getBoundingClientRect();
          const stageRect = stage.getBoundingClientRect();
          const explosionDmg = Math.floor((p.lossAccumulator || 0) * 5.00);

          // Create giant red explosion with shockwave
          const centerX = rect.left + rect.width/2;
          const centerY = rect.top + rect.height/2;

          spawnShockwave(centerX, centerY, 200, '#ff0000', 600);

          // Add explosion particles radiating outward
          for (let i = 0; i < 30; i++) {
            const angle = (i / 30) * Math.PI * 2;
            const distance = 200;
            const particleX = centerX + Math.cos(angle) * distance;
            const particleY = centerY + Math.sin(angle) * distance;

            const particle = document.createElement('div');
            particle.style.cssText = `position:absolute;left:${centerX - stageRect.left}px;top:${centerY - stageRect.top}px;width:16px;height:16px;border-radius:50%;background:radial-gradient(circle,rgba(255,59,59,1),rgba(139,0,0,0.6));transform:translate(-50%,-50%);pointer-events:none;z-index:65;transition:all 0.6s ease-out;opacity:1;box-shadow:0 0 12px rgba(255,59,59,0.8);`;
            stage.appendChild(particle);

            setTimeout(() => {
              particle.style.left = `${particleX - stageRect.left}px`;
              particle.style.top = `${particleY - stageRect.top}px`;
              particle.style.opacity = '0';
              particle.style.width = '4px';
              particle.style.height = '4px';
            }, 10);

            setTimeout(() => particle.remove(), 650);
          }

          const playerX = stage.clientWidth / 2;
          const playerY = stage.clientHeight / 2;

          GameState.enemies.forEach(e => {
            const dx = playerX - (e.position?.x || e.x || 0);
            const dy = playerY - (e.position?.y || e.y || 0);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= 200) {
              applyDamageToEnemy(e, explosionDmg, { type: 'physical', source: 'overflow_explosion', setId: 'shade' });
            }
          });

          showNotification('üíÄ Overflow! Full heal + massive explosion!', 'legendary');
        }
      }
    }
  },

  // Aegis Scepter - launches a ball that hovers around enemy dealing continuous damage
  aegis: (p, enemy, weapon) => {
    const element = 'aether';
    const has3Piece = getSetCount('aegis') >= 3;
    const has6Piece = getSetCount('aegis') >= 6;

    // Base ball: 120% damage, 2 second duration
    const dmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
    applyDamageToEnemy(enemy, dmg, { type: element, source:'weapon', setId:'aegis' });

    // Launch ball that hovers and deals damage
    const ballDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
    spawnAegisHoveringBall(enemy, ballDmg, 2000, p, has3Piece, has6Piece);
  },

  glacier: (p, enemy, weapon) => {
    const element = 'cryo';
    const cryoDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
    applyDamageToEnemy(enemy, cryoDmg, { type: element, source:'weapon', setId:'glacier' });

    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      spawnShockwave(enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2, enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2, 28, getElementColor(element), 260);
    }

    // Freeze enemy for 2 seconds - if enemy is already frozen before, they can't be frozen again for 10 seconds
    const now = Date.now();
    if (!enemy.freezeCooldownUntil || now >= enemy.freezeCooldownUntil) {
      enemy.frozen = true;
      enemy.frozenTimer = 2.0; // 2 second freeze
      enemy.frozenAt = now;
      enemy.originalSpeed = enemy.speed;
      enemy.speed = 0; // Stop movement while frozen

      // Set cooldown: after unfrozen, can't freeze again for 10 seconds
      enemy.freezeCooldownUntil = now + 12000; // 2s freeze + 10s cooldown
    }

    // After enemy is dead, create a cryo AOE that freezes enemies
    if (enemy.hp <= 0) {
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;
      const aoeDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.10);

      // Create cryo AOE zone that freezes enemies for 3 seconds and deals 10% cryo damage every tick
      createCryoZone(enemyX, enemyY, aoeDmg, 5000, p);
    }
  },

  // Emberkin - Inferno Blade: instant damage + fire AoE zone
  emberkin: (p, enemy, weapon) => {
    const element = 'fire';
    const instant = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
    const burnTick = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.20);

    applyDamageToEnemy(enemy, instant, { type: element, source:'weapon', setId:'emberkin' });

    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      createProjectile({
        fromX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2 + 80,
        fromY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2 - 20,
        toX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2,
        toY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2,
        color: getElementColor(element), size: 18, travelMs: 200
      });
    }

    // Create fire AoE zone that lasts 10 seconds
    // Enemies entering or within the AOE take 20% fire damage every tick for 5 seconds
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;
    createFireZone(enemyX, enemyY, burnTick, 10000, p);
  },

  // Zephyr - Gale Daggers: stars (star-shaped) and explosions
  zephyr: (p, enemy, weapon) => {
    const element = 'aether';
    const main = Math.floor((p.currentStats?.finalATK || p.ATK) * 1.20);
    applyDamageToEnemy(enemy, main, { type: element, source:'weapon', setId:'zephyr' });

    // 4-piece: +2 stars (6 total)
    let nStars = 4;
    if (getSetCount('zephyr') >= 4) nStars = 6;

    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    const fromX = enemyEl ? (enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2) : (enemy.x||0);
    const fromY = enemyEl ? (enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2) : (enemy.y||0);

    const starDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.50);

    for (let i=0;i<nStars;i++){
      const candidates = GameState.enemies.filter(e => e.id !== enemy.id);
      const randTarget = candidates.length ? candidates[Math.floor(Math.random()*candidates.length)] : null;
      const toX = randTarget ? (randTarget.position?.x||randTarget.x||0) : (fromX + (Math.random()*240 - 120));
      const toY = randTarget ? (randTarget.position?.y||randTarget.y||0) : (fromY + (Math.random()*240 - 120));

      createStarProjectile({
        fromX, fromY, toX, toY, color: getElementColor(element), size: 12, travelMs: 260,
        onArrive: ()=> {
          const hits = findEnemiesInRadius(toX, toY, 40);
          hits.forEach(h => {
            applyDamageToEnemy(h, starDmg, { type: element, source:'weapon_star', setId:'zephyr' });

            // 3-piece: Blow - explosion on each star collision
            if (getSetCount('zephyr') >= 3) {
              const explosionDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.50);
              const nearbyEnemies = findEnemiesInRadius(toX, toY, 80);
              nearbyEnemies.forEach(ne => {
                if (ne.id !== h.id) {
                  applyDamageToEnemy(ne, explosionDmg, { type: element, source:'zephyr_explosion', setId:'zephyr' });
                }
              });
              const hitEl = document.querySelector(`[data-enemy-id="${h.id}"]`);
              if (hitEl) {
                const rect = hitEl.getBoundingClientRect();
                spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 60, getElementColor(element), 300);
              }
            }
          });

          // 6-piece: Bounce to another random enemy
          if (getSetCount('zephyr') >= 6 && hits.length > 0) {
            const bounceCandidates = GameState.enemies.filter(e => !hits.some(h => h.id === e.id));
            if (bounceCandidates.length > 0) {
              const bounceTarget = bounceCandidates[Math.floor(Math.random() * bounceCandidates.length)];
              const bounceToX = bounceTarget.position?.x || bounceTarget.x || 0;
              const bounceToY = bounceTarget.position?.y || bounceTarget.y || 0;

              setTimeout(() => {
                createStarProjectile({
                  fromX: toX, fromY: toY, toX: bounceToX, toY: bounceToY,
                  color: getElementColor(element), size: 12, travelMs: 260,
                  onArrive: () => {
                    applyDamageToEnemy(bounceTarget, starDmg, { type: element, source:'weapon_star_bounce', setId:'zephyr' });
                    if (getSetCount('zephyr') >= 3) {
                      const explosionDmg = Math.floor((p.currentStats?.finalATK || p.ATK) * 0.50);
                      const nearbyEnemies = findEnemiesInRadius(bounceToX, bounceToY, 80);
                      nearbyEnemies.forEach(ne => {
                        if (ne.id !== bounceTarget.id) {
                          applyDamageToEnemy(ne, explosionDmg, { type: element, source:'zephyr_explosion', setId:'zephyr' });
                        }
                      });
                    }
                  }
                });
              }, 100);
            }
          }
        }
      });
    }
  }
}; // end WEAPON_HANDLERS
/* ---------- Updated attackEnemy to call weapon handler ---------- */

/* ---------- attackEnemy: updated to skip click when Aegis equipped ---------- */
function attackEnemy(enemy) {
  if (GameState.isDead || !GameState.canAttack) return;

  const player = GameState.player;
  const weaponItem = player.equipment && player.equipment.weapon;
  const hasSetWeapon = weaponItem && weaponItem.setId;
  const isAegisEquipped = weaponItem && weaponItem.setId === 'aegis';

  // If player has a weapon from a set: Deal ONLY Element Damage (no physical click damage)
  // If player has no weapon or non-set weapon: Deal physical damage normally
  if (!hasSetWeapon) {
    // No set weapon equipped - deal normal physical click damage
    const clickResult = computeDamage(enemy);
    enemy.hp -= clickResult.damage;
    enemy.lastHit = { type: 'physical', source: 'click', setId: null, damage: clickResult.damage };
    // show click number
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      const n = document.createElement('div');
      n.className = 'drop-item';
      n.textContent = clickResult.crit ? `${clickResult.damage}!` : `${clickResult.damage}`;
      n.style.left = `${enemy.position?.x || enemy.x || 0}px`;
      n.style.top = `${(enemy.position?.y || enemy.y || 0) - 30}px`;
      n.style.color = clickResult.crit ? '#ff0' : '#fff';
      n.style.fontWeight = '700';
      document.getElementById('drop-layer').appendChild(n);
      setTimeout(()=> n.remove(), 1400);
    }
  } else if (isAegisEquipped) {
    // Aegis special case: ensure orbiters spawn and show small pulse
    ensureAegisOrbiters(player);
    const playerEl = document.getElementById('player-container');
    if (playerEl) {
      const pr = playerEl.getBoundingClientRect();
      spawnShockwave(pr.left + pr.width/2, pr.top + pr.height/2, 32, getElementColor('aether'), 220);
    }
  }
  // Note: If hasSetWeapon is true (but not Aegis), we skip physical damage entirely
  // and only deal elemental damage through the weapon handler below

  // Weapon unique attack - deals ONLY elemental damage for set weapons
  if (weaponItem && weaponItem.isWeapon && weaponItem.setId) {
    const handler = WEAPON_HANDLERS[weaponItem.setId];
    if (handler) {
      try { handler(player, enemy, weaponItem); }
      catch(e){ console.error('weapon handler error', e); }
    } else {
      // fallback: elemental damage only
      const p = player;
      const weaponBase = Math.floor((p.currentStats?.finalATK || p.ATK) * (weaponItem.weaponMultiplier || 1.20));
      const el = weaponItem.element || (weaponItem.setId && (EQUIPMENT_SETS[weaponItem.setId]?.element || 'physical')) || 'physical';
      applyDamageToEnemy(enemy, weaponBase, { type: el, source:'weapon', setId: weaponItem.setId||null });
    }
  }

  // handle death if hp <= 0 (applyDamageToEnemy handles AoE explosion for skywarden)
  if (enemy.hp <= 0) {
    // onEnemyDeath already invoked inside applyDamageToEnemy
    // fallback in case click killed before weapon applied:
    if (enemy.lastHit && enemy.lastHit.type === 'wind' && enemy.lastHit.setId === 'skywarden') {
      // handled earlier; nothing extra
    }
  }
}

function showFloatingDamage(damage, isCrit, element) {
  if (!element) return;

  const stage = document.getElementById('stage');
  if (!stage) return;

  const rect = element.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const dmgEl = document.createElement('div');
  dmgEl.className = 'drop-item';
  dmgEl.textContent = isCrit ? `${damage}! ‚ö°` : damage;
  dmgEl.style.left = `${rect.left - stageRect.left + rect.width / 2}px`;
  dmgEl.style.top = `${rect.top - stageRect.top - 30}px`;
  dmgEl.style.color = isCrit ? '#ff0' : '#ffa500';
  dmgEl.style.fontWeight = 'bold';
  dmgEl.style.fontSize = '18px';

  const dropLayer = document.getElementById('drop-layer');
  if (dropLayer) {
    dropLayer.appendChild(dmgEl);
    setTimeout(() => dmgEl.remove(), 2000);
  }
}

function showDrop(position, icon) {
  const drop = document.createElement('div');
  drop.className = 'drop-item';
  drop.textContent = icon;
  drop.style.left = `${position.x}px`;
  drop.style.top = `${position.y}px`;
  document.getElementById('drop-layer').appendChild(drop);
  setTimeout(() => drop.remove(), 2000);
}

// ========== Tooltip System ==========
// ========== Tooltip helpers & System ==========
function buildItemTooltipHtml(item, isEquipped) {
  let html = `
    <div class="tooltip-header-row">
      <div class="tooltip-header-left">
        <div class="tooltip-header text-${item.rarity || 'common'}">${item.name}</div>
        ${item.type === 'equipment' ? `<div class="tooltip-level">Level: ${item.level} ${item.stars > 0 ? `(${item.stars}‚≠ê)` : ''}</div>` : ''}
      </div>
      ${item.type === 'equipment' ? `
        <div class="tooltip-base-stat">
          <div class="base-stat-name">${item.baseAttribute.name}</div>
          <div class="base-stat-value">${item.baseAttribute.value}</div>
        </div>
      ` : ''}
    </div>
    <div class="tooltip-content">
  `;

  if (item.type === 'equipment') {
    // Add set information if item is part of a set
    if (item.setId && EQUIPMENT_SETS[item.setId]) {
      const setData = EQUIPMENT_SETS[item.setId];
      const p = GameState.player;
      const setCount = (p.activeSets && p.activeSets[item.setId]) || 0;

      html += `<div style="padding: 10px; margin: 8px 0; background: rgba(212,175,55,0.15); border: 2px solid var(--accent-gold); border-radius: 6px;">`;
      html += `<div style="color: var(--accent-gold); font-weight: 700; margin-bottom: 6px; font-size: 13px;">${setData.icon} ${setData.name} Set (${setCount}/6)</div>`;

      // Show weapon ability if this is a weapon
      if (item.slot === 'weapon' && setData.weaponName && setData.weaponDesc) {
        html += `<div style="padding: 6px; margin: 6px 0; background: rgba(0,0,0,0.3); border-left: 3px solid var(--accent-gold); font-size: 10px;">`;
        html += `<div style="color: var(--accent-gold-bright); font-weight: 600; margin-bottom: 3px;">‚öîÔ∏è ${setData.weaponName}</div>`;
        html += `<div style="color: var(--text-secondary); line-height: 1.4;">${setData.weaponDesc}</div>`;
        html += `</div>`;
      }

      // Show set bonuses
      html += `<div style="margin-top: 8px; font-size: 10px;">`;
      [2, 3, 4, 6].forEach(tier => {
        const bonus = setData.bonuses[tier];
        if (bonus) {
          const active = setCount >= tier;
          const color = active ? 'var(--text-primary)' : 'var(--text-dim)';
          const weight = active ? '600' : '400';
          const checkmark = active ? '‚úì' : '‚óã';
          html += `<div style="color: ${color}; font-weight: ${weight}; padding: 2px 0; line-height: 1.3;">`;
          html += `<span style="color: ${active ? '#4fc3f7' : 'var(--text-dim)'};">${checkmark} ${tier}-piece:</span> ${bonus.desc}`;
          html += `</div>`;
        }
      });
      html += `</div></div>`;
    }

    // Item attributes
    item.affixes.forEach(affix => {
      const suffix = (affix.name.includes('%') || affix.name.includes('Crit')) ? '%' : '';
      if (affix.locked) {
        html += `<div class="tooltip-attr locked">${affix.name}: ${affix.value}${suffix} (Upgrade to level ${affix.unlockLevel})</div>`;
      } else {
        html += `<div class="tooltip-attr">${affix.name}: ${affix.value}${suffix}</div>`;
      }
    });

    const cost = getUpgradeCost(item);
    html += `
      </div>
      <div class="tooltip-actions">
        ${!isEquipped ? `<button class="tooltip-btn primary" onclick="equipItem('${item.id}')">Equip</button>` : ''}
        ${isEquipped ? `<button class="tooltip-btn secondary" onclick="unequipItem('${item.slot}')">Unequip</button>` : ''}
        <button class="tooltip-btn secondary" onclick="upgradeItem('${item.id}')">Upgrade (üí∞${cost.coins} ${cost.gems > 0 ? `üíé${cost.gems}` : ''})</button>
        <button class="tooltip-btn danger" onclick="sellItem('${item.id}')">Sell (üí∞${item.sellPrice})</button>
      </div>
    `;
  } else if (item.type === 'consumable') {
    html += `
      <div>${item.name}</div>
      <div class="tooltip-actions">
        <button class="tooltip-btn primary" onclick="useConsumable('${item.id}')">Use</button>
      </div>
    </div>
    `;
  } else {
    html += `</div>`;
  }

  return html;
}

function buildShopItemTooltipHtml(item) {
  let html = `
    <div class="tooltip-header-row">
      <div class="tooltip-header-left">
        <div class="tooltip-header text-${item.rarity || 'common'}">${item.name}</div>
        ${item.type === 'equipment' ? `<div class="tooltip-level">Level: ${item.level} ${item.stars > 0 ? `(${item.stars}‚≠ê)` : ''}</div>` : ''}
      </div>
      ${item.type === 'equipment' ? `
        <div class="tooltip-base-stat">
          <div class="base-stat-name">${item.baseAttribute.name}</div>
          <div class="base-stat-value">${item.baseAttribute.value}</div>
        </div>
      ` : ''}
    </div>
    <div class="tooltip-content">
  `;

  if (item.type === 'equipment') {
    // Add set information if item is part of a set
    if (item.setId && EQUIPMENT_SETS[item.setId]) {
      const setData = EQUIPMENT_SETS[item.setId];
      const p = GameState.player;
      const setCount = (p.activeSets && p.activeSets[item.setId]) || 0;

      html += `<div style="padding: 10px; margin: 8px 0; background: rgba(212,175,55,0.15); border: 2px solid var(--accent-gold); border-radius: 6px;">`;
      html += `<div style="color: var(--accent-gold); font-weight: 700; margin-bottom: 6px; font-size: 13px;">${setData.icon} ${setData.name} Set (${setCount}/6)</div>`;

      // Show weapon ability if this is a weapon
      if (item.slot === 'weapon' && setData.weaponName && setData.weaponDesc) {
        html += `<div style="padding: 6px; margin: 6px 0; background: rgba(0,0,0,0.3); border-left: 3px solid var(--accent-gold); font-size: 10px;">`;
        html += `<div style="color: var(--accent-gold-bright); font-weight: 600; margin-bottom: 3px;">‚öîÔ∏è ${setData.weaponName}</div>`;
        html += `<div style="color: var(--text-secondary); line-height: 1.4;">${setData.weaponDesc}</div>`;
        html += `</div>`;
      }

      // Show set bonuses
      html += `<div style="margin-top: 8px; font-size: 10px;">`;
      [2, 3, 4, 6].forEach(tier => {
        const bonus = setData.bonuses[tier];
        if (bonus) {
          const active = setCount >= tier;
          const color = active ? 'var(--text-primary)' : 'var(--text-dim)';
          const weight = active ? '600' : '400';
          const checkmark = active ? '‚úì' : '‚óã';
          html += `<div style="color: ${color}; font-weight: ${weight}; padding: 2px 0; line-height: 1.3;">`;
          html += `<span style="color: ${active ? '#4fc3f7' : 'var(--text-dim)'};">${checkmark} ${tier}-piece:</span> ${bonus.desc}`;
          html += `</div>`;
        }
      });
      html += `</div></div>`;
    }

    item.affixes.forEach(affix => {
      const suffix = (affix.name.includes('%') || affix.name.includes('Crit')) ? '%' : '';
      if (affix.locked) {
        html += `<div class="tooltip-attr locked">${affix.name}: ${affix.value}${suffix} (Upgrade to level ${affix.unlockLevel})</div>`;
      } else {
        html += `<div class="tooltip-attr">${affix.name}: ${affix.value}${suffix}</div>`;
      }
    });

    html += `
      </div>
      <div class="tooltip-actions">
        <button class="tooltip-btn primary buy-shop-btn" data-item-id="${item.id}">Buy (üí∞${item.buyPrice.toLocaleString()})</button>
      </div>
    `;
  } else if (item.type === 'consumable') {
    html += `
      <div style="padding: 8px;">${item.desc || item.name}</div>
      </div>
      <div class="tooltip-actions">
        <button class="tooltip-btn primary buy-shop-btn" data-item-id="${item.id}">Buy (üíé${item.price})</button>
      </div>
    `;
  } else {
    html += `</div>`;
  }

  return html;
}

function showShopItemTooltip(item, targetEl) {
  const tooltip = document.getElementById('inventory-tooltip');

  // Set content first
  tooltip.innerHTML = buildShopItemTooltipHtml(item);

  // Temporarily position offscreen to measure without showing
  const originalLeft = tooltip.style.left;
  const originalTop = tooltip.style.top;
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
  tooltip.setAttribute('aria-hidden', 'false');

  // Force a reflow to get dimensions
  tooltip.offsetHeight;

  const tooltipRect = tooltip.getBoundingClientRect();
  const rect = targetEl.getBoundingClientRect();

  // Calculate position
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

  let left = rect.right + 8;
  let top = rect.top;

  // Better mobile handling - center tooltip if it doesn't fit
  if (vw < 768) {
    // On mobile, center the tooltip horizontally if it would go offscreen
    if (tooltipRect.width > vw - 16) {
      left = 8;
    } else {
      left = Math.max(8, Math.min(vw - tooltipRect.width - 8, rect.left));
    }
    // Position below the target element on mobile
    top = rect.bottom + 8;
  } else {
    // Desktop behavior
    if (left + tooltipRect.width > vw - 8) {
      left = rect.left - tooltipRect.width - 8;
    }
    // If still offscreen on left, center it
    if (left < 8) {
      left = Math.max(8, (vw - tooltipRect.width) / 2);
    }
  }
  
  // Vertical positioning - ensure it stays on screen
  if (top + tooltipRect.height > vh - 8) {
    top = vh - tooltipRect.height - 8;
  }
  if (top < 8) top = 8;

  // Apply final position
  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

function hideTooltip() {
  const tooltip = document.getElementById('inventory-tooltip');
  tooltip.setAttribute('aria-hidden', 'true');

  // Clear any active effect tooltip timer
  if (GameState.effectTooltipTimer) {
    clearInterval(GameState.effectTooltipTimer);
    GameState.effectTooltipTimer = null;
  }
}

function showEffectTooltip(effect, targetEl) {
  const tooltip = document.getElementById('inventory-tooltip');

  // Clear any existing effect tooltip timer
  if (GameState.effectTooltipTimer) {
    clearInterval(GameState.effectTooltipTimer);
    GameState.effectTooltipTimer = null;
  }

  // Map effect IDs to readable info
  const effectData = {
    'exp_boost_200': { name: 'EXP Boost x3', description: 'Experience gain multiplied by 3', icon: 'üìö' },
    'dmg_boost_200': { name: 'Damage Boost x3', description: 'Damage output multiplied by 3', icon: '‚ö°' },
    'coins_boost_200': { name: 'Coins Boost x3', description: 'Coin drops multiplied by 3', icon: 'üí∞' }
  };

  const data = effectData[effect.id] || { name: effect.id, description: 'Active effect', icon: '‚ú®' };

  // Function to update the timer display
  const updateTimer = () => {
    const now = Date.now();
    const elapsed = (now - effect.startedAtTs) / 1000;
    const remaining = Math.max(0, effect.durationSec - elapsed);
    const minutes = Math.floor(remaining / 60);
    const seconds = Math.floor(remaining % 60);

    const timerEl = tooltip.querySelector('.effect-tooltip-timer');
    if (timerEl) {
      timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Close tooltip if effect expired
    if (remaining <= 0) {
      hideTooltip();
    }
  };

  // Initial render
  const now = Date.now();
  const elapsed = (now - effect.startedAtTs) / 1000;
  const remaining = Math.max(0, effect.durationSec - elapsed);
  const minutes = Math.floor(remaining / 60);
  const seconds = Math.floor(remaining % 60);

  tooltip.innerHTML = `
    <div class="tooltip-header-row">
      <div class="tooltip-header-left">
        <div class="tooltip-header text-legendary">${data.name}</div>
      </div>
      <div class="tooltip-base-stat">
        <div class="base-stat-name">TIME</div>
        <div class="base-stat-value effect-tooltip-timer" style="font-size: 20px;">${minutes}:${seconds.toString().padStart(2, '0')}</div>
      </div>
    </div>
    <div class="tooltip-content">
      <div style="text-align: center; font-size: 48px; margin: 8px 0;">${data.icon}</div>
      <div style="margin-top: 8px;">${data.description}</div>
    </div>
  `;

  // Start updating the timer every second
  GameState.effectTooltipTimer = setInterval(updateTimer, 1000);

  // Temporarily position offscreen to measure
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
  tooltip.setAttribute('aria-hidden', 'false');

  // Force reflow
  tooltip.offsetHeight;

  const tooltipRect = tooltip.getBoundingClientRect();
  const rect = targetEl.getBoundingClientRect();

  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

  let left = rect.right + 8;
  let top = rect.top;

  // Better mobile handling
  if (vw < 768) {
    if (tooltipRect.width > vw - 16) {
      left = 8;
    } else {
      left = Math.max(8, Math.min(vw - tooltipRect.width - 8, rect.left));
    }
    top = rect.bottom + 8;
  } else {
    if (left + tooltipRect.width > vw - 8) {
      left = rect.left - tooltipRect.width - 8;
    }
    if (left < 8) {
      left = Math.max(8, (vw - tooltipRect.width) / 2);
    }
  }
  
  if (top + tooltipRect.height > vh - 8) {
    top = vh - tooltipRect.height - 8;
  }
  if (top < 8) top = 8;

  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

function showItemTooltip(item, targetEl, isEquipped) {
  const tooltip = document.getElementById('inventory-tooltip');
  const rect = targetEl.getBoundingClientRect();

  // build content using helper
  tooltip.innerHTML = buildItemTooltipHtml(item, isEquipped);

  // mark which item is shown (so we can update it later without needing the target element)
  tooltip.dataset.currentItemId = item.id;
  tooltip.dataset.isEquipped = !!isEquipped;

  // Temporarily show offscreen to measure
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
  tooltip.setAttribute('aria-hidden', 'false');
  
  // Force reflow
  tooltip.offsetHeight;

  // position tooltip near target
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const tooltipRect = tooltip.getBoundingClientRect();
  
  let left = rect.right + 8;
  let top = rect.top;

  // Better mobile handling
  if (vw < 768) {
    // On mobile, center the tooltip horizontally if it would go offscreen
    if (tooltipRect.width > vw - 16) {
      left = 8;
    } else {
      left = Math.max(8, Math.min(vw - tooltipRect.width - 8, rect.left));
    }
    // Position below the target element on mobile
    top = rect.bottom + 8;
  } else {
    // Desktop behavior
    if (left + tooltipRect.width > vw - 8) {
      left = rect.left - tooltipRect.width - 8;
    }
    // If still offscreen on left, center it
    if (left < 8) {
      left = Math.max(8, (vw - tooltipRect.width) / 2);
    }
  }
  
  // Vertical positioning
  if (top + tooltipRect.height > vh - 8) {
    top = Math.max(8, vh - tooltipRect.height - 8);
  }

  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

// ========== World Progress & Boss ==========
function updateWorldProgress() {
  const wp = GameState.worldProgress;
  const p = GameState.player;

  wp.requiredEnemies = 25 * p.world;
  wp.requiredElites = Math.max(1, Math.floor(p.world / 2));
  wp.requiredLevel = Math.min(2 + p.world * 1, 100);

  const enemiesMet = wp.enemiesKilledThisWorld >= wp.requiredEnemies;
  const elitesMet = wp.elitesKilledThisWorld >= wp.requiredElites;
  const levelMet = p.level >= wp.requiredLevel;

  document.getElementById('req-enemies-text').textContent = `${wp.enemiesKilledThisWorld} / ${wp.requiredEnemies}`;
  document.getElementById('req-elites-text').textContent = `${wp.elitesKilledThisWorld} / ${wp.requiredElites}`;
  document.getElementById('req-level-text').textContent = `${p.level} / ${wp.requiredLevel}`;

  document.getElementById('req-enemies').className = enemiesMet ? 'requirement met' : 'requirement not-met';
  document.getElementById('req-elites').className = elitesMet ? 'requirement met' : 'requirement not-met';
  document.getElementById('req-level').className = levelMet ? 'requirement met' : 'requirement not-met';

    const allMet = enemiesMet && elitesMet && levelMet;
    document.getElementById('btn-challenge-boss').disabled = !allMet;

    // Show the requirements panel by default, but hide it while a boss fight is active
    const panel = document.getElementById('boss-requirements');
    if (GameState.suspendWaves) {
      // we are in a boss fight (or waves suspended) ‚Äî hide the panel
      panel.className = 'panel';
    } else {
      // not fighting boss ‚Äî keep it visible even if requirements aren't met
      panel.className = 'panel visible';
    }

}

// ========== Dynamic Challenge System ==========
const CHALLENGE_TYPES = {
  STANDARD: { name: 'Standard', desc: 'Defeat enemies and elites normally without dying' },
  SPEED: { name: 'Speed Challenge', desc: 'Defeat 20 enemies within 60 seconds without dying', requiredEnemies: 20, timeLimit: 60 },
  ELITE_HUNTER: { name: 'Elite Hunter', desc: 'Focus on defeating 5 elite/special enemies without dying', requiredElites: 5 },
  SURVIVAL: { name: 'Survival', desc: 'Survive 3 waves of increasing difficulty without dying', requiredWaves: 3 },
  PERFECT: { name: 'Perfect Challenge', desc: 'Defeat boss without dying' }
};

function selectRandomChallenge() {
  const challenges = Object.keys(CHALLENGE_TYPES);
  return challenges[Math.floor(Math.random() * challenges.length)];
}

function startChallenge(challengeType) {
  GameState.currentChallenge = challengeType;
  GameState.challengeProgress = {
    enemiesKilled: 0,
    elitesKilled: 0,
    wavesCompleted: 0,
    bossKilled: false,
    died: false,
    startTime: Date.now(),
    timeLimit: CHALLENGE_TYPES[challengeType].timeLimit || 0
  };
  
  // Show timer for speed challenge
  if (challengeType === 'SPEED') {
    document.getElementById('challenge-timer').style.display = 'block';
    updateChallengeTimer();
  }
  
  showNotification(`üéØ Challenge: ${CHALLENGE_TYPES[challengeType].name}`, 'info');
}

function updateChallengeTimer() {
  if (GameState.currentChallenge !== 'SPEED') return;
  
  const elapsed = (Date.now() - GameState.challengeProgress.startTime) / 1000;
  const remaining = Math.max(0, GameState.challengeProgress.timeLimit - elapsed);
  const minutes = Math.floor(remaining / 60);
  const seconds = Math.floor(remaining % 60);
  
  const timerEl = document.getElementById('timer-text');
  if (timerEl) {
    timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
  
  // Check if time ran out
  if (remaining <= 0 && !verifyChallengeComplete()) {
    failChallenge('Time ran out!');
  }
}

function trackChallengeProgress(enemy) {
  if (!GameState.currentChallenge) return;
  
  GameState.challengeProgress.enemiesKilled++;
  if (enemy.type === 'elite') {
    GameState.challengeProgress.elitesKilled++;
  }
  if (enemy.type === 'boss') {
    GameState.challengeProgress.bossKilled = true;
  }
}

function trackWaveCompletion() {
  if (GameState.currentChallenge === 'SURVIVAL' && GameState.enemies.length === 0) {
    GameState.challengeProgress.wavesCompleted++;
    
    // Check if there are more waves to complete
    const requiredWaves = CHALLENGE_TYPES['SURVIVAL'].requiredWaves;
    if (GameState.challengeProgress.wavesCompleted < requiredWaves) {
      // Spawn next wave
      const nextWave = GameState.challengeProgress.wavesCompleted + 1;
      setTimeout(() => {
        spawnSurvivalWave(nextWave);
      }, 2000); // 2 second delay between waves
    } else {
      // All waves completed! End the challenge
      showNotification('‚úÖ All waves completed!', 'legendary');
      // Will be verified when checked in gameTick
    }
  }
}

function trackDeath() {
  if (GameState.currentChallenge) {
    GameState.challengeProgress.died = true;
    failChallenge('You died!');
  }
}

function verifyChallengeComplete() {
  if (!GameState.currentChallenge) return false;
  
  const challenge = CHALLENGE_TYPES[GameState.currentChallenge];
  const progress = GameState.challengeProgress;
  
  // Check if died (all challenges fail on death)
  if (progress.died) return false;
  
  switch (GameState.currentChallenge) {
    case 'STANDARD':
      // Just need to not die and defeat the boss normally
      return progress.bossKilled;
      
    case 'SPEED':
      // Must kill required enemies within time limit without dying
      const elapsed = (Date.now() - progress.startTime) / 1000;
      return progress.enemiesKilled >= challenge.requiredEnemies && elapsed <= challenge.timeLimit;
      
    case 'ELITE_HUNTER':
      // Must defeat required number of elites without dying
      return progress.elitesKilled >= challenge.requiredElites;
      
    case 'SURVIVAL':
      // Must complete ALL required waves without dying
      return progress.wavesCompleted >= challenge.requiredWaves;
      
    case 'PERFECT':
      // Defeat boss without dying
      return progress.bossKilled;
      
    default:
      return false;
  }
}

function completeChallenge() {
  if (!GameState.currentChallenge) return;
  
  const challengeName = CHALLENGE_TYPES[GameState.currentChallenge].name;
  showNotification(`‚úÖ ${challengeName} Complete!`, 'legendary');
  
  // Hide timer if it was shown
  document.getElementById('challenge-timer').style.display = 'none';
  
  // Reset challenge
  GameState.currentChallenge = null;
}

function failChallenge(reason) {
  if (!GameState.currentChallenge) return;
  
  showNotification(`‚ùå Challenge Failed: ${reason}`, 'danger');
  
  // Hide timer if it was shown
  document.getElementById('challenge-timer').style.display = 'none';
  
  // Reset challenge
  GameState.currentChallenge = null;
}

function challengeBoss() {
  if (GameState.suspendWaves) return;

  // Start a random dynamic challenge
  const challengeType = selectRandomChallenge();
  startChallenge(challengeType);

  GameState.suspendWaves = true;
  GameState.inBossChallenge = true;
  GameState.enemies = [];

  // Spawn enemies based on challenge type
  switch (challengeType) {
    case 'STANDARD':
    case 'PERFECT':
      // These challenges are boss battles
      const boss = createEnemy('boss', GameState.player.world);
      GameState.enemies.push(boss);
      showNotification('üêâ Boss Battle!', 'danger');
      break;
      
    case 'SPEED':
      // Speed challenge: spawn 20+ normal enemies for a fast-paced battle
      showNotification('‚ö° Speed Challenge: Defeat 20 enemies in 60 seconds!', 'epic');
      for (let i = 0; i < 25; i++) {
        const enemy = createEnemy('normal', GameState.player.world);
        GameState.enemies.push(enemy);
      }
      break;
      
    case 'ELITE_HUNTER':
      // Elite Hunter: spawn 5 elite enemies and some normal enemies
      showNotification('üëë Elite Hunter: Defeat 5 elite enemies!', 'legendary');
      for (let i = 0; i < 5; i++) {
        const elite = createEnemy('elite', GameState.player.world);
        GameState.enemies.push(elite);
      }
      // Add some normal enemies for variety
      for (let i = 0; i < 10; i++) {
        const enemy = createEnemy('normal', GameState.player.world);
        GameState.enemies.push(enemy);
      }
      break;
      
    case 'SURVIVAL':
      // Survival: Start with first wave, will spawn more waves as they complete
      showNotification('üõ°Ô∏è Survival: Complete 3 waves without dying!', 'rare');
      spawnSurvivalWave(1);
      break;
  }

  document.getElementById('boss-requirements').className = 'panel';
}

function spawnSurvivalWave(waveNumber) {
  if (!GameState.currentChallenge || GameState.currentChallenge !== 'SURVIVAL') return;
  
  // Clear existing enemies
  GameState.enemies = [];
  
  // Spawn enemies based on wave number (increasing difficulty)
  const normalCount = 10 + (waveNumber * 5);
  const eliteCount = waveNumber;
  
  for (let i = 0; i < normalCount; i++) {
    const enemy = createEnemy('normal', GameState.player.world);
    GameState.enemies.push(enemy);
  }
  
  for (let i = 0; i < eliteCount; i++) {
    const elite = createEnemy('elite', GameState.player.world);
    GameState.enemies.push(elite);
  }
  
  showNotification(`üåä Wave ${waveNumber}/3 - ${normalCount} enemies, ${eliteCount} elites`, 'info');
}

function onChallengeComplete() {
  // Check if challenge was completed successfully
  if (GameState.currentChallenge && verifyChallengeComplete()) {
    completeChallenge();
  } else if (GameState.currentChallenge) {
    failChallenge('Challenge requirements not met');
  }

  GameState.player.world++;

  // Track world completion
  if (GameState.player.statistics) {
    GameState.player.statistics.worldsCompleted++;
  }

  GameState.worldProgress.enemiesKilledThisWorld = 0;
  GameState.worldProgress.elitesKilledThisWorld = 0;
  GameState.suspendWaves = false;
  GameState.inBossChallenge = false;

  showNotification(`üéâ Boss defeated! Welcome to World ${GameState.player.world}!`, 'legendary');
  updateWorldProgress();
}

// ========== Active Effects ==========
function updateActiveEffects() {
  const now = Date.now();
  GameState.player.activeEffects = GameState.player.activeEffects.filter(effect => {
    const elapsed = (now - effect.startedAtTs) / 1000;
    return elapsed < effect.durationSec;
  });

  // Render in inventory
  const iconsContainer = document.getElementById('active-effects-icons');
  if (!iconsContainer) return;

  if (GameState.player.activeEffects.length === 0) {
    iconsContainer.innerHTML = '<div class="no-effects-message">No active effects</div>';
  } else {
    // Map effect IDs to icons and names
    const effectData = {
      'exp_boost_200': { icon: 'üìö', name: 'EXP Boost x3', description: 'Experience gain multiplied by 3' },
      'dmg_boost_200': { icon: '‚ö°', name: 'Damage Boost x3', description: 'Damage output multiplied by 3' },
      'coins_boost_200': { icon: 'üí∞', name: 'Coins Boost x3', description: 'Coin drops multiplied by 3' }
    };

    iconsContainer.innerHTML = GameState.player.activeEffects.map((effect, index) => {
      const elapsed = (now - effect.startedAtTs) / 1000;
      const remaining = Math.max(0, effect.durationSec - elapsed);
      const minutes = Math.floor(remaining / 60);
      const seconds = Math.floor(remaining % 60);
      const data = effectData[effect.id] || { icon: '‚ú®', name: effect.id, description: 'Active effect' };

      return `
        <div class="effect-icon" data-effect-index="${index}" title="${data.name}">
          <div class="effect-icon-image">${data.icon}</div>
          <div class="effect-icon-timer">${minutes}:${seconds.toString().padStart(2, '0')}</div>
        </div>
      `;
    }).join('');

    // Add click handlers for tooltips and hover handlers for bounce animation
    iconsContainer.querySelectorAll('.effect-icon').forEach(iconEl => {
      // Bounce animation on hover (once per hover)
      iconEl.addEventListener('mouseenter', (e) => {
        const el = e.currentTarget;
        // Only add bounce if not already bouncing
        if (!el.classList.contains('bouncing')) {
          el.classList.add('bouncing');
          // Remove the class after animation completes
          setTimeout(() => {
            el.classList.remove('bouncing');
          }, 300);
        }
      });

      // Tooltip on click
      iconEl.addEventListener('click', (e) => {
        const effectIndex = parseInt(e.currentTarget.getAttribute('data-effect-index'));
        const effect = GameState.player.activeEffects[effectIndex];
        if (effect) {
          showEffectTooltip(effect, e.currentTarget);
        }
      });
    });
  }

  // Update coins and gems display in inventory
  const invCoinsEl = document.getElementById('inv-coins');
  const invGemsEl = document.getElementById('inv-gems');
  if (invCoinsEl) invCoinsEl.textContent = Math.floor(GameState.player.coins).toLocaleString();
  if (invGemsEl) invGemsEl.textContent = Math.floor(GameState.player.gems).toLocaleString();
}

// ========== Save/Load ==========
function saveGame() {
  // Update total play time before saving
  if (GameState.player.statistics) {
    const currentSession = (Date.now() - GameState.player.statistics.sessionStartTime) / 1000;
    GameState.player.statistics.totalPlayTime += currentSession;
    GameState.player.statistics.sessionStartTime = Date.now(); // Reset session timer
  }

  const saveData = {
    saveVersion: 1,
    timestamp: Date.now(),
    player: GameState.player,
    shop: GameState.shop,
    worldProgress: GameState.worldProgress
  };

  localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(saveData));
  GameState.lastSaveTime = Date.now();
}

function loadGame() {
  const saved = localStorage.getItem(CONFIG.SAVE_KEY);
  if (!saved) return false;

  try {
    const data = JSON.parse(saved);
    GameState.player = data.player;
    GameState.shop = data.shop;
    GameState.worldProgress = data.worldProgress;

    // Ensure inventory is properly initialized as sparse array
    if (!GameState.player.inventory) {
      GameState.player.inventory = [];
    }

    // Initialize statistics if missing (for backward compatibility)
    if (!GameState.player.statistics) {
      GameState.player.statistics = {
        totalKills: 0,
        totalDamageDealt: 0,
        totalDamageTaken: 0,
        totalCoinsEarned: 0,
        totalGemsEarned: 0,
        totalExpGained: 0,
        bossesDefeated: 0,
        deaths: 0,
        criticalHits: 0,
        itemsFound: 0,
        itemsPurchased: 0,
        worldsCompleted: 0,
        totalPlayTime: 0,
        sessionStartTime: Date.now()
      };
    } else {
      // Reset session start time for loaded game
      GameState.player.statistics.sessionStartTime = Date.now();
    }

    // Clean up invalid equipment data before computing stats
    try {
      cleanupInvalidEquipment();
    } catch (cleanupError) {
      console.error('Error during equipment cleanup:', cleanupError);
    }

    computeDerivedStats();
    return true;
  } catch (e) {
    console.error('Failed to load save:', e);
    showNotification('Error: Failed to load save: ' + e.message, 'danger');
    return false;
  }
}

// Clean up any invalid equipment data that might cause errors
function cleanupInvalidEquipment() {
  const p = GameState.player;
  if (!p || !p.equipment) return;

  // Check each equipment slot
  Object.keys(p.equipment).forEach(slot => {
    const item = p.equipment[slot];
    if (!item) return;

    // Ensure item has required properties
    if (!item.name) {
      console.warn(`Equipment in slot ${slot} has no name, removing:`, item);
      p.equipment[slot] = null;
      return;
    }

    // If item has a setId, validate it exists
    if (item.setId) {
      const setData = EQUIPMENT_SETS[item.setId];
      if (!setData) {
        console.warn(`Removing invalid setId "${item.setId}" from ${item.name}`);
        delete item.setId;
      }
    }
  });

  // Check inventory
  if (p.inventory) {
    for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
      const item = p.inventory[i];
      if (!item) continue;

      if (!item.name) {
        console.warn(`Inventory item at index ${i} has no name, removing:`, item);
        delete p.inventory[i];
        continue;
      }

      if (item.setId) {
        const setData = EQUIPMENT_SETS[item.setId];
        if (!setData) {
          console.warn(`Removing invalid setId "${item.setId}" from ${item.name}`);
          delete item.setId;
        }
      }
    }
  }

  // Check shop offers
  if (GameState.shop && GameState.shop.offers && GameState.shop.offers.equipment) {
    GameState.shop.offers.equipment = GameState.shop.offers.equipment.filter(item => {
      if (!item || !item.name) {
        console.warn('Removing invalid shop item:', item);
        return false;
      }
      if (item.setId && !EQUIPMENT_SETS[item.setId]) {
        console.warn(`Removing invalid setId "${item.setId}" from shop item ${item.name}`);
        delete item.setId;
      }
      return true;
    });
  }

  // Rebuild activeSets from scratch
  const setCounts = {};
  Object.keys(p.equipment || {}).forEach(slot => {
    const item = p.equipment[slot];
    if (item && item.setId && EQUIPMENT_SETS[item.setId]) {
      setCounts[item.setId] = (setCounts[item.setId] || 0) + 1;
    }
  });
  p.activeSets = setCounts;
}

// ========== Notifications ==========
function showNotification(message, type = 'info') {
  const container = document.getElementById('notification-container');
  if (!container) {
    console.log(`[${type.toUpperCase()}] ${message}`);
    return;
  }

  // Create notification element
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;

  // Add to container
  container.appendChild(notification);

  // Auto-remove after 3 seconds
  setTimeout(() => {
    notification.style.animation = 'fadeOut 0.3s ease-out';
    setTimeout(() => {
      if (notification.parentNode === container) {
        container.removeChild(notification);
      }
    }, 300);
  }, 3000);
}

function showFloatingChange(amount, kind) {
  if (!amount) return;

  const id = (kind === 'gems') ? 'gems' : 'coins';
  let el = document.getElementById(id);

  // If inventory is open, also show floating change on inventory resources
  const invOverlay = document.getElementById('inventory-overlay');
  if (invOverlay && invOverlay.getAttribute('aria-hidden') === 'false') {
    const invId = (kind === 'gems') ? 'inv-gems' : 'inv-coins';
    const invEl = document.getElementById(invId);
    if (invEl) {
      createFloatingChange(invEl, amount);
    }
  }

  if (!el) {
    console.warn('showFloatingChange: target element not found #' + id);
    return;
  }

  createFloatingChange(el, amount);
}

function createFloatingChange(el, amount) {
  // create node
  const node = document.createElement('div');
  node.className = 'floating-change ' + (amount > 0 ? 'positive' : 'negative');
  node.textContent = (amount > 0 ? `+${amount}` : `${amount}`);

  // append to body so it's positioned relative to viewport
  document.body.appendChild(node);

  // measure
  const rect = el.getBoundingClientRect();

  // place offscreen to force layout, then measure size
  node.style.position = 'absolute';
  node.style.left = '0px';
  node.style.top = '-9999px';
  node.style.pointerEvents = 'none';
  // force layout
  // eslint-disable-next-line no-unused-expressions
  node.offsetWidth;

  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  // Align right edge of popup with right edge of the element:
  // left = rect.right - node.offsetWidth
  let left = rect.right - node.offsetWidth;

  // clamp so it stays in viewport with 8px padding
  left = Math.min(Math.max(8, left), Math.max(8, vw - node.offsetWidth - 8));

  // position it just below the element (aligned to right)
  const top = rect.bottom - 4;

  Object.assign(node.style, {
    left: `${left}px`,
    top: `${top}px`,
    transform: 'translateY(0)', // start position (no offset)
    opacity: '1',
    position: 'absolute',
    zIndex: '9999'
  });

  // force reflow so transition runs
  // eslint-disable-next-line no-unused-expressions
  node.offsetHeight;

  // animate: move a bit down and fade out
  requestAnimationFrame(() => {
    node.style.transform = 'translateY(8px)'; // moves downward
    node.style.opacity = '0';
  });

  // cleanup
  setTimeout(() => {
    if (node && node.parentNode) node.parentNode.removeChild(node);
  }, 900);
}


// ========== Overlay Management ==========
function openOverlay(id) {
  const overlay = document.getElementById(id);
  overlay.setAttribute('aria-hidden', 'false');

  if (id === 'inventory-overlay') renderInventory();
  if (id === 'shop-overlay') renderShop();
}

function closeOverlay(id) {
  const overlay = document.getElementById(id);
  overlay.setAttribute('aria-hidden', 'true');
  hideTooltip();
}


// ========== SET BONUS IMPLEMENTATION ==========

function getSetCount(setId) {
  const p = GameState.player;
  return (p.activeSets && p.activeSets[setId]) || 0;
}

function initializeSetBonusTracking() {
  const p = GameState.player;
  if (!p.setBonusTracking) {
    p.setBonusTracking = {
      nightwing: { coinsCollected: 0, wealthStacks: 0, wealthStackExpiry: [] },
      shade: { hpLossAccumulator: 0, hpHealAccumulator: 0, bloodthirstStacks: 0, bloodthirstStackExpiry: [] },
      bastion: { shockRoarTimer: 0 },
      emberkin: { fireKillCount: 0, igniteAOEs: [] },
      glacier: { frozenEnemies: new Set() },
      aegis: { activeBalls: [] },
      zephyr: { activeStars: [] }
    };
  }
}

function updateSetBonusesPeriodic(dt) {
  const p = GameState.player;
  initializeSetBonusTracking();

  // BASTION 3-PIECE: Shock Roar every 2 seconds
  if (getSetCount('bastion') >= 3) {
    p.setBonusTracking.bastion.shockRoarTimer += dt;
    if (p.setBonusTracking.bastion.shockRoarTimer >= 1.5) {
      p.setBonusTracking.bastion.shockRoarTimer = 0;
      const stage = document.getElementById('stage');
      const playerX = stage.clientWidth / 2;
      const playerY = stage.clientHeight / 2;

      // 6-piece: Metal Fierce increases area and changes color
      const has6Piece = getSetCount('bastion') >= 6;
      const isLowHP = getPlayerHP(p) < (p.maxHp || p.HP_max || 1) * 0.50;

      let shockRadius = 150;
      if (has6Piece && isLowHP) {
        shockRadius = 250; // Increased area
      }

      const shockColor = (has6Piece && isLowHP) ? '#ffcccc' : '#d4af37'; // Light red when Metal Fierce active
      const shockDamage = Math.floor((p.maxHp || 0) * 0.5 * 1.80);

      const playerEl = document.getElementById('player-container');
      if (playerEl) {
        const rect = playerEl.getBoundingClientRect();
        spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, shockRadius, shockColor, 300);
      }
      GameState.enemies.forEach(enemy => {
        const dx = playerX - enemy.position.x;
        const dy = playerY - enemy.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= shockRadius) {
          applyDamageToEnemy(enemy, shockDamage, { type: 'physical', source: 'shock_roar', setId: 'bastion' });
        }
      });
    }
  }

  // NIGHTWING 6-PIECE: Wealth stack decay
  if (getSetCount('nightwing') >= 6) {
    p.setBonusTracking.nightwing.wealthStackExpiry = p.setBonusTracking.nightwing.wealthStackExpiry.filter(expiry => {
      if (Date.now() >= expiry) {
        p.setBonusTracking.nightwing.wealthStacks = Math.max(0, p.setBonusTracking.nightwing.wealthStacks - 1);
        computeDerivedStats();
        return false;
      }
      return true;
    });
  }

  // SHADE 6-PIECE: Bloodthirst stack decay
  if (getSetCount('shade') >= 6) {
    p.setBonusTracking.shade.bloodthirstStackExpiry = p.setBonusTracking.shade.bloodthirstStackExpiry.filter(expiry => {
      if (Date.now() >= expiry) {
        p.setBonusTracking.shade.bloodthirstStacks = Math.max(0, p.setBonusTracking.shade.bloodthirstStacks - 1);
        computeDerivedStats();
        return false;
      }
      return true;
    });
  }

    // SHADE 3-PIECE: Bloodbath rain zone damage ticks
  if (getSetCount('shade') >= 3 && p.shadeRainZones) {
    p.shadeRainZones.forEach(zone => {
      if (Date.now() - zone.startTime <= zone.duration) {
        GameState.enemies.forEach(enemy => {
          const dx = zone.x - (enemy.position?.x || enemy.x || 0);
          const dy = zone.y - (enemy.position?.y || enemy.y || 0);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= zone.radius) {
            applyDamageToEnemy(enemy, Math.floor(zone.damage), { type: 'physical', source: 'bloodbath_rain', setId: 'shade', isDoT: true });
          }
        });
      }
    });
  }

  // EMBERKIN: Fire zone damage ticks (same mechanics as Bloodbath)
  if (p.emberkinFireZones) {
    p.emberkinFireZones.forEach(zone => {
      const now = Date.now();
      if (now - zone.startTime <= zone.duration) {
        GameState.enemies.forEach(enemy => {
          const enemyX = enemy.position?.x || enemy.x || 0;
          const enemyY = enemy.position?.y || enemy.y || 0;
          const dist = Math.sqrt((zone.x - enemyX)**2 + (zone.y - enemyY)**2);

          if (dist <= zone.radius) {
            // Track when enemy entered zone
            if (!zone.affectedEnemies.has(enemy.id)) {
              zone.affectedEnemies.set(enemy.id, { enteredAt: now, lastTickAt: 0 });
            }

            const enemyData = zone.affectedEnemies.get(enemy.id);

            // Deal damage every tick if within burn duration and enough time has passed
            if (now - enemyData.enteredAt < zone.burnDuration && now - enemyData.lastTickAt >= 200) {
              // Calculate burn damage with 3-piece bonus
              let totalBurnDmg = zone.baseDamage;
              if (getSetCount('emberkin') >= 3) {
                totalBurnDmg += Math.floor((p.currentStats?.finalATK || p.ATK) * 0.08);
              }

              applyDamageToEnemy(enemy, Math.floor(totalBurnDmg), { type: 'fire', source: 'weapon_zone', setId: 'emberkin', isDoT: true });
              enemyData.lastTickAt = now;
            }
          } else {
            // Enemy left zone
            zone.affectedEnemies.delete(enemy.id);
          }
        });

        // Clean up old entries
        for (const [enemyId, data] of zone.affectedEnemies.entries()) {
          if (now - data.enteredAt >= zone.burnDuration) {
            zone.affectedEnemies.delete(enemyId);
          }
        }
      }
    });
  }

  // EMBERKIN 6-PIECE: Ignite AOE damage ticks
  if (getSetCount('emberkin') >= 6 && p.setBonusTracking.emberkin.igniteAOEs) {
    p.setBonusTracking.emberkin.igniteAOEs = p.setBonusTracking.emberkin.igniteAOEs.filter(aoe => {
      const elapsed = Date.now() - aoe.startTime;
      if (elapsed > aoe.duration) {
        if (aoe.element && aoe.element.parentNode) aoe.element.remove();
        return false;
      }

      const now = Date.now();

      // Track which enemies are affected (similar to fire zones)
      if (!aoe.affectedEnemies) {
        aoe.affectedEnemies = new Map();
      }

      GameState.enemies.forEach(enemy => {
        const dx = aoe.x - (enemy.position?.x || enemy.x || 0);
        const dy = aoe.y - (enemy.position?.y || enemy.y || 0);
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= aoe.radius) {
          // Track when enemy entered zone
          if (!aoe.affectedEnemies.has(enemy.id)) {
            aoe.affectedEnemies.set(enemy.id, { enteredAt: now, lastTickAt: 0 });
          }

          const enemyData = aoe.affectedEnemies.get(enemy.id);

          // Deal damage every 200ms (same tick rate as regular fire zones) for 10 seconds after entering
          if (now - enemyData.enteredAt < 10000 && now - enemyData.lastTickAt >= 200) {
            const tickDmg = Math.floor((p.currentStats?.finalATK || 0) * 0.65);
            applyDamageToEnemy(enemy, tickDmg, { type: 'fire', source: 'ignite_aoe', setId: 'emberkin', isDoT: true });
            enemyData.lastTickAt = now;
          }
        } else {
          // Enemy left zone
          aoe.affectedEnemies.delete(enemy.id);
        }
      });

      // Clean up old entries
      for (const [enemyId, data] of aoe.affectedEnemies.entries()) {
        if (now - data.enteredAt >= 10000) {
          aoe.affectedEnemies.delete(enemyId);
        }
      }

      return true;
    });
  }
}

function handleSetBonusOnKill(enemy) {
  const p = GameState.player;
  initializeSetBonusTracking();

  // NIGHTWING 6-PIECE: Wealth stacks
  if (getSetCount('nightwing') >= 6) {
    const coins = enemy.dropProfile?.coinBase || 0;
    p.setBonusTracking.nightwing.coinsCollected = (p.setBonusTracking.nightwing.coinsCollected || 0) + coins;
    while (p.setBonusTracking.nightwing.coinsCollected >= 10000 && p.setBonusTracking.nightwing.wealthStacks < 9) {
      p.setBonusTracking.nightwing.coinsCollected -= 10000;
      p.setBonusTracking.nightwing.wealthStacks++;
      p.setBonusTracking.nightwing.wealthStackExpiry.push(Date.now() + 30000);
      showNotification('üí∞ Wealth stack gained! (+20% DMG)', 'legendary');
      computeDerivedStats();
    }

  // NIGHTWING 6-PIECE: Wealth Rain - track coin kills
    if (getSetCount('nightwing') >= 6 && enemy.lastHit && enemy.lastHit.source && enemy.lastHit.source.includes('coin')) {
      if (!p.nightwingCoinKills) p.nightwingCoinKills = 0;

      // Don't count rain kills
      if (enemy.lastHit.source !== 'wealth_rain') {
        p.nightwingCoinKills++;

        if (p.nightwingCoinKills >= 20) {
          p.nightwingCoinKills = 0;

          // Rain coins visually on full screen for 5 seconds
          const rainDmg = Math.floor(p.coins * 0.0188);
          const rainDuration = 5000;
          const rainStartTime = Date.now();

          // Create full-screen coin rain effect
          const stage = document.getElementById('stage');
          if (stage) {
            const stageRect = stage.getBoundingClientRect();

            const rainInterval = setInterval(() => {
              if (Date.now() - rainStartTime >= rainDuration) {
                clearInterval(rainInterval);
                return;
              }

              // Create coins falling across the entire screen
              for (let i = 0; i < 15; i++) {
                const startX = Math.random() * stageRect.width;
                const startY = -50;
                const endY = stageRect.height + 50;

                const particle = document.createElement('div');
                particle.textContent = 'üí∞';
                particle.style.cssText = `position:absolute;left:${startX}px;top:${startY}px;font-size:20px;transform:translate(-50%,0);pointer-events:none;z-index:55;transition:all 1.2s linear;opacity:1;`;
                stage.appendChild(particle);

                setTimeout(() => {
                  particle.style.top = `${endY}px`;
                  particle.style.opacity = '0.3';
                }, 10);

                setTimeout(() => particle.remove(), 1250);
              }

              // Deal damage to all enemies on field
              GameState.enemies.forEach(e => {
                if (e.hp > 0) {
                  applyDamageToEnemy(e, rainDmg, { type: 'physical', source: 'wealth_rain', setId: 'nightwing' });
                }
              });
            }, 150); // Rain every 150ms for denser effect
          }

          showNotification('üí∞üí∞üí∞ Coin Rain! üí∞üí∞üí∞', 'legendary');
        }
      }
    }

    // NIGHTWING 3-PIECE: Rich Man's Blow
  if (getSetCount('nightwing') >= 3 && enemy.lastHit && enemy.lastHit.source === 'weapon_coin') {
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;
    const coinDmg = Math.floor(p.coins * 0.0099);

    // Shoot 5 coins in star pattern
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const distance = 120;
      const toX = enemyX + Math.cos(angle) * distance;
      const toY = enemyY + Math.sin(angle) * distance;

      setTimeout(() => {
        const enemyElPos = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
        const stage = document.getElementById('stage');
        if (stage) {
          createProjectile({
            fromX: enemyX, fromY: enemyY, toX: toX, toY: toY,
            color: '#ffd700', size: 12, travelMs: 250,
            onArrive: () => {
              const hits = findEnemiesInRadius(toX, toY, 50);
              hits.forEach(hit => {
                applyDamageToEnemy(hit, coinDmg, { type: 'physical', source: 'rich_mans_blow', setId: 'nightwing' });
              });
            }
          });
        }
      }, i * 50);
    }
  }
  }

  // EMBERKIN 6-PIECE: Ignite
  if (getSetCount('emberkin') >= 6 && enemy.lastHit && enemy.lastHit.type === 'fire') {
    p.setBonusTracking.emberkin.fireKillCount = (p.setBonusTracking.emberkin.fireKillCount || 0) + 1;
    if (p.setBonusTracking.emberkin.fireKillCount >= 10) {
      p.setBonusTracking.emberkin.fireKillCount = 0;
      const stage = document.getElementById('stage');
      const w = stage.clientWidth;
      const h = stage.clientHeight;

      // Create 3 giant red-pink fire zones around the player
      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2;
        const distance = 150 + Math.random() * 100;
        const playerX = w / 2;
        const playerY = h / 2;
        const x = playerX + Math.cos(angle) * distance;
        const y = playerY + Math.sin(angle) * distance;

        const fireAOE = document.createElement('div');
        fireAOE.className = 'fire-aoe-ignite';
        fireAOE.style.cssText = 'position:absolute;left:'+x+'px;top:'+y+'px;width:180px;height:180px;border-radius:50%;background:radial-gradient(circle,rgba(255,100,150,0.7),rgba(255,50,100,0.4),rgba(255,0,50,0.2));border:3px solid rgba(255,100,150,0.8);box-shadow:0 0 40px rgba(255,100,100,0.9), inset 0 0 30px rgba(255,50,100,0.5);transform:translate(-50%,-50%);pointer-events:none;z-index:40;animation:fire-pulse 1s infinite;';
        document.getElementById('enemy-layer').appendChild(fireAOE);
        p.setBonusTracking.emberkin.igniteAOEs.push({ x: x, y: y, radius: 90, startTime: Date.now(), duration: 10000, element: fireAOE });
      }
      showNotification('üî• Ignite! Created 3 giant fire zones!', 'legendary');
    }
  }

  // GLACIER 6-PIECE: Ice Storm
  if (getSetCount('glacier') >= 6 && enemy.lastHit && enemy.lastHit.type === 'cryo') {
    const now = Date.now();

    // Check if cooldown has passed (30 seconds)
    if (!p.glacierIceStormCooldown || now >= p.glacierIceStormCooldown) {
      p.glacierIceStormCooldown = now + 30000; // 30 second cooldown

      // Freeze ALL enemies on the field for 5 seconds
      GameState.enemies.forEach(e => {
        if (e.hp > 0) {
          e.frozen = true;
          e.frozenTimer = 5.0; // 5 second freeze
          e.frozenAt = now;
          e.originalSpeed = e.speed;
          e.speed = 0;
          // Don't set freezeCooldownUntil here as this is a special 6-piece effect

          // Visual effect
          const enemyEl = document.querySelector(`[data-enemy-id="${e.id}"]`);
          if (enemyEl) {
            const rect = enemyEl.getBoundingClientRect();
            spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 50, getElementColor('cryo'), 400);
            enemyEl.style.filter = 'brightness(1.5) saturate(0.3) hue-rotate(180deg)';
            setTimeout(() => {
              if (enemyEl) enemyEl.style.filter = '';
            }, 5000);
          }
        }
      });

      showNotification('‚ùÑÔ∏è Ice Storm! All enemies frozen! ‚ùÑÔ∏è', 'legendary');
    }
  }

  // SKYWARDEN 3-PIECE: Wind Storm - 3 explosions
  if (getSetCount('skywarden') >= 3 && enemy.lastHit && enemy.lastHit.type === 'wind') {
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;

    // Create 3 small explosions nearby
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2;
      const distance = 80;
      const explX = enemyX + Math.cos(angle) * distance;
      const explY = enemyY + Math.sin(angle) * distance;

      setTimeout(() => {
        const explDmg = Math.floor((p.currentStats?.finalATK || 0) * 0.50);
        const nearbyEnemies = findEnemiesInRadius(explX, explY, 60);
        nearbyEnemies.forEach(e => {
          applyDamageToEnemy(e, explDmg, { type: 'wind', source: 'wind_storm', setId: 'skywarden' });
        });

        const tornadoEl = document.createElement('div');
        tornadoEl.style.cssText = `position:absolute;left:${explX}px;top:${explY}px;width:80px;height:80px;border-radius:50%;background:radial-gradient(circle, transparent 20%, rgba(152,251,152,0.5) 50%, rgba(152,251,152,0.8) 70%, transparent 100%);transform:translate(-50%,-50%);pointer-events:none;z-index:45;animation:spin 0.5s linear, wind-pulse 0.4s ease-out;`;
        document.getElementById('enemy-layer').appendChild(tornadoEl);
        setTimeout(() => tornadoEl.remove(), 500);
      }, i * 150);
    }
  }

  // SKYWARDEN 6-PIECE: Aquila Tornado - every 20 wind kills
  if (getSetCount('skywarden') >= 6 && enemy.lastHit && enemy.lastHit.type === 'wind') {
    if (!p.skywardenWindKills) p.skywardenWindKills = 0;
    p.skywardenWindKills++;

    if (p.skywardenWindKills >= 20) {
      p.skywardenWindKills = 0;

      // Pick random enemy for tornado
      const availableEnemies = GameState.enemies.filter(e => e.hp > 0);
      if (availableEnemies.length > 0) {
        const tornadoTarget = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
        const tornadoX = tornadoTarget.position?.x || tornadoTarget.x || 0;
        const tornadoY = tornadoTarget.position?.y || tornadoTarget.y || 0;

        // Create giant tornado with improved visuals
        const tornadoEl = document.createElement('div');
        tornadoEl.style.cssText = `position:absolute;left:${tornadoX}px;top:${tornadoY}px;width:40px;height:40px;border-radius:50%;background:radial-gradient(circle, rgba(152,251,152,0.2) 0%, rgba(152,251,152,0.6) 40%, rgba(152,251,152,0.9) 70%, transparent 100%);box-shadow:0 0 30px rgba(152,251,152,0.8), inset 0 0 20px rgba(200,255,200,0.5);transform:translate(-50%,-50%);pointer-events:none;z-index:46;transition:all 1s ease-out;`;
        document.getElementById('enemy-layer').appendChild(tornadoEl);

        // Scale up tornado
        setTimeout(() => {
          tornadoEl.style.width = '200px';
          tornadoEl.style.height = '200px';
          tornadoEl.style.animation = 'spin 1s linear infinite, wind-pulse 2s ease-in-out infinite';
        }, 50);

        // Pull enemies and deal damage for 5 seconds
        const tornadoStart = Date.now();
        const tornadoDuration = 5000;
        const pullRadius = 200;
        const tornadoDmg = Math.floor((p.currentStats?.finalATK || 0) * 0.50);

        const tornadoInterval = setInterval(() => {
          const elapsed = Date.now() - tornadoStart;
          if (elapsed >= tornadoDuration) {
            clearInterval(tornadoInterval);

            // Scale down and remove
            tornadoEl.style.transition = 'all 0.5s ease-in';
            tornadoEl.style.width = '0px';
            tornadoEl.style.height = '0px';
            tornadoEl.style.opacity = '0';
            setTimeout(() => tornadoEl.remove(), 500);
            return;
          }

          // Pull enemies towards tornado and damage them
          GameState.enemies.forEach(e => {
            const dx = tornadoX - (e.position?.x || e.x || 0);
            const dy = tornadoY - (e.position?.y || e.y || 0);
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist <= pullRadius) {
              // Pull towards center
              const pullStrength = 0.15;
              e.position.x += (dx / dist) * pullStrength * 20;
              e.position.y += (dy / dist) * pullStrength * 20;

              // Deal damage each tick
              if (Math.random() < 0.5) { // 50% chance per tick to avoid spam
                applyDamageToEnemy(e, tornadoDmg, { type: 'wind', source: 'aquila_tornado', setId: 'skywarden', isDoT: true });
              }
            }
          });
        }, 200); // Tick every 200ms

        showNotification('üå™Ô∏è Aquila Tornado summoned!', 'legendary');
      }
    }
  }
}

function trackShadeHPChange(amount) {
  const p = GameState.player;
  if (getSetCount('shade') < 6) return;
  initializeSetBonusTracking();
  if (amount < 0) {
    p.setBonusTracking.shade.hpLossAccumulator = (p.setBonusTracking.shade.hpLossAccumulator || 0) + Math.abs(amount);
  } else {
    p.setBonusTracking.shade.hpHealAccumulator = (p.setBonusTracking.shade.hpHealAccumulator || 0) + amount;
  }
  const totalChange = (p.setBonusTracking.shade.hpLossAccumulator || 0) + (p.setBonusTracking.shade.hpHealAccumulator || 0);
  while (totalChange >= 200 && p.setBonusTracking.shade.bloodthirstStacks < 99) {
    const toDeduct = Math.min(200, p.setBonusTracking.shade.hpLossAccumulator + p.setBonusTracking.shade.hpHealAccumulator);
    if (p.setBonusTracking.shade.hpLossAccumulator >= toDeduct) {
      p.setBonusTracking.shade.hpLossAccumulator -= toDeduct;
    } else {
      const remaining = toDeduct - p.setBonusTracking.shade.hpLossAccumulator;
      p.setBonusTracking.shade.hpLossAccumulator = 0;
      p.setBonusTracking.shade.hpHealAccumulator -= remaining;
    }
    p.setBonusTracking.shade.bloodthirstStacks++;
    p.setBonusTracking.shade.bloodthirstStackExpiry.push(Date.now() + 30000);
    showNotification('üíÄ Bloodthirst stack gained! (+2% DMG)', 'legendary');
    computeDerivedStats();
  }
}


// ========== Game Loop ==========
function gameTick() {

  const dt = (CONFIG.TICK_INTERVAL_MS / 1000) * CONFIG.GAME_TIME_SCALE;

  updateEnemies(dt);

  // Process status effects (burn, slow, freeze, etc.)
  processEnemyStatusTicks(CONFIG.TICK_INTERVAL_MS);

  // Update death system
  updateDeathSystem(dt);

  // snapshot current positions for next frame's interpolation (AFTER update)
  if (GameState && GameState.enemies) GameState.enemies.forEach(e => { e.prevX = e.position.x; e.prevY = e.position.y; });
  GameState.lastPhysicsTs = performance.now();

  updateSetBonusesPeriodic(dt);

  GameState.autoAttackTimer += dt;
  const attackInterval = getAttackInterval();
  if (GameState.autoAttackTimer >= attackInterval) {
    GameState.autoAttackTimer -= attackInterval;

    // Get player's auto-attack range (different from enemy engagement range)
    const weaponItem = GameState.player.equipment && GameState.player.equipment.weapon;
    let playerAttackRange = CONFIG.ENGAGE_RADIUS_PX;
    if (weaponItem) {
      // Weapon equipped - increase player's attack range
      if (weaponItem.setId) {
        // Set weapon - 50% increased range
        playerAttackRange = CONFIG.ENGAGE_RADIUS_PX * 1.5;
      } else {
        // Regular weapon - 25% increased range
        playerAttackRange = CONFIG.ENGAGE_RADIUS_PX * 1.25;
      }
    }

    // Find closest enemy within player's attack range
    const stage = document.getElementById('stage');
    const playerX = stage.clientWidth / 2;
    const playerY = stage.clientHeight / 2;

    let target = null;
    let minDistance = playerAttackRange;

    GameState.enemies.forEach(enemy => {
      const dx = playerX - enemy.position.x;
      const dy = playerY - enemy.position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance <= playerAttackRange && distance < minDistance) {
        minDistance = distance;
        target = enemy;
      }
    });

    if (target) {
      attackEnemy(target);
    }
  }

  if (!GameState.suspendWaves) {
    GameState.waveTimer += dt;
    if (GameState.waveTimer >= CONFIG.WAVE_INTERVAL_SEC) {
      GameState.waveTimer -= CONFIG.WAVE_INTERVAL_SEC;
      spawnWave();
    }
  }

  // Update challenge timer for speed challenge
  if (GameState.currentChallenge === 'SPEED') {
    updateChallengeTimer();
  }

  // Check if challenge is complete when all enemies defeated
  if (GameState.suspendWaves && GameState.enemies.length === 0 && !GameState.isDead) {
    onChallengeComplete();
  }

  if (Date.now() - GameState.lastSaveTime > CONFIG.SAVE_INTERVAL_MS) {
    saveGame();
  }
}

function uiTick() {
  renderUI();
  renderEnemies();
  renderPlayerStats();
  
  // Update challenge timer
  if (GameState.currentChallenge === 'SPEED') {
    updateChallengeTimer();
  }

  const shop = GameState.shop;
  const timeUntilRefresh = CONFIG.SHOP_AUTO_REFRESH_SEC - Math.floor((Date.now() - shop.lastRefreshTs) / 1000);
  if (timeUntilRefresh <= 0) {
    refreshShop();
  }
  document.getElementById('shop-timer').textContent = `Auto refreshes in: ${Math.max(0, timeUntilRefresh)}s`;

  const canManualRefresh = Date.now() >= shop.manualCooldownEndTs;
  const btn = document.getElementById('btn-manual-refresh');
  btn.disabled = !canManualRefresh;
  if (!canManualRefresh) {
    const cooldown = Math.ceil((shop.manualCooldownEndTs - Date.now()) / 1000);
    btn.textContent = `Refresh (${cooldown}s)`;
  } else {
    btn.textContent = 'Refresh';
  }
}

// ========== Dev Tools ==========
const DevTools = {
  spawnEnemies(count, type) {
    for (let i = 0; i < count; i++) {
      const enemy = createEnemy(type, GameState.player.world);
      GameState.enemies.push(enemy);
    }
  },

  grantCoins(amount) {
    GameState.player.coins += amount;
    showFloatingChange(amount, 'coins');
  },

  grantGems(amount) {
    GameState.player.gems += amount;
    showFloatingChange(amount, 'gems');
  },

  levelUp() {
    GameState.player.level++;
    GameState.player.baseStats.ATK += 10;
    GameState.player.baseStats.HP += 20;
    GameState.player.baseStats.SPD += 1;
    computeDerivedStats();
    GameState.player.hp = GameState.player.maxHp;
  },

  clearSave() {
    if (confirm('Clear all save data?')) {
      localStorage.removeItem(CONFIG.SAVE_KEY);
      location.reload();
    }
  },

  grantSet(setId) {
    try {
      const p = GameState.player;
      if (!p) {
        console.error('GameState.player is undefined');
        showNotification('Error: Player not initialized', 'danger');
        return;
      }

      const setData = EQUIPMENT_SETS[setId];
      if (!setData) {
        console.error('Set not found:', setId);
        showNotification(`Unknown set: ${setId}`, 'danger');
        return;
      }

      console.log('Granting set:', setId, setData);

      // Initialize equipment and inventory if needed
      if (!p.equipment) p.equipment = {};
      if (!p.inventory) p.inventory = {};
      if (!GameState.itemIdCounter) GameState.itemIdCounter = 1000;

      // Clear current equipment and move to inventory if there's space
      Object.keys(p.equipment).forEach(slot => {
        const item = p.equipment[slot];
        if (item) {
          // Find first empty slot in inventory
          let placed = false;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (p.inventory[i] == null) {
              p.inventory[i] = item;
              placed = true;
              break;
            }
          }
          // If inventory is full, just discard the old item
          if (!placed) {
            console.log('Inventory full, discarding old item:', item.name);
          }
        }
        p.equipment[slot] = null;
      });

      // Grant all items from the set at mythic rarity with max stats
      if (!setData.items) {
        console.error('Set has no items:', setId);
        showNotification('Error: Set has no items', 'danger');
        return;
      }

      const mythicRanges = RARITY_RANGES.mythic;

      Object.keys(setData.items).forEach(itemKey => {
        const itemTemplate = setData.items[itemKey];
        if (!itemTemplate) {
          console.error('Item template is undefined for key:', itemKey);
          return;
        }

        const slot = itemTemplate.slot;

        // Determine base attribute based on slot (matching generateEquipment)
        let baseAttrName;
        if (slot === 'helmet') baseAttrName = 'ATK';
        else if (slot === 'chestplate') baseAttrName = 'HP';
        else if (slot === 'leggings') baseAttrName = 'HP';
        else if (slot === 'boots') baseAttrName = 'SPD';
        else if (slot === 'ring') baseAttrName = 'DMG%';
        else if (slot === 'weapon') baseAttrName = 'ATK';

        // Create item with full structure matching generateEquipment
        const item = {
          id: `item_${GameState.itemIdCounter++}`,
          type: 'equipment',
          slot: slot,
          name: itemTemplate.name,
          icon: itemTemplate.icon,
          rarity: 'mythic',
          level: 1,
          stars: 0,
          setId: setId,
          setName: setData.name,
          element: setData.element,
          baseAttribute: {
            name: baseAttrName,
            value: mythicRanges[baseAttrName][1] // Max value for mythic
          },
          affixes: [
            {
              name: 'ATK%',
              value: mythicRanges['ATK%'][1], // 35 (max)
              locked: false, // Unlocked since we're giving them for testing
              unlockLevel: 10
            },
            {
              name: 'DMG%',
              value: mythicRanges['DMG%'][1], // 100 (max)
              locked: false,
              unlockLevel: 25
            },
            {
              name: 'Crit Rate',
              value: mythicRanges['Crit Rate'][1], // 35 (max)
              locked: false,
              unlockLevel: 50
            },
            {
              name: 'Crit Damage',
              value: mythicRanges['Crit Damage'][1], // 250 (max)
              locked: false,
              unlockLevel: 75
            }
          ],
          buyPrice: 0,
          sellPrice: 0,
          createdAtWorld: p.world || 1
        };

        // Set weapon properties if it's a weapon
        if (itemTemplate.isWeapon) {
          item.isWeapon = true;
          item.weaponMultiplier = itemTemplate.multiplier || 1.0;
        }

        console.log('Equipping item:', item);

        // Equip the item
        p.equipment[slot] = item;
      });

      // Recompute stats
      computeDerivedStats();
      renderInventory();
      renderPlayerStats();

      showNotification(`‚ú® Granted full ${setData.name} set!`, 'success');
    } catch (error) {
      console.error('Error in grantSet:', error);
      showNotification(`Error: ${error.message}`, 'danger');
    }
  }
};

function updateDebugPanel() {
  const info = document.getElementById('debug-info');
  info.innerHTML = `
    <div style="font-size: 10px; margin-bottom: 8px;">
      Seed: ${CONFIG.AUTO_ATTACK_SEED || 'random'}<br>
      Enemies: ${GameState.enemies.length}<br>
      Wave: ${Math.floor(GameState.waveTimer)}s / ${CONFIG.WAVE_INTERVAL_SEC}s<br>
      ATK Interval: ${getAttackInterval().toFixed(2)}s<br>
      Luck: ${GameState.player.luck}
    </div>
  `;
}

// ========== Initialization ==========

// Clean up invalid setIds from equipment (for old save data compatibility)
function cleanupInvalidSetIds() {
  cleanupInvalidEquipment();
}

function init() {
  try {
    GameState.rng = new RNG(CONFIG.AUTO_ATTACK_SEED);

    const loaded = loadGame();
    if (!loaded) {
      GameState.player = createPlayer();
      GameState.shop = createShop();
      GameState.worldProgress = createWorldProgress();
      refreshShop();
    }

    // Clean up any invalid setIds from old save data
    cleanupInvalidSetIds();

    computeDerivedStats();
    renderUI();
    renderInventory();
    renderPlayerStats();
    renderShop();
    updateWorldProgress();

    setInterval(gameTick, CONFIG.TICK_INTERVAL_MS);
    setInterval(uiTick, CONFIG.UI_UPDATE_MS);
    if (CONFIG.DEV_MODE) {
      setInterval(updateDebugPanel, 500);
    }

    spawnWave();
  } catch (error) {
    console.error('Fatal error during initialization:', error);
    alert('Game failed to initialize. Check console for details. Error: ' + error.message);
    // Try to clear save and reload
    if (confirm('Would you like to clear your save data and restart?')) {
      localStorage.removeItem(CONFIG.SAVE_KEY);
      location.reload();
    }
  }
}

// ========== Event Listeners ==========
document.addEventListener('DOMContentLoaded', init);

document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'd') {
    e.preventDefault();
    const panel = document.getElementById('debug-panel');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
  }

  if (e.key === 'Escape') {
    hideTooltip();
    document.querySelectorAll('.overlay').forEach(overlay => {
      overlay.setAttribute('aria-hidden', 'true');
    });
    // Close custom modal
    const modal = document.getElementById('reset-modal');
    if (modal) {
      modal.setAttribute('aria-hidden', 'true');
    }
  }
});

document.getElementById('btn-challenge-boss').addEventListener('click', challengeBoss);

document.getElementById('btn-manual-refresh').addEventListener('click', () => {
  if (Date.now() >= GameState.shop.manualCooldownEndTs) {
    refreshShop();
    GameState.shop.manualCooldownEndTs = Date.now() + CONFIG.SHOP_MANUAL_COOLDOWN_SEC * 1000;
    renderShop();
  }
});

document.getElementById('btn-reset-progress').addEventListener('click', () => {
  const modal = document.getElementById('reset-modal');
  modal.setAttribute('aria-hidden', 'false');
});

document.getElementById('modal-cancel').addEventListener('click', () => {
  const modal = document.getElementById('reset-modal');
  modal.setAttribute('aria-hidden', 'true');
});

document.getElementById('modal-confirm').addEventListener('click', () => {
  localStorage.removeItem(CONFIG.SAVE_KEY);
  location.reload();
});

// Close modal when clicking outside
document.getElementById('reset-modal').addEventListener('click', (e) => {
  if (e.target.id === 'reset-modal') {
    e.target.setAttribute('aria-hidden', 'true');
  }
});

document.addEventListener('click', (e) => {
  // Handle buy shop button clicks
  if (e.target.classList.contains('buy-shop-btn')) {
    const itemId = e.target.getAttribute('data-item-id');
    if (itemId) {
      buyShopItem(itemId);
    }
    return;
  }

  // Close tooltip when clicking outside
  if (!e.target.closest('.inv-slot') &&
      !e.target.closest('.equip-slot') &&
      !e.target.closest('.shop-item') &&
      !e.target.closest('.effect-icon') &&
      !e.target.closest('.tooltip')) {
    hideTooltip();
  }
});

document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.enemy') || e.target.closest('.inv-slot') || e.target.closest('.equip-slot')) {
    e.preventDefault();
  }
});

/* --- Smooth per-frame enemy renderer (added by assistant) --- */
if (!window.GameState) window.GameState = window.GameState || {};
if (!window.CONFIG) window.CONFIG = window.CONFIG || {};
// Fallback tick interval ms if CONFIG not defined
if (!CONFIG.TICK_INTERVAL_MS) CONFIG.TICK_INTERVAL_MS = 200;

GameState.lastPhysicsTs = GameState.lastPhysicsTs || performance.now();

function renderEnemiesPerFrame(){
  requestAnimationFrame(renderEnemiesPerFrame);
  const now = performance.now();
  const alpha = Math.min(1, (now - (GameState.lastPhysicsTs || now)) / CONFIG.TICK_INTERVAL_MS);

  GameState.enemies = GameState.enemies || [];
  GameState.enemies.forEach(enemy => {
    const px = (enemy.prevX !== undefined ? enemy.prevX : enemy.position.x);
    const py = (enemy.prevY !== undefined ? enemy.prevY : enemy.position.y);
    const rx = px + (enemy.position.x - px) * alpha;
    const ry = py + (enemy.position.y - py) * alpha;

    let el =
      document.querySelector(`[data-enemy-id="${enemy.id}"]`) ||
      document.querySelector(`[data-boss-id="${enemy.id}"]`) ||
      document.querySelector(`[data-entity-id="${enemy.id}"]`);
    if (el) {
      el.style.transform = `translate(${rx}px, ${ry}px)`;
      const hpFill = el.querySelector('.enemy-hp-fill');
      if (hpFill && enemy.maxHp) {
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
        hpFill.style.width = `${hpPct}%`;
      }
    }
  });
}

// start the per-frame renderer after DOM ready or immediately if already ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(renderEnemiesPerFrame));
} else {
  requestAnimationFrame(renderEnemiesPerFrame);
}
/* --- end smooth renderer --- */

</script>
</body>
</html>