<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Solo Leveling</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --color-common: #9e9e9e;
      --color-uncommon: #4caf50;
      --color-rare: #2196f3;
      --color-epic: #9c27b0;
      --color-legendary: #ff9800;
      --color-mythic: #f44336;
      --color-divine: #dc2367;
      --bg-primary : #1a1410;
      --bg-secondary : #2a1f1a;
      --bg-tertiary : #3a2f2a;
      --accent-gold : #d4af37;
      --accent-gold-bright : #f4cf57;
      --accent-copper : #b87333;
      --text-primary : #f5e6d3;
      --text-secondary : #c5b5a3;
      --text-dim : #8a7a6a;
      --text-bonus : #4fc3f7;
      --border-radius : 8px;
      --border-color: #444;
      --shadow-sm : 0 2px 4px rgba(0,0,0,0.3);
      --shadow-md : 0 4px 12px rgba(0,0,0,0.5);
      --shadow-lg : 0 8px 24px rgba(0,0,0,0.7);
      --font-display:'Cinzel', serif;
      --font-body:'Merriweather', serif;
    }

    body {
      font-family: "Crimson Text", Georgia, "Times New Roman", serif;
      background:linear-gradient(135deg,#1a1410 0%,#2a1f1a 50%,#1a1410 100%);
      background-attachment:fixed;
      color: var(--text-primary);
      overflow: hidden;
      touch-action: pan-y;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #game-root {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    #hud {
      background: var(--bg-secondary);
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      padding: 8px 12px;
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      gap: 36px;
      border-bottom: 2px solid var(--border-color);
      z-index: 100;
    }

    #resources {
      display: flex;
      gap: 12px;
      align-items: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    #coins::before { content: 'ðŸ’° '; }
    #gems::before { content: 'ðŸ’Ž '; }
    #world {
      background: var(--bg-tertiary);
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    #levelbar {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 100px;
    }

    #level {
      font-weight: bold;
      color: #ffd700;
      white-space: nowrap;
    }

    #expbar {
      flex: 1;
      height: 20px;
      background: #333;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      border: 1px solid #555;
    }

    #exp-fill {
      height: 100%;
      background:linear-gradient(90deg,var(--accent-copper) 0%,var(--accent-gold) 100%);
      width: 0%;
      transition: width 0.3s ease;
      box-shadow:0 0 8px var(--accent-gold);
    }

    #exp-text {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
      z-index: 1;
    }

    #btn-challenge-world {
      padding:8px 16px;
      background:linear-gradient(135deg,#8b0000 0%,#dc143c 100%);
      border:2px solid #ff6347;
      border-radius:var(--border-radius);
      color:white;
      font-family:var(--font-display);
      font-weight:600;
      font-size:12px;
      cursor:pointer;
      box-shadow:var(--shadow-sm);
      transition:all 0.2s;
      text-transform:uppercase;
      margin-top: 8px;
      width: 100%;
    }

    #btn-challenge-world:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    #btn-challenge-world:active:not(:disabled) {
      transform: scale(0.95);
    }

    /* Challenge Overlay - top center on screen */
    #challenge-overlay {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 600;
      pointer-events: none;
    }

    #challenge-content {
      background: rgba(26, 20, 16, 0.95);
      border: 3px solid var(--accent-gold);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
      min-width: 300px;
    }

    #challenge-description {
      font-size: 14px;
      color: var(--text-primary);
      line-height: 1.6;
      white-space: pre-line;
      margin-bottom: 12px;
      font-family: var(--font-body);
    }

    #challenge-description .wave-title {
      font-size: 16px;
      font-weight: bold;
      color: var(--accent-gold);
      font-family: var(--font-display);
      display: block;
      margin-bottom: 8px;
    }

    #challenge-timer {
      font-size: 16px;
      font-weight: bold;
      font-family: var(--font-display);
      color: #ffd700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
      padding: 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      display: inline-block;
    }

    #stage {
      flex: 1;
      position: relative;
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      overflow: hidden;
      touch-action: none;
    }

    #player-container {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
    }

    #player {
      width: 56px;
      height: 56px;
      background: radial-gradient(circle, #4fc3f7, #0288d1);
      border-radius: 50%;
      border: 3px solid #01579b;
      box-shadow: 0 0 20px rgba(79, 195, 247, 0.6);
      position: relative;
      margin: 0 auto;
    }

    #attack-range-circle {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 2px solid;
      pointer-events: none;
      opacity: 0.3;
      z-index: 45;
      display: none;
    }

    #attack-range-circle.visible {
      display: block;
    }

    #player-hpbar {
      position: absolute;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      border: 2px solid #555;
      overflow: hidden;
    }

    #player-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #e74c3c, #c0392b);
      width: 100%;
      transition: width 0.2s ease;
    }

    #player-hp-text {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
    }

    #equip-ring {
      position: absolute;
      left: 50%;
      top: 28px;
      transform: translate(-50%, -50%);
      width: 160px;
      height: 160px;
      pointer-events: none;
    }

    .equipped-icon {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    #enemy-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .enemy {
      position: absolute;
      border-radius: 50%;
      border: 2px solid;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: transform 0.1s;
      cursor: pointer;
      pointer-events: auto;
      touch-action: manipulation;
    }

    .enemy:active {
      transform: scale(0.9);
    }

    .enemy.small {
      width: 32px;
      height: 32px;
      background: #9e9e9e;
      border-color: #757575;
      font-size: 14px;
    }

    .enemy.normal {
      width: 40px;
      height: 40px;
      background: #795548;
      border-color: #5d4037;
    }

    .enemy.big {
      width: 56px;
      height: 56px;
      background: #ff5722;
      border-color: #d84315;
      font-size: 24px;
    }

    .enemy.elite {
      width: 64px;
      height: 64px;
      background: #9c27b0;
      border-color: #7b1fa2;
      font-size: 28px;
      box-shadow: 0 0 20px rgba(156, 39, 176, 0.8);
    }

    .enemy.boss {
      width: 80px;
      height: 80px;
      background: #f44336;
      border-color: #c62828;
      font-size: 36px;
      box-shadow: 0 0 30px rgba(244, 67, 54, 0.9);
      animation: boss-pulse 1s infinite;
    }

    /* New Enemy Types - Sized by Category */
    
    /* Small Category */
    .enemy.assassin {
      width: 32px;
      height: 32px;
      background: #263238;
      border-color: #000;
      font-size: 14px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
    }

    /* Normal Category */
    .enemy.tank {
      width: 40px;
      height: 40px;
      background: #546e7a;
      border-color: #37474f;
      font-size: 18px;
      box-shadow: 0 0 15px rgba(100, 150, 255, 0.6);
    }

    .enemy.ranger {
      width: 40px;
      height: 40px;
      background: #558b2f;
      border-color: #33691e;
      font-size: 18px;
    }

    .enemy.mage {
      width: 40px;
      height: 40px;
      background: #4a148c;
      border-color: #311b92;
      font-size: 18px;
      box-shadow: 0 0 15px rgba(156, 39, 176, 0.8);
      animation: mage-glow 2s infinite;
    }

    /* Big Category */
    .enemy.necromancer {
      width: 56px;
      height: 56px;
      background: #1b5e20;
      border-color: #0d3d0f;
      font-size: 24px;
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
    }

    /* Elite Category */
    .enemy.berserker {
      width: 64px;
      height: 64px;
      background: #bf360c;
      border-color: #870000;
      font-size: 28px;
      box-shadow: 0 0 12px rgba(255, 87, 34, 0.7);
    }

    .enemy.paladin {
      width: 64px;
      height: 64px;
      background: linear-gradient(135deg, #ffd700 0%, #ffecb3 100%);
      border-color: #f57f17;
      font-size: 28px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      animation: holy-shine 1.5s infinite;
    }

    .enemy.demon {
      width: 64px;
      height: 64px;
      background: #b71c1c;
      border-color: #880e4f;
      font-size: 28px;
      box-shadow: 0 0 25px rgba(183, 28, 28, 0.9);
      animation: demon-flicker 1.2s infinite;
    }

    /* Boss Category */
    .enemy.archboss {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, #4a148c 0%, #880e4f 50%, #b71c1c 100%);
      border-color: #000;
      font-size: 36px;
      box-shadow: 0 0 40px rgba(183, 28, 28, 1);
      animation: archboss-pulse 1s infinite;
    }

    @keyframes mage-glow {
      0%, 100% {
        box-shadow: 0 0 15px rgba(156, 39, 176, 0.8);
      }
      50% {
        box-shadow: 0 0 25px rgba(156, 39, 176, 1);
      }
    }

    @keyframes holy-shine {
      0%, 100% {
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      }
      50% {
        box-shadow: 0 0 30px rgba(255, 215, 0, 1);
        filter: brightness(1.2);
      }
    }

    @keyframes demon-flicker {
      0%, 100% {
        box-shadow: 0 0 25px rgba(183, 28, 28, 0.9);
        filter: brightness(1);
      }
      25% {
        box-shadow: 0 0 35px rgba(183, 28, 28, 1);
        filter: brightness(1.3);
      }
      75% {
        box-shadow: 0 0 20px rgba(183, 28, 28, 0.8);
        filter: brightness(0.9);
      }
    }

    @keyframes archboss-pulse {
      0%, 100% {
        box-shadow: 0 0 40px rgba(183, 28, 28, 1);
      }
      50% {
        box-shadow: 0 0 60px rgba(183, 28, 28, 1);
        filter: brightness(1.3);
      }
    }

    @keyframes boss-pulse {
      0%, 100% {
        box-shadow: 0 0 30px rgba(244, 67, 54, 0.9);
        filter: brightness(1);
      }
      50% {
        box-shadow: 0 0 45px rgba(244, 67, 54, 1);
        filter: brightness(1.2);
      }
    }

    .enemy-hpbar {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 6px;
      background: #333;
      border-radius: 3px;
      overflow: hidden;
      border: 1px solid #555;
    }

    .enemy-hp-fill {
      height: 100%;
      background: #4caf50;
      width: 100%;
      transition: width 0.2s ease;
    }

    #drop-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .drop-item {
      position: absolute;
      font-size: 20px;
      animation: dropFloat 2s ease-out forwards;
      pointer-events: none;
    }

    @keyframes dropFloat {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateY(-60px) scale(1.5);
      }
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 16px;
      display: none;
    }

    .overlay[aria-hidden="false"] {
      display: block;
    }

    .overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      position: sticky;
      top: 0;
      background: var(--bg-primary);
      padding: 8px;
      border-radius:var(--border-radius);
      z-index: 10;
    }

    .overlay-title {
      font-size: 20px;
      font-weight: bold;
      color: #ffd700;
    }

    .btn, .btn-refresh, .tooltip-btn, .nav-btn {
      padding:14px 20px;
      background:linear-gradient(135deg,var(--accent-copper) 0%,var(--accent-gold) 100%);
      border:2px solid var(--accent-gold-bright);
      border-radius:var(--border-radius);
      color:var(--bg-primary);
      font-family:var(--font-display);
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      gap: 8px;
      box-shadow:var(--shadow-md);
      transition:all 0.2s;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    .btn:hover, .btn-refresh:hover {
      transform:translateY(-2px);
      box-shadow:0 6px 16px rgba(206, 196, 165, 0.4);
    }
    .btn-close {
      background: #e74c3c;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      touch-action: manipulation;
    }

    .btn-close:active {
      transform: scale(0.95);
    }

    .custom-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .custom-modal[aria-hidden="false"] {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-content {
      background: var(--bg-secondary);
      border: 3px solid var(--accent-gold);
      border-radius: var(--border-radius);
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: var(--shadow-lg);
      transform: scale(0.9);
      transition: transform 0.3s;
    }

    .custom-modal[aria-hidden="false"] .modal-content {
      transform: scale(1);
    }

    .modal-header {
      font-size: 20px;
      font-weight: bold;
      color: var(--accent-gold);
      margin-bottom: 16px;
      text-align: center;
      font-family: var(--font-display);
    }

    .modal-body {
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 20px;
      text-align: center;
      color: var(--text-primary);
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .modal-btn {
      padding: 10px 24px;
      border: none;
      border-radius: var(--border-radius);
      font-family: var(--font-display);
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .modal-btn-confirm {
      background: linear-gradient(135deg, #8b0000 0%, #dc143c 100%);
      color: white;
      border: 2px solid #ff6347;
    }

    .modal-btn-confirm:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(220, 20, 60, 0.5);
    }

    .modal-btn-cancel {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
    }

    .modal-btn-cancel:hover {
      background: var(--bg-secondary);
      border-color: var(--accent-gold);
    }

    .modal-btn:active {
      transform: scale(0.95);
    }

    .inventory-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 800px;
      margin: 0 auto;
    }

    @media (min-width: 768px) {
      .inventory-container {
        flex-direction: row;
      }
    }

    .inv-left-col {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .inv-player-label {
      font-size: 18px;
      font-weight: bold;
      color: #ffd700;
      text-align: center;
      margin-bottom: -4px;
    }

    .inv-player {
      width: 100px;
      height: 100px;
      background: radial-gradient(circle, #4fc3f7, #0288d1);
      border-radius: 50%;
      border: 4px solid #01579b;
      box-shadow: 0 0 30px rgba(79, 195, 247, 0.6);
    }

    .stats-box {
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      border:2px solid var(--accent-copper);
      border-radius:var(--border-radius);
      padding: 12px;
      width: 200px;
      margin-top: 8px;
    }

    .inv-resources {
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      border:2px solid var(--accent-gold);
      border-radius:var(--border-radius);
      padding: 12px;
      width: 200px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
    }

    .inv-resource-line {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
      position: relative;
    }

    .inv-resource-line:last-child {
      border-bottom: none;
    }

    .inv-resource-label {
      font-weight: bold;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .inv-resource-value {
      color: #ffd700;
      font-weight: bold;
    }

    .inv-active-effects {
      background:linear-gradient(135deg,rgba(58,47,42,0.6) 0%,rgba(42,31,26,0.6) 100%);
      border:2px solid var(--accent-gold);
      border-radius:var(--border-radius);
      padding: 12px;
      width: 200px;
    }

    .active-effects-icons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      min-height: 60px;
      align-items: center;
    }

    .effect-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 64px;
      padding: 8px;
      background: rgba(212, 175, 55, 0.1);
      border: 2px solid var(--accent-gold);
      border-radius: 8px;
      transition: background 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }

    @keyframes bounce-once {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .effect-icon.bouncing {
      animation: bounce-once 0.3s ease;
    }

    .effect-icon:hover {
      box-shadow: 0 4px 8px rgba(212, 175, 55, 0.4);
      background: rgba(212, 175, 55, 0.2);
    }

    .effect-icon-image {
      font-size: 32px;
      margin-bottom: 4px;
    }

    .effect-icon-timer {
      font-size: 10px;
      color: var(--text-secondary);
      font-weight: bold;
    }

    .no-effects-message {
      color: #999;
      text-align: center;
      font-size: 12px;
      font-style: italic;
    }

    .stat-line {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .stat-line:last-child {
      border-bottom: none;
    }

    .stat-label {
      font-weight: bold;
      color: var(--text-secondary);
    }

    .stat-value {
      color: #ffd700;
      font-weight: bold;
    }

    .inv-right-col {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .inv-title {
      font-size: 24px;
      text-align: center;
      color: #ffd700;
      margin-bottom: 8px;
    }

    .equip-ring {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin: 0 auto;
      max-width: 600px;
      padding: 20px;
    }

    .equip-slot {
      aspect-ratio: 1;
      border: 3px solid var(--border-color);
      border-radius: 50%;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      touch-action: manipulation;
    }

    .equip-slot.dragging {
      opacity: 0.5;
    }

    .equip-slot.drag-over {
      border-color: #ffd700;
      background: var(--bg-secondary);
      transform: scale(1.05);
    }

    .equip-slot:hover {
      border-color: #ffd700;
      transform: scale(1.05);
    }

    .equip-slot.filled {
      background: var(--bg-secondary);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }

    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(4, 80px);
      gap: 8px;
      max-width: 400px;
      margin: 0 auto;
    }

    .inv-slot {
      width: 80px;
      height: 80px;
      aspect-ratio: 1;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      touch-action: manipulation;
    }

    .inv-slot.dragging {
      opacity: 0.5;
    }

    .inv-slot.drag-over {
      border-color: #ffd700;
      background: var(--bg-secondary);
    }

    .inv-slot:hover {
      border-color: #ffd700;
      transform: scale(1.05);
    }

    .inv-slot.filled {
      background: var(--bg-secondary);
    }

    .item-icon {
      font-size: inherit;
      pointer-events: none;
    }

    .item-level {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
      color: #ffd700;
      pointer-events: none;
    }

    .item-stars {
      position: absolute;
      top: 2px;
      left: 4px;
      font-size: 10px;
      color: #ffd700;
      pointer-events: none;
    }

    .tooltip {
      position: fixed;
      background: var(--bg-secondary);
      border: 2px solid;
      border-radius: 8px;
      padding: 12px;
      max-width: 300px;
      z-index: 2000;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    /* Mobile tooltip adjustments */
    @media (max-width: 768px) {
      .tooltip {
        max-width: 85vw;
        padding: 8px;
        font-size: 11px;
        max-height: 70vh;
        overflow-y: auto;
      }

      .tooltip-header {
        font-size: 13px;
      }

      .tooltip-level {
        font-size: 11px;
      }

      .base-stat-value {
        font-size: 20px;
      }

      .base-stat-name {
        font-size: 10px;
      }

      .tooltip-content {
        font-size: 11px;
        line-height: 1.4;
      }

      .tooltip-attr {
        padding: 3px;
        margin: 3px 0;
      }

      .tooltip-btn {
        padding: 6px 8px;
        font-size: 11px;
        min-width: 60px;
      }

      .tooltip-actions {
        margin-top: 8px;
        gap: 4px;
      }
    }

    .tooltip[aria-hidden="false"] {
      opacity: 1;
      pointer-events: auto;
    }

    .tooltip-header-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
      gap: 16px;
    }

    .tooltip-header-left {
      flex: 1;
    }

    .tooltip-header {
      font-weight: bold;
      font-size: 16px;
    }

    .tooltip-level {
      font-size: 13px;
      color: var(--text-secondary);
      margin-top: 2px;
    }

    .tooltip-base-stat {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 60px;
    }

    .base-stat-name {
      font-size: 12px;
      font-weight: bold;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .base-stat-value {
      font-size: 28px;
      font-weight: bold;
      color: var(--text-primary);
      line-height: 1;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .tooltip-content {
      font-size: 13px;
      line-height: 1.5;
    }

    .tooltip-attr {
      margin: 4px 0;
      padding: 4px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    .tooltip-attr.locked {
      opacity: 0.6;
    }

    .tooltip-attr.locked::before {
      content: 'ðŸ”’ ';
    }

    .tooltip-actions {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tooltip-btn {
      flex: 1;
      min-width: 70px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      cursor: pointer;
      touch-action: manipulation;
    }

    .tooltip-btn.primary {
      background: #4caf50;
      color: white;
    }

    .tooltip-btn.secondary {
      background: #2196f3;
      color: white;
    }

    .tooltip-btn.danger {
      background: #e74c3c;
      color: white;
    }

    .tooltip-btn:active {
      transform: scale(0.95);
    }

    .reroll-btn:hover {
      opacity: 0.8;
      transform: scale(1.05);
      transition: all 0.2s;
    }

    .reroll-btn:active {
      transform: scale(0.95);
    }

    .shop-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .shop-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 8px;
    }

    .shop-timer {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .btn-refresh {
      background: #2196f3;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      touch-action: manipulation;
    }

    .btn-refresh:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .btn-refresh:active:not(:disabled) {
      transform: scale(0.95);
    }

    .shop-section {
      margin-bottom: 24px;
    }

    .shop-section h3 {
      margin-bottom: 12px;
      color: #ffd700;
      font-size: 18px;
    }

    .shop-resources {
      display: flex;
      gap: 24px;
      justify-content: center;
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: var(--border-radius);
      margin-bottom: 16px;
      font-size: 18px;
      font-weight: bold;
    }

    .shop-resource {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
    }

    .shop-resource span {
      color: #ffd700;
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
    }

    .shop-item {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
      touch-action: manipulation;
      position: relative;
    }

    .shop-item.sold-out {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }

    .shop-item.sold-out::after {
      content: 'SOLD OUT';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.9);
      color: white;
      padding: 6px 16px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 12px;
      letter-spacing: 1px;
    }

    .shop-item:hover {
      border-color: #ffd700;
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }

    .shop-item:active {
      transform: translateY(-2px);
    }

    .shop-item-icon {
      text-align: center;
      font-size: 48px;
      margin-bottom: 8px;
    }

    .shop-item-name {
      text-align: center;
      font-weight: bold;
      font-size: 13px;
      margin-bottom: 4px;
      min-height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shop-item-price {
      text-align: center;
      color: #ffd700;
      font-weight: bold;
      font-size: 14px;
    }

    .stats-container {
      max-width: 600px;
      margin: 0 auto;
    }

    .stats-section {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .stats-section h3 {
      color: #ffd700;
      margin-bottom: 12px;
      font-size: 18px;
    }

    .effect-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .effect-item {
      background: var(--bg-tertiary);
      padding: 8px;
      border-radius: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .effect-name {
      font-weight: bold;
    }

    .effect-timer {
      color: var(--text-secondary);
      font-size: 13px;
    }

    .panel {
      position: fixed;
      top: 52px;
      right: 8px;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 8px 12px;
      width: auto;
      max-width: calc(100% - 16px);
      min-height: auto;
      max-height: fit-content;
      z-index: 500;
      display: none;
    }

    .panel.visible {
      display: block;
    }

    .panel h4 {
      color: #ffd700;
      margin-bottom: 4px;
      font-size: 18px;
    }

    .requirement {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 2px 0;
      font-size: 12px;
    }

    .requirement.met {
      color: #4caf50;
    }

    .requirement.not-met {
      color: #e74c3c;
    }

    .requirement::before {
      content: 'âœ“';
      font-weight: bold;
      width: 16px;
    }

    .requirement.not-met::before {
      content: 'âœ—';
    }

    #bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-secondary);
      border-top: 2px solid var(--border-color);
      display: flex;
      gap: 8px;
      justify-content: space-around;
      padding: 8px;
      z-index: 100;
    }

    .nav-btn {
      flex: 1;
      font-family:var(--font-display);
      font-weight:600;
      font-size:11px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      padding: 12px 8px;
      font-size: 12px;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      touch-action: manipulation;
    }

    .nav-btn:active {
      background: var(--bg-primary);
      transform: scale(0.95);
    }

    .nav-btn-icon {
      font-size: 20px;
    }

    #debug-panel {
      position: fixed;
      top: 50%;
      right: 8px;
      transform: translateY(-50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #ffd700;
      border-radius: 8px;
      padding: 12px;
      max-width: 250px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 9999;
      font-size: 11px;
    }

    #debug-panel h4 {
      color: #ffd700;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .debug-btn {
      width: 100%;
      margin: 4px 0;
      padding: 6px;
      background: #2196f3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      touch-action: manipulation;
    }

    .debug-btn:active {
      background: #1976d2;
    }

    #notification-container {
      position: fixed;
      top: 60px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 300px;
    }

    .notification {
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: var(--shadow-lg);
      animation: slideIn 0.3s ease-out;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      font-weight: 500;
    }

    .notification.info {
      border-color: #2196f3;
      background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(33, 150, 243, 0.05));
    }

    .notification.success {
      border-color: #4caf50;
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(76, 175, 80, 0.05));
    }

    .notification.warning {
      border-color: #ff9800;
      background: linear-gradient(135deg, rgba(255, 152, 0, 0.1), rgba(255, 152, 0, 0.05));
    }

    .notification.danger {
      border-color: #f44336;
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(244, 67, 54, 0.05));
    }

    .notification.legendary {
      border-color: #ffd700;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.1));
      animation: slideIn 0.3s ease-out, glow 2s ease-in-out infinite;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateX(400px);
      }
    }

    .rarity-common { border-color: var(--color-common) !important; }
    .rarity-uncommon { border-color: var(--color-uncommon) !important; }
    .rarity-rare { border-color: var(--color-rare) !important; }
    .rarity-epic { border-color: var(--color-epic) !important; }
    .rarity-legendary { border-color: var(--color-legendary) !important; }
    .rarity-mythic { border-color: var(--color-mythic) !important; }
    .rarity-divine { border-color: var(--color-divine) !important; }

    .text-common { color: var(--color-common); }
    .text-uncommon { color: var(--color-uncommon); }
    .text-rare { color: var(--color-rare); }
    .text-epic { color: var(--color-epic); }
    .text-legendary { color: var(--color-legendary); }
    .text-mythic { color: var(--color-mythic); }
    .text-divine { color: var(--color-divine); }

    /* Floating coin/gem popup */
    .floating-change {
      position: absolute;
      pointer-events: none;
      font-weight: 700;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(0);
      opacity: 1;
      transition: transform 800ms cubic-bezier(.22,.9,.3,1), opacity 800ms ease-out;
      z-index: 9999;
      text-shadow: 0 1px 0 rgba(0,0,0,0.3);
    }

    /* colors for positive / negative */
    .floating-change.positive { color: #2ecc71; } /* green */
    .floating-change.negative { color: #e74c3c; } /* red */
    @media (max-width: 480px) {
      #hud {
        font-size: 12px;
      }

      #challenge-content {
        padding: 16px 20px;
        min-width: 250px;
      }

      #challenge-description {
        font-size: 14px;
      }

      #challenge-timer {
        font-size: 24px;
      }

      .overlay {
        padding: 12px;
      }

      .shop-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
    }

    @media (min-width: 768px) {
      #debug-panel {
        right: 16px;
        max-width: 300px;
      }

      .panel {
        bottom: 16px;
        width: 400px;
      }
    }
    /* Death Screen */
    #death-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      pointer-events: none;
    }

    #death-screen.active {
      display: flex;
    }

    #death-message {
      font-family: var(--font-display);
      font-size: 48px;
      font-weight: bold;
      color: #e74c3c;
      text-shadow: 0 0 20px rgba(231, 76, 60, 0.8), 0 0 40px rgba(231, 76, 60, 0.5);
      margin-bottom: 20px;
      animation: pulse-death 1s ease-in-out infinite;
    }

    @keyframes pulse-death {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }

    #respawn-timer {
      font-family: var(--font-display);
      font-size: 24px;
      color: var(--text-primary);
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }

    /* Player flashing effect */
    #player.flashing {
      animation: flash-invincible 0.15s ease-in-out infinite;
    }

    @keyframes flash-invincible {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Respawn damage burst effect */
    .damage-burst {
      position: absolute;
      width: 600px;
      height: 600px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 253, 242, 0.6) 0%, rgba(255, 244, 225, 0.4) 30%, rgba(255, 177, 148, 0.2) 60%, transparent 100%);
      pointer-events: none;
      animation: burst-expand 0.8s ease-out forwards;
      z-index: 40;
    }

    @keyframes burst-expand {
      0% {
        transform: translate(-50%, -50%) scale(0.1);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 0;
      }
    }

    /* Challenge Failure Screen */
    #challenge-failure-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      pointer-events: none;
    }

    #challenge-failure-screen.active {
      display: flex;
    }

    #challenge-failure-message {
      font-family: var(--font-display);
      font-size: 56px;
      font-weight: bold;
      color: #ff4444;
      text-shadow: 0 0 30px rgba(255, 68, 68, 0.9), 0 0 60px rgba(255, 68, 68, 0.6);
      margin-bottom: 30px;
      animation: pulse-failure 1.2s ease-in-out infinite;
    }

    @keyframes pulse-failure {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.08); opacity: 0.7; }
    }

    #challenge-failure-info {
      font-family: var(--font-display);
      font-size: 28px;
      color: var(--accent-gold);
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
    }

    #challenge-failure-world {
      font-weight: bold;
      color: var(--accent-gold-bright);
    }

    @keyframes fire-pulse {
      0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
    }

    @keyframes wind-pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    #set-bonuses-display {
      display: none !important;
    }

/* Enchantment glint effect (Minecraft-style) */
.enchanted {
  position: relative;
  overflow: hidden;
}

.enchanted::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 30%,
    rgba(168, 85, 247, 0.4) 50%,
    transparent 70%
  );
  animation: enchant-glint 3s infinite;
  pointer-events: none;
  z-index: 1;
}

@keyframes enchant-glint {
  0% {
    transform: translate(-100%, -100%) rotate(45deg);
  }
  100% {
    transform: translate(100%, 100%) rotate(45deg);
  }
}

/* Enchantment text styling */
.enchantment-attr {
  color: #a855f7;
  padding: 4px 8px;
  margin: 2px 0;
  background: rgba(168, 85, 247, 0.1);
  border-left: 3px solid #a855f7;
  border-radius: 4px;
  font-size: 11px;
  line-height: 1.4;
  position: relative;
}

.enchantment-attr.locked {
  opacity: 0.5;
  background: rgba(168, 85, 247, 0.05);
}

.enchantment-attr.locked::after {
  content: 'ðŸ”’';
  margin-left: 6px;
  font-size: 10px;
}

/* Enchantment section in tooltip */
.enchantments-section {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 2px solid rgba(168, 85, 247, 0.3);
}

.enchantments-header {
  font-size: 12px;
  font-weight: 700;
  color: #a855f7;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Enchantment unlock/reroll buttons */
.enchant-btn {
  background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
  border: 2px solid #a855f7;
  color: white;
  padding: 6px 12px;
  margin: 3px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 10px;
  font-weight: 600;
  transition: all 0.2s;
  display: inline-block;
}

.enchant-btn:hover {
  background: linear-gradient(135deg, #6d28d9 0%, #9333ea 100%);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(168, 85, 247, 0.4);
}

.enchant-btn:active {
  transform: translateY(0);
}

.enchant-btn.disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background: #666;
  border-color: #888;
}

.enchant-btn.disabled:hover {
  transform: none;
  box-shadow: none;
}

/* Small glint for inventory slots */
.inv-slot.enchanted::after {
  content: 'âœ¨';
  position: absolute;
  top: 2px;
  right: 2px;
  font-size: 12px;
  text-shadow: 0 0 4px #a855f7;
  animation: sparkle 2s infinite;
  z-index: 2;
}

.equip-slot.enchanted::after {
  content: 'âœ¨';
  position: absolute;
  top: 2px;
  right: 2px;
  font-size: 12px;
  text-shadow: 0 0 4px #a855f7;
  animation: sparkle 2s infinite;
  z-index: 2;
}

@keyframes sparkle {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.7;
    transform: scale(1.2);
  }
}

/* Player equipment ring enchantment glow */
#player.enchanted {
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.8), 0 0 15px rgba(168, 85, 247, 0.6) inset;
}

</style>
</head>
<body>
  <div id="game-root">
    <header id="hud">
      <div id="resources">
        <span id="coins">0</span>
        <span id="gems">0</span>
      </div>
      <div id="levelbar">
        <span id="level">Lv 1</span>
        <div id="expbar">
          <div id="exp-fill"></div>
          <div id="exp-text">0 / 100</div>
        </div>
      </div>
      <div id="world">World 1</div>
    </header>

    <main id="stage">
      <div id="attack-range-circle"></div>
      <div id="player-container">
        <div id="player" aria-label="player" role="img"></div>
        <div id="player-hpbar">
          <div id="player-hp-fill"></div>
          <div id="player-hp-text">100 / 100</div>
        </div>
        <div id="equip-ring"></div>
      </div>

      <div id="enemy-layer"></div>
      <div id="drop-layer"></div>
      <div id="death-screen">
        <div id="death-message">You Died!</div>
        <div id="respawn-timer">Respawning in 5 seconds...</div>
      </div>
      <div id="challenge-failure-screen">
        <div id="challenge-failure-message">Challenge Failed!</div>
        <div id="challenge-failure-info">Return to World <span id="challenge-failure-world">1</span></div>
      </div>
    </main>

    <section id="overlays">
      <div id="inventory-overlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Inventory">
        <div class="overlay-header">
          <h2 class="overlay-title">Inventory</h2>
          <button class="btn-close" onclick="closeOverlay('inventory-overlay')">âœ• Close</button>
        </div>
        <div class="inventory-container">
          <div class="inv-left-col">
            <div class="inv-player-label">Player</div>
            <div id="inv-player" class="inv-player" role="img" aria-label="Player"></div>
            <div id="player-stats-box" class="stats-box" role="region" aria-label="Player stats" tabindex="0" aria-live="polite">
              <div class="stat-line"><span class="stat-label">ATK</span><span class="stat-value" id="stat-atk">0</span></div>
              <div class="stat-line"><span class="stat-label">HP</span><span class="stat-value" id="stat-hp">0</span></div>
              <div class="stat-line"><span class="stat-label">SPD</span><span class="stat-value" id="stat-spd">0</span></div>
              <div class="stat-line"><span class="stat-label">DMG%</span><span class="stat-value" id="stat-dmg">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit Rate</span><span class="stat-value" id="stat-crit-rate">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit DMG</span><span class="stat-value" id="stat-crit-dmg">0%</span></div>
            </div>
            <div id="inv-resources" class="inv-resources">
              <div class="inv-resource-line">
                <span class="inv-resource-label">ðŸ’° Coins</span>
                <span class="inv-resource-value" id="inv-coins">0</span>
              </div>
              <div class="inv-resource-line">
                <span class="inv-resource-label">ðŸ’Ž Gems</span>
                <span class="inv-resource-value" id="inv-gems">0</span>
              </div>
            </div>

            <div id="inv-active-effects" class="inv-active-effects">
              <div id="active-effects-icons" class="active-effects-icons">
                <!-- Effects will be rendered here as icons -->
              </div>
            </div>

            <!-- Set Bonuses Display -->
            <div id="set-bonuses-display" style="margin-top: 12px;"></div>
          </div>

          <div class="inv-right-col">
            <div id="inv-equip-ring" class="equip-ring" aria-label="Equipment slots">
              <div class="equip-slot" data-slot="helmet" id="equip-helmet" aria-label="Helmet" tabindex="0"></div>
              <div class="equip-slot" data-slot="leggings" id="equip-leggings" aria-label="Leggings" tabindex="0"></div>
              <div class="equip-slot" data-slot="ring" id="equip-ring-slot" aria-label="Ring relic" tabindex="0"></div>

              <div class="equip-slot" data-slot="chestplate" id="equip-chestplate" aria-label="Chestplate" tabindex="0"></div>
              <div class="equip-slot" data-slot="boots" id="equip-boots" aria-label="Boots" tabindex="0"></div>
              <div class="equip-slot" data-slot="weapon" id="equip-weapon" aria-label="Weapon" tabindex="0"></div>
            </div>

            <div id="inventory-grid" class="inventory-grid" role="list" aria-label="Inventory slots">
              <div class="inv-slot" data-index="0" role="listitem" aria-label="Inventory slot 1" tabindex="0"></div>
              <div class="inv-slot" data-index="1" role="listitem" aria-label="Inventory slot 2" tabindex="0"></div>
              <div class="inv-slot" data-index="2" role="listitem" aria-label="Inventory slot 3" tabindex="0"></div>
              <div class="inv-slot" data-index="3" role="listitem" aria-label="Inventory slot 4" tabindex="0"></div>

              <div class="inv-slot" data-index="4" role="listitem" aria-label="Inventory slot 5" tabindex="0"></div>
              <div class="inv-slot" data-index="5" role="listitem" aria-label="Inventory slot 6" tabindex="0"></div>
              <div class="inv-slot" data-index="6" role="listitem" aria-label="Inventory slot 7" tabindex="0"></div>
              <div class="inv-slot" data-index="7" role="listitem" aria-label="Inventory slot 8" tabindex="0"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="shop-overlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Shop">
        <div class="overlay-header">
          <h2 class="overlay-title">Shop</h2>
          <button class="btn-close" onclick="closeOverlay('shop-overlay')">âœ• Close</button>
        </div>
        <div class="shop-resources">
          <div class="shop-resource">ðŸ’° <span id="shop-coins">0</span></div>
          <div class="shop-resource">ðŸ’Ž <span id="shop-gems">0</span></div>
        </div>
        <div class="shop-container">
          <div class="shop-controls">
            <div class="shop-timer" id="shop-timer">Next refresh in: 60s</div>
            <button class="btn-refresh" id="btn-manual-refresh">Refresh (5s cooldown)</button>
          </div>

          <div class="shop-section">
            <h3>Equipment</h3>
            <div class="shop-grid" id="shop-equipment-grid"></div>
          </div>

          <div class="shop-section">
            <h3>Consumables</h3>
            <div class="shop-grid" id="shop-consumables-grid"></div>
          </div>
        </div>
      </div>

      <div id="stats-overlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Stats">
        <div class="overlay-header">
          <h2 class="overlay-title">Stats</h2>
          <button class="btn-close" onclick="closeOverlay('stats-overlay')">âœ• Close</button>
        </div>
        <div class="stats-container">
          <div class="stats-section">
            <h3>Combat Stats</h3>
            <div id="detailed-stats" style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
              <div class="stat-line"><span class="stat-label">ATK</span><span class="stat-value" id="stat-atk-detail">0</span></div>
              <div class="stat-line"><span class="stat-label">HP</span><span class="stat-value" id="stat-hp-detail">0</span></div>
              <div class="stat-line"><span class="stat-label">SPD</span><span class="stat-value" id="stat-spd-detail">0</span></div>
              <div class="stat-line"><span class="stat-label">DMG%</span><span class="stat-value" id="stat-dmg-detail">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit Rate</span><span class="stat-value" id="stat-crit-rate-detail">0%</span></div>
              <div class="stat-line"><span class="stat-label">Crit Dmg</span><span class="stat-value" id="stat-crit-dmg-detail">0%</span></div>
            </div>

            <h3>Player Statistics</h3>
            <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px;">
              <div class="stat-line"><span class="stat-label">Total Kills</span><span class="stat-value" id="stat-total-kills">0</span></div>
              <div class="stat-line"><span class="stat-label">Bosses Defeated</span><span class="stat-value" id="stat-bosses">0</span></div>
              <div class="stat-line"><span class="stat-label">Worlds Completed</span><span class="stat-value" id="stat-worlds">0</span></div>
              <div class="stat-line"><span class="stat-label">Deaths</span><span class="stat-value" id="stat-deaths">0</span></div>
              <div class="stat-line"><span class="stat-label">Critical Hits</span><span class="stat-value" id="stat-crits">0</span></div>
              <div class="stat-line"><span class="stat-label">Damage Dealt</span><span class="stat-value" id="stat-dmg-dealt">0</span></div>
              <div class="stat-line"><span class="stat-label">Damage Taken</span><span class="stat-value" id="stat-dmg-taken">0</span></div>
              <div class="stat-line"><span class="stat-label">Highest Damage Dealt</span><span class="stat-value" id="stat-highest-dmg-dealt">0</span></div>
              <div class="stat-line"><span class="stat-label">Highest Damage Taken</span><span class="stat-value" id="stat-highest-dmg-taken">0</span></div>
              <div class="stat-line"><span class="stat-label">Coins Earned</span><span class="stat-value" id="stat-coins-earned">0</span></div>
              <div class="stat-line"><span class="stat-label">Gems Earned</span><span class="stat-value" id="stat-gems-earned">0</span></div>
              <div class="stat-line"><span class="stat-label">EXP Gained</span><span class="stat-value" id="stat-exp-gained">0</span></div>
              <div class="stat-line"><span class="stat-label">Items Found</span><span class="stat-value" id="stat-items-found">0</span></div>
              <div class="stat-line"><span class="stat-label">Items Purchased</span><span class="stat-value" id="stat-items-bought">0</span></div>
              <div class="stat-line"><span class="stat-label">Play Time</span><span class="stat-value" id="stat-playtime">0h 0m</span></div>
            </div>

            <button id="btn-reset-progress" style="width: 100%; margin-top: 16px; padding: 10px; background: linear-gradient(135deg, #8b0000 0%, #dc143c 100%); border: 2px solid #ff6347; border-radius: 8px; color: white; font-family: var(--font-display); font-weight: 600; font-size: 13px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: all 0.2s; text-transform: uppercase;">
              Reset All Progress
            </button>
          </div>
        </div>
      </div>

      <div id="world-requirements" class="panel">
        <h4 id="world-requirements-title">Challenge World 1</h4>
        <div class="requirement" id="req-enemies">
          <span>Enemies: <span id="req-enemies-text">0 / 0</span></span>
        </div>
        <div class="requirement" id="req-elites">
          <span>Elites: <span id="req-elites-text">0 / 0</span></span>
        </div>
        <div class="requirement" id="req-level">
          <span>Level: <span id="req-level-text">1 / 1</span></span>
        </div>
        <button id="btn-challenge-world">Challenge World</button>
      </div>
    </section>

    <!-- Challenge Overlay - Shows active challenge info centered on screen -->
    <div id="challenge-overlay" style="display:none;">
      <div id="challenge-content">
        <p id="challenge-description">Challenge description</p>
        <div id="challenge-timer">â±ï¸ <span id="timer-text">1:00</span></div>
      </div>
    </div>

    <!-- Global tooltip for inventory and shop -->
    <div id="inventory-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>

    <!-- Custom confirmation modal -->
    <div id="reset-modal" class="custom-modal" aria-hidden="true">
      <div class="modal-content">
        <div class="modal-header">Reset All Progress</div>
        <div class="modal-body">
          This will delete ALL your progress and reset the game to the beginning. This action CANNOT be undone!
          <br><br>
          Are you absolutely sure you want to reset?
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-cancel" id="modal-cancel">Cancel</button>
          <button class="modal-btn modal-btn-confirm" id="modal-confirm">Reset Progress</button>
        </div>
      </div>
    </div>

    <!-- Sell confirmation modal -->
    <div id="sell-modal" class="custom-modal" aria-hidden="true">
      <div class="modal-content">
        <div class="modal-header">Sell Item</div>
        <div class="modal-body" id="sell-modal-body">
          Are you sure you want to sell this item?
        </div>
        <div class="modal-actions">
          <button class="modal-btn modal-btn-cancel" id="sell-modal-cancel">Cancel</button>
          <button class="modal-btn modal-btn-confirm" id="sell-modal-confirm">Sell</button>
        </div>
      </div>
    </div>

    <div id="bottom-nav">
      <button class="nav-btn" onclick="openOverlay('inventory-overlay')">
        <span class="nav-btn-icon">ðŸŽ’</span>
        <span>Inventory</span>
      </button>
      <button class="nav-btn" onclick="openOverlay('shop-overlay')">
        <span class="nav-btn-icon">ðŸ›’</span>
        <span>Shop</span>
      </button>
      <button class="nav-btn" onclick="openOverlay('stats-overlay')">
        <span class="nav-btn-icon">ðŸ“Š</span>
        <span>Stats</span>
      </button>
    </div>

    <div id="debug-panel" style="display:none">
      <h4>Debug Panel</h4>
      <div id="debug-info"></div>
      <button class="debug-btn" onclick="DevTools.spawnEnemies(10, 'normal')">Spawn 10 Normal</button>
      <button class="debug-btn" onclick="DevTools.spawnEnemies(5, 'elite')">Spawn 5 Elite</button>
      <button class="debug-btn" onclick="DevTools.grantCoins(1000000)">+1m Coins</button>
      <button class="debug-btn" onclick="DevTools.grantGems(100)">+100 Gems</button>
      <button class="debug-btn" onclick="DevTools.levelUp()">Level Up</button>
      <button class="debug-btn" onclick="DevTools.clearSave()">Clear Save</button>
      <div style="border-top: 1px solid #444; margin: 8px 0; padding-top: 8px;">
        <div style="font-weight: bold; margin-bottom: 4px;">Grant Equipment Sets:</div>
        <button class="debug-btn" onclick="DevTools.grantSet('skywarden')">Skywarden</button>
        <button class="debug-btn" onclick="DevTools.grantSet('stormbreaker')">Stormbreaker</button>
        <button class="debug-btn" onclick="DevTools.grantSet('bastion')">Bastion</button>
        <button class="debug-btn" onclick="DevTools.grantSet('nightwing')">Nightwing</button>
        <button class="debug-btn" onclick="DevTools.grantSet('shade')">Shade</button>
        <button class="debug-btn" onclick="DevTools.grantSet('aegis')">Aegis</button>
        <button class="debug-btn" onclick="DevTools.grantSet('glacier')">Glacier</button>
        <button class="debug-btn" onclick="DevTools.grantSet('emberkin')">Emberkin</button>
        <button class="debug-btn" onclick="DevTools.grantSet('zephyr')">Zephyr</button>
      </div>
    </div>

    <div id="notification-container"></div>
  </div>

  <script>
// ========== Section 2: CONFIG ==========
const CONFIG = {
  TICK_INTERVAL_MS: 100,
  UI_UPDATE_MS: 250,
  SAVE_INTERVAL_MS: 10000,
  GAME_TIME_SCALE: 1,
  PLAYER_RADIUS_PX: 28,
  ENGAGE_RADIUS_PX: 120,
  EQUIP_RENDER_RADIUS_PX: 80,
  MAX_INVENTORY_SLOTS: 8,
  ATTACK_INTERVAL_DIVISOR: 100,
  MIN_ATTACK_INTERVAL_S: 0.01,
  SHOP_AUTO_REFRESH_SEC: 60,
  SHOP_MANUAL_COOLDOWN_SEC: 5,
  DEFAULT_CONSUMABLE_DURATION_S: 3600,
  TEST_CONSUMABLE_DURATION_S: 300,
  WAVE_INTERVAL_SEC: 0.3,
  MIN_WAVE_ENEMIES: 5,
  MAX_WAVE_ENEMIES: 200,
  RARITY_PROB: { common:0.45, uncommon:0.35, rare:0.10, epic:0.05, legendary:0.03, mythic:0.02 },
  // Base upgrade costs calculated so that upgrading from level 1 to 100 costs max 300% of next rarity's shop price
  // Formula: maxTotalCost = nextRarityShopPrice * 3.0
  // Using geometric series with r=1.055 over 99 levels (1->2, 2->3, ... 99->100)
  EQUIP_BASE_UPGRADE_COST: { 
    common: 10.7,      // Upgrades to 100 cost ~1500 (300% of uncommon's 2000/3 â‰ˆ 667)
    uncommon: 42.8,    // Upgrades to 100 cost ~6000 (300% of rare's 10000/3 â‰ˆ 3333)
    rare: 214,         // Upgrades to 100 cost ~30000 (300% of epic's 50000/3 â‰ˆ 16667)
    epic: 1070,        // Upgrades to 100 cost ~150000 (300% of legendary's 200000/3 â‰ˆ 66667)
    legendary: 4280,   // Upgrades to 100 cost ~600000 (300% of mythic's 1000000/3 â‰ˆ 333333)
    mythic: 21400,     // Upgrades to 100 cost ~3000000 (300% of divine's cost)
    divine: 107000     // Upgrades to 100 cost ~15000000 (highest tier)
  },
  STAR_THRESHOLDS: [10,25,50,75,100],
  STAR_GEM_COSTS: { "10":0, "25":1, "50":3, "75":5, "100":10 },
  BASE_SHOP_PRICE: { common:500, uncommon:2000, rare:10000, epic:50000, legendary:200000, mythic:1000000 },
  ENEMY_BASE_COIN: { small:25, normal:50, big:150, elite:650, boss:7250 },
  ENEMY_HP_SCALE: 1.75,
  ENEMY_ATK_SCALE: 1.25,
  ENEMY_RESIST_BONUS_PER_WORLD: 0.5,
  BASE_EQUIP_DROP_CHANCE_PCT: { normal:0.5, small:0.25, big:2, elite:10 },
  LUCK_EFFECT_MULTIPLIER: 1.0,
  SAVE_KEY: "inc_rpg_v1",
  AUTO_ATTACK_SEED: null,
  DEV_MODE: false
};

// ========== EQUIPMENT SETS ==========
const EQUIPMENT_SETS = {
  skywarden: {
    name: 'Skywarden',
    element: 'wind',
    icon: 'ðŸŒªï¸',
    weaponName: 'Aquila Longbow',
    weaponDesc: 'Deal 120% wind damage to an enemy, randomly pushes that enemy and 2 nearby enemies back a small distance, and deal 50% wind damage to them. After enemy dies to wind damage, creates an AOE wind explosion on the dead enemy area that deals 50% wind damage to surrounding enemies and push them back.',
    items: {
      helmet: { slot: 'helmet', name: 'Skywarden Helmet', icon: 'ðŸƒ' },
      chestplate: { slot: 'chestplate', name: 'Skywarden Chestplate', icon: 'ðŸƒ' },
      leggings: { slot: 'leggings', name: 'Skywarden Leggings', icon: 'ðŸƒ' },
      boots: { slot: 'boots', name: 'Skywarden Boots', icon: 'ðŸƒ' },
      ring: { slot: 'ring', name: 'Skywarden Ring', icon: 'ðŸƒ' },
      weapon: { slot: 'weapon', name: 'Aquila Longbow', icon: 'ðŸ¹', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Wind Storm: If enemy killed with wind damage, create 3 AOE wind explosions nearby that enemy that deals 50% wind damage to surrounding enemies.' },
      4: { desc: '+12% Wind DMG', WindDMG_pct: 12 },
      6: { desc: 'Aquila Tornado: For every 20 enemy killed with wind damage, create a tornado at a random enemy, pull every enemy nearby to the tornado, dealing 50% wind damage each tick for 5 seconds.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  stormbreaker: {
    name: 'Stormbreaker',
    element: 'lightning',
    icon: 'âš¡',
    weaponName: 'Storm Pike',
    weaponDesc: 'Deal 120% lightning damage to an enemy, there is a 50% chance to hit a nearby enemy, dealing 75% lightning damage to that enemy, then there is a 25% chance to hit another nearby enemy, dealing 50% lightning damage to that enemy.',
    items: {
      helmet: { slot: 'helmet', name: 'Stormbreaker Helmet', icon: 'âš¡' },
      chestplate: { slot: 'chestplate', name: 'Stormbreaker Chestplate', icon: 'âš¡' },
      leggings: { slot: 'leggings', name: 'Stormbreaker Leggings', icon: 'âš¡' },
      boots: { slot: 'boots', name: 'Stormbreaker Boots', icon: 'âš¡' },
      ring: { slot: 'ring', name: 'Stormbreaker Ring', icon: 'âš¡' },
      weapon: { slot: 'weapon', name: 'Storm Pike', icon: 'ðŸ”±', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Lightning Surge: Lightning is guaranteed to hit at least 2 nearby enemies after hitting an enemy, 50% chance to hit the 4th and 25% chance to hit the 5th, lightning now deals consistent 75% lightning damage.' },
      4: { desc: '+12% Lightning DMG', LightningDMG_pct: 12 },
      6: { desc: 'Multishot: Creates 3 lightning arcs to that enemy and 2 nearby enemies, lightning now deals consistent 120% lightning damage.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  bastion: {
    name: 'Bastion',
    element: 'physical',
    icon: 'ðŸ›¡ï¸',
    weaponName: 'Titan Warhammer',
    weaponDesc: 'Deal 120% physical damage equal to 30% player HP and 80% physical damage equal to 20% player HP in surrounding area.',
    items: {
      helmet: { slot: 'helmet', name: 'Bastion Helmet', icon: 'ðŸ›¡ï¸' },
      chestplate: { slot: 'chestplate', name: 'Bastion Chestplate', icon: 'ðŸ›¡ï¸' },
      leggings: { slot: 'leggings', name: 'Bastion Leggings', icon: 'ðŸ›¡ï¸' },
      boots: { slot: 'boots', name: 'Bastion Boots', icon: 'ðŸ›¡ï¸' },
      ring: { slot: 'ring', name: 'Bastion Ring', icon: 'ðŸ›¡ï¸' },
      weapon: { slot: 'weapon', name: 'Titan Warhammer', icon: 'âš’ï¸', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% HP', HP_pct: 12 },
      3: { desc: 'Shock Roar: Creates a giant shock area around the player every 1.5 seconds, dealing 180% damage equal to 50% of players HP.' },
      4: { desc: 'Reduce damage taken by 12%', DMG_reduction_pct: 12 },
      6: { desc: 'Metal Fierce: +20% DMG when player <50% HP, increase area of Shock Roar and the player\'s attack, change color of Shock Roar and player\'s attack to light red' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  nightwing: {
    name: 'Nightwing',
    element: 'physical',
    icon: 'ðŸ¦‡',
    weaponName: "Raven's Volley",
    weaponDesc: 'Deal 120% physical damage equal to 20% of players ATK, after hit an enemy, bounce 2 coins randomly 3 times, dealing 0.77% physical damage of players total coins (this damage appears yellow).',
    items: {
      helmet: { slot: 'helmet', name: 'Nightwing Helmet', icon: 'ðŸ¦‡' },
      chestplate: { slot: 'chestplate', name: 'Nightwing Chestplate', icon: 'ðŸ¦‡' },
      leggings: { slot: 'leggings', name: 'Nightwing Leggings', icon: 'ðŸ¦‡' },
      boots: { slot: 'boots', name: 'Nightwing Boots', icon: 'ðŸ¦‡' },
      ring: { slot: 'ring', name: 'Nightwing Ring', icon: 'ðŸ¦‡' },
      weapon: { slot: 'weapon', name: "Raven's Volley", icon: 'ðŸŸ¡', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Rich Man\'s Blow: For every enemy killed with coin damage, shoot 5 coins from the dead enemy in star pattern, each coin hit deals 0.99% physical yellow damage of players total coins. Increase coin obtained from enemies killed with coin damage by 50%.' },
      4: { desc: '+6% SPD', SPD_pct: 6 },
      6: { desc: 'Wealth: For every 20 enemy killed with coin damage, rains coins and each coin hit deals 1.88% physical yellow damage of players total coins to the enemies on the field, this rain lasts for 5 seconds, kills from rain coins do not count towards 20 enemy killed with coin damage.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  shade: {
    name: 'Shade',
    element: 'physical',
    icon: 'ðŸ’€',
    weaponName: 'Wraith Scythe',
    weaponDesc: 'Deal 50% physical damage to an enemy, lose 2% max HP, and deals extra 200% physical damage + 200% of HP lost to an enemy (this damage appears red), if an enemy dies, restores 5% max HP. If the player has lower than 2% max HP, set the player\'s HP to 1.',
    items: {
      helmet: { slot: 'helmet', name: 'Shade Helmet', icon: 'ðŸ©¸' },
      chestplate: { slot: 'chestplate', name: 'Shade Chestplate', icon: 'ðŸ©¸' },
      leggings: { slot: 'leggings', name: 'Shade Leggings', icon: 'ðŸ©¸' },
      boots: { slot: 'boots', name: 'Shade Boots', icon: 'ðŸ©¸' },
      ring: { slot: 'ring', name: 'Shade Ring', icon: 'ðŸ©¸' },
      weapon: { slot: 'weapon', name: 'Wraith Scythe', icon: 'ðŸª’', isWeapon: true, multiplier: 0.50 }
    },
    bonuses: {
      2: { desc: '+12% HP', HP_pct: 12 },
      3: { desc: 'Bloodbath: Increase damage dealt by HP lost by 200%, create a small rain area lasts for 5 seconds, enemies entering or within the area takes damage equal to 300% of HP lost every tick for 5 seconds.' },
      4: { desc: 'Reduce damage taken by 12%', DMG_reduction_pct: 12 },
      6: { desc: 'Overflow: For every 2000 HP lost or healed, +50% DMG for 30 seconds. If the player has <50% HP, heals up to full HP and creates a giant red explosion, dealing 500% HP lost to surrounding enemies.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  aegis: {
    name: 'Aegis',
    element: 'aether',
    icon: 'âœ¨',
    weaponName: 'Aether Scepter',
    weaponDesc: 'Launches a ball that continuously hover around the enemy, dealing 120% aether damage each enemy hit, if the enemy is dead, the ball launches to a random enemy, dealing 120% aether damage each hit, the ball lasts for 5 seconds.',
    items: {
      helmet: { slot: 'helmet', name: 'Aegis Helmet', icon: 'âœ¨' },
      chestplate: { slot: 'chestplate', name: 'Aegis Chestplate', icon: 'âœ¨' },
      leggings: { slot: 'leggings', name: 'Aegis Leggings', icon: 'âœ¨' },
      boots: { slot: 'boots', name: 'Aegis Boots', icon: 'âœ¨' },
      ring: { slot: 'ring', name: 'Aegis Ring', icon: 'âœ¨' },
      weapon: { slot: 'weapon', name: 'Aether Scepter', icon: 'ðŸ”®', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% Aether DMG', AetherDMG_pct: 12 },
      3: { desc: 'Myth: For every enemy hit, there is a 20% chance to spawn another ball from the enemy, launches to a random enemy, that continuously hover around the enemy, dealing 120% aether damage each hit, the ball lasts for 3 seconds or after the enemy is dead' },
      4: { desc: 'Launches 2 balls that continuously hover around the enemy instead of 1, dealing 150% aether damage each enemy hit, if the enemy is dead, the balls move to a random enemy, dealing 150% aether damage each hit, the balls last for 8 seconds.' },
      6: { desc: 'Star Shooter: after the enemy is dead, the balls no longer moves to a random enemy, but instead spins around the dead enemy for 3 seconds, each ball deals 80% aether damage, then launch those balls to random enemies, explodes and dealing 200% aether damage to the enemy.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  glacier: {
    name: 'Glacier',
    element: 'cryo',
    icon: 'â„ï¸',
    weaponName: 'Cryo Rod',
    weaponDesc: 'Immediately freezes the enemy for 2 seconds and deal 120% cryo damage to an enemy, if an enemy is already frozen before, they cant be frozen again for 10 seconds, after the enemy is dead, create a cryo AOE that any enemy moved or within the area will be freezed for 3 seconds, dealing 20% cryo damage every tick for 3 seconds.',
    items: {
      helmet: { slot: 'helmet', name: 'Glacier Helmet', icon: 'â„ï¸' },
      chestplate: { slot: 'chestplate', name: 'Glacier Chestplate', icon: 'â„ï¸' },
      leggings: { slot: 'leggings', name: 'Glacier Leggings', icon: 'â„ï¸' },
      boots: { slot: 'boots', name: 'Glacier Boots', icon: 'â„ï¸' },
      ring: { slot: 'ring', name: 'Glacier Ring', icon: 'â„ï¸' },
      weapon: { slot: 'weapon', name: 'Cryo Rod', icon: 'ðŸ¦¯', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Frozen Spikes: After the enemy is unfrozen, create an explosion and deal 120% cryo damage to that enemy.' },
      4: { desc: 'Freezed enemies take +20% damage' },
      6: { desc: 'Ice Storm: If an enemy dies to cryo damage, freeze all enemies on the field for 5 seconds, this effect can only be activated every 30 seconds.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  emberkin: {
    name: 'Emberkin',
    element: 'fire',
    icon: 'ðŸ”¥',
    weaponName: 'Inferno Blade',
    weaponDesc: 'Deals 120% fire damage, create a fire AOE for 10 seconds, enemy entering or within the fire AOE will immediately take fire damage over time equal to 20% fire damage every tick for 5 seconds.',
    items: {
      helmet: { slot: 'helmet', name: 'Emberkin Helmet', icon: 'ðŸ”¥' },
      chestplate: { slot: 'chestplate', name: 'Emberkin Chestplate', icon: 'ðŸ”¥' },
      leggings: { slot: 'leggings', name: 'Emberkin Leggings', icon: 'ðŸ”¥' },
      boots: { slot: 'boots', name: 'Emberkin Boots', icon: 'ðŸ”¥' },
      ring: { slot: 'ring', name: 'Emberkin Ring', icon: 'ðŸ”¥' },
      weapon: { slot: 'weapon', name: 'Inferno Blade', icon: 'âš”ï¸', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Burn: Burning DoT scales by +8% of player ATK per tick.' },
      4: { desc: '+12% Fire DMG', FireDMG_pct: 12 },
      6: { desc: 'Ignite: After killing 10 enemies with fire damage, randomly creates 3 giant red pink-ish fire around the player that lasts for 10 seconds, enemy entering or within the fire AOE will immediately take fire damage over time equal to 65% fire damage every tick for 10 seconds.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  },
  zephyr: {
    name: 'Zephyr',
    element: 'aether',
    icon: 'ðŸŒŸ',
    weaponName: 'Gale Daggers',
    weaponDesc: 'Deals 120% aether damage to an enemy, then split into 4 stars shooting randomly, each star deals 50% aether damage to enemy collide with the star.',
    items: {
      helmet: { slot: 'helmet', name: 'Zephyr Helmet', icon: 'ðŸŒŸ' },
      chestplate: { slot: 'chestplate', name: 'Zephyr Chestplate', icon: 'ðŸŒŸ' },
      leggings: { slot: 'leggings', name: 'Zephyr Leggings', icon: 'ðŸŒŸ' },
      boots: { slot: 'boots', name: 'Zephyr Boots', icon: 'ðŸŒŸ' },
      ring: { slot: 'ring', name: 'Zephyr Ring', icon: 'ðŸŒŸ' },
      weapon: { slot: 'weapon', name: 'Gale Daggers', icon: 'ðŸ—¡ï¸', isWeapon: true, multiplier: 1.20 }
    },
    bonuses: {
      2: { desc: '+12% ATK', ATK_pct: 12 },
      3: { desc: 'Blow: For each star collide to an enemy, create an explosion dealing 50% aether damage to surrounding enemies.' },
      4: { desc: '+2 stars' },
      6: { desc: 'Bounce: Stars after hit the first enemy, now bounces to another random enemy, for each enemy hit, deals 50% aether damage to enemy.' }
    },
    slots: ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon']
  }
};
// ========== RNG ==========
class RNG {
  constructor(seed) {
    this.useDeterministic = seed !== null && seed !== undefined;
    if (this.useDeterministic) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < seed.length; i++) {
        h = Math.imul(h ^ seed.charCodeAt(i), 16777619);
      }
      this.state = h >>> 0;
    }
  }

  rand() {
    if (!this.useDeterministic) return Math.random();
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }

  randInt(min, max) {
    return Math.floor(this.rand() * (max - min + 1)) + min;
  }

  randRange(a, b) {
    return a + this.rand() * (b - a);
  }

  weightedChoice(items, weights) {
    const total = weights.reduce((sum, w) => sum + w, 0);
    let r = this.rand() * total;
    for (let i = 0; i < items.length; i++) {
      r -= weights[i];
      if (r <= 0) return items[i];
    }
    return items[items.length - 1];
  }
}

// ========== Game State ==========
const GameState = {
  rng: null,
  player: null,
  enemies: [],
  shop: null,
  worldProgress: null,
  lastSaveTime: 0,
  waveTimer: 0,
  suspendWaves: false,
  autoAttackTimer: 0,
  enemyIdCounter: 0,
  itemIdCounter: 0,

  // Death system
  isDead: false,
  deathTimer: 0,
  isInvincible: false,
  invincibilityTimer: 0,
  canAttack: true,
  inBossChallenge: false,
  
  // Dynamic challenge system
  currentChallenge: null,
  challengeProgress: {
    enemiesKilled: 0,
    elitesKilled: 0,
    bossesKilled: 0,
    totalKilled: 0,
    died: false,
    startTime: 0,
    waitingForNextWave: false
  }
};

// ========== Data Models ==========
function createPlayer() {
  return {
    coins: 0,
    gems: 0,
    level: 1,
    exp: 0,
    world: 1,
    hp: 100,
    maxHp: 100,
    inventory: [],
    equipment: { helmet:null, chestplate:null, leggings:null, boots:null, ring:null, weapon:null },
    baseStats: { ATK:100, HP:100, SPD:10, DMG_PCT:100, CRIT_RATE_PCT:5, CRIT_DMG_PCT:100 },
    currentStats: {},
    activeEffects: [],
    luck: 0,
    statistics: {
      totalKills: 0,
      totalDamageDealt: 0,
      totalDamageTaken: 0,
      highestDamageDealt: 0,
      highestDamageTaken: 0,
      totalCoinsEarned: 0,
      totalGemsEarned: 0,
      totalExpGained: 0,
      bossesDefeated: 0,
      deaths: 0,
      criticalHits: 0,
      itemsFound: 0,
      itemsPurchased: 0,
      worldsCompleted: 0,
      totalPlayTime: 0,
      sessionStartTime: Date.now()
    }
  };
}

function createShop() {
  return {
    lastRefreshTs: Date.now(),
    offers: { equipment: [], consumables: [] },
    manualCooldownEndTs: 0
  };
}

function createWorldProgress() {
  return {
    enemiesKilledThisWorld: 0,
    elitesKilledThisWorld: 0,
    requiredEnemies: 25,
    requiredElites: 1,
    requiredLevel: 3,
    equipmentRequirement: { minRarity: 'rare', required: false },
    assignedChallenges: {} // Store challenge type per world: { worldNum: challengeType }
  };
}

// ========== Derived Stats ==========
function computeDerivedStats() {
  const p = GameState.player;
  const base = p.baseStats;

  let sumFlatATK = 0, sumFlatHP = 0, sumFlatSPD = 0;
  let sumATKPct = 0, sumHPPct = 0, sumDMGPct = 0;
  let sumCritRate = 0, sumCritDmg = 0;
  let luck = 0;

  Object.values(p.equipment).forEach(item => {
    if (!item) return;

    // Add safety check for baseAttribute
    const attr = item.baseAttribute;
    if (attr && attr.name) {
      if (attr.name === 'ATK') sumFlatATK += attr.value;
      else if (attr.name === 'HP') sumFlatHP += attr.value;
      else if (attr.name === 'SPD') sumFlatSPD += attr.value;
      else if (attr.name === 'DMG%') sumDMGPct += attr.value;
      else if (attr.name === 'ATK%') sumATKPct += attr.value;
      else if (attr.name === 'HP%') sumHPPct += attr.value;
    }

    // Add from item.stats if baseAttribute doesn't exist (for debug-granted items)
    if (item.stats) {
      if (item.stats.ATK) sumFlatATK += item.stats.ATK;
      if (item.stats.HP) sumFlatHP += item.stats.HP;
      if (item.stats.SPD) sumFlatSPD += item.stats.SPD;
    }

    // Add safety check for affixes
    if (item.affixes && Array.isArray(item.affixes)) {
      item.affixes.forEach(affix => {
        if (affix.locked) return;

        if (affix.name === 'ATK') sumFlatATK += affix.value;
        else if (affix.name === 'HP') sumFlatHP += affix.value;
        else if (affix.name === 'SPD') sumFlatSPD += affix.value;
        else if (affix.name === 'DMG%') sumDMGPct += affix.value;
        else if (affix.name === 'ATK%') sumATKPct += affix.value;
        else if (affix.name === 'HP%') sumHPPct += affix.value;
        else if (affix.name === 'Crit Rate') sumCritRate += affix.value;
        else if (affix.name === 'Crit Damage') sumCritDmg += affix.value;
      });
    }
  });

  // Count equipped set pieces
  const setCounts = {};
  Object.values(p.equipment).forEach(item => {
    if (item && item.setId) {
      setCounts[item.setId] = (setCounts[item.setId] || 0) + 1;
    }
  });

  // Initialize set tracking
  p.activeSets = setCounts;
  p.elementalDMG = {};
  p.dmgReduction = 0;

  // Apply set bonuses
  Object.keys(setCounts).forEach(setId => {
    const count = setCounts[setId];
    // Safety check: Skip if set doesn't exist in EQUIPMENT_SETS
    if (!EQUIPMENT_SETS[setId]) return;
    const setData = EQUIPMENT_SETS[setId];
    if (!setData) return;

    // 2-piece bonus
    if (count >= 2 && setData.bonuses[2]) {
      const bonus = setData.bonuses[2];
      if (bonus.ATK_pct) sumATKPct += bonus.ATK_pct;
      if (bonus.HP_pct) sumHPPct += bonus.HP_pct;
      if (bonus.SPD_pct) sumFlatSPD *= (1 + bonus.SPD_pct / 100);
      if (bonus.DMG_reduction_pct) p.dmgReduction += bonus.DMG_reduction_pct / 100;
      if (bonus.AetherDMG_pct) p.elementalDMG.aether = (p.elementalDMG.aether || 0) + bonus.AetherDMG_pct / 100;
    }

    // 4-piece bonus
    if (count >= 4 && setData.bonuses[4]) {
      const bonus = setData.bonuses[4];
      if (bonus.WindDMG_pct) p.elementalDMG.wind = (p.elementalDMG.wind || 0) + bonus.WindDMG_pct / 100;
      if (bonus.LightningDMG_pct) p.elementalDMG.lightning = (p.elementalDMG.lightning || 0) + bonus.LightningDMG_pct / 100;
      if (bonus.FireDMG_pct) p.elementalDMG.fire = (p.elementalDMG.fire || 0) + bonus.FireDMG_pct / 100;
      if (bonus.DMG_reduction_pct) p.dmgReduction += bonus.DMG_reduction_pct / 100;
    }

    // 5-piece: Nightwing coin bonus
    if (count >= 5 && setId === 'nightwing') {
      const coinBonus = Math.min(Math.floor(p.coins / 2000), 5000);
      sumFlatATK += coinBonus;
    }
  });

  Object.keys(setCounts).forEach(setId => {
    const count = setCounts[setId];
    if (count >= 6 && setId === 'nightwing') {
      const wealthStacks = (p.setBonusTracking && p.setBonusTracking.nightwing && p.setBonusTracking.nightwing.wealthStacks) || 0;
      sumDMGPct += wealthStacks * 20;
    }
    if (count >= 6 && setId === 'bastion') {
      const currentHp = p.hp || 0;
      const maxHp = p.maxHp || p.HP_max || 1;
      if (currentHp < maxHp * 0.5) sumDMGPct += 20;
    }
    if (count >= 6 && setId === 'shade') {
      const bloodthirstStacks = (p.setBonusTracking && p.setBonusTracking.shade && p.setBonusTracking.shade.bloodthirstStacks) || 0;
      sumDMGPct += bloodthirstStacks * 2;
    }
  });

  p.activeEffects.forEach(effect => {
    if (effect.id === 'spd_boost_200') {
      sumFlatSPD *= effect.params.multiplier;
    }
    if (effect.id === 'luck_boost_50') {
      luck += effect.params.value;
    }
  });

  // Apply enchantment bonuses
  const activeEnchantments = getActiveEnchantments();
  activeEnchantments.forEach(ench => {
    switch(ench.id) {
      case 'strength':
        sumATKPct += 200;
        break;
      case 'damage_boost':
        sumDMGPct += 150;
        break;
      case 'elemental_boost':
        // Apply 120% to all elemental damage
        ['fire', 'lightning', 'wind', 'cryo', 'aether', 'physical'].forEach(elem => {
          p.elementalDMG[elem] = (p.elementalDMG[elem] || 0) + 1.20;
        });
        break;
      case 'hp_boost':
        sumHPPct += 150;
        break;
      case 'spd_boost':
        sumFlatSPD *= 1.5;
        break;
      case 'protection':
        p.dmgReduction += 0.20;
        break;
      case 'fortune':
        // Coin bonus handled in enemy death
        break;
      case 'expert_hunter':
        // EXP bonus handled in enemy death
        break;
      case 'luck':
        luck += 50; // Increase luck value
        break;
    }
  });
  
  // Apply Rage enchantment bonus if active
  if (p.rageEnchantActive) {
    sumFlatSPD *= 1.5;
    // Physical damage bonus will be applied in damage calculation
  }

  const finalATK = Math.floor((base.ATK + sumFlatATK) * (1 + sumATKPct / 100));
  const finalHP = Math.floor((base.HP + sumFlatHP) * (1 + sumHPPct / 100));
  const finalSPD = base.SPD + sumFlatSPD;
  const finalDMGPct = base.DMG_PCT + sumDMGPct;
  const finalCritRate = Math.max(0, Math.min(100, base.CRIT_RATE_PCT + sumCritRate));
  const finalCritDmg = Math.max(0, base.CRIT_DMG_PCT + sumCritDmg);

  // BASTION 6-PIECE: Metal Fierce - +20% DMG when player <50% HP
  let bastionDmgMultiplier = 1.0;
  if (getSetCount('bastion') >= 6) {
    const currentHP = getPlayerHP(p);
    const maxHP = p.maxHp || finalHP || 1;
    if (currentHP < maxHP * 0.50) {
      bastionDmgMultiplier = 1.20;
    }
  }

  // Calculate bonuses from items (difference from base stats)
  const atkBonus = finalATK - base.ATK;
  const hpBonus = finalHP - base.HP;
  const spdBonus = finalSPD - base.SPD;
  const dmgBonus = (finalDMGPct * bastionDmgMultiplier) - base.DMG_PCT;

  p.currentStats = { finalATK, finalHP, finalSPD, finalDMGPct: finalDMGPct * bastionDmgMultiplier, finalCritRate, finalCritDmg };
  p.statBonuses = { atkBonus, hpBonus, spdBonus, dmgBonus };
  p.luck = luck;

  p.maxHp = finalHP;
  if (p.hp > p.maxHp) p.hp = p.maxHp;
}

// ========== Attack & Damage ==========
function getAttackInterval() {
  const spd = GameState.player.currentStats.finalSPD;
  return Math.max(CONFIG.MIN_ATTACK_INTERVAL_S, CONFIG.ATTACK_INTERVAL_DIVISOR / spd);
}

function computeDamage(enemy) {
  const p = GameState.player;
  let baseDamage = p.currentStats.finalATK * (p.currentStats.finalDMGPct / 100);

  const dmgBoost = p.activeEffects.find(e => e.id === 'dmg_boost_200');
  if (dmgBoost) {
    baseDamage *= dmgBoost.params.multiplier;
  }

  // Apply Rage enchantment bonus for physical damage
  if (p.rageEnchantActive && hasEnchantment('rage')) {
    baseDamage *= 3.0; // +200% = 3x multiplier
  }
  
  const isCrit = GameState.rng.rand() < p.currentStats.finalCritRate / 100;
  if (isCrit) {
    baseDamage *= (1 + p.currentStats.finalCritDmg / 100);
    // Track critical hits
    if (p.statistics) {
      p.statistics.criticalHits++;
    }
  }

  const appliedDamage = Math.max(1, Math.floor(baseDamage * Math.max(0.05, 1 - enemy.resistancePct / 100)));

  // Track total damage dealt
  if (p.statistics) {
    p.statistics.totalDamageDealt += appliedDamage;
    if (appliedDamage > (p.statistics.highestDamageDealt || 0)) {
      p.statistics.highestDamageDealt = appliedDamage;
    }
  }

  return { damage: appliedDamage, crit: isCrit };
}

function computePlayerDamage() {
  const p = GameState.player;
  let baseDamage = p.currentStats.finalATK * (p.currentStats.finalDMGPct / 100);

  const dmgBoost = p.activeEffects.find(e => e.id === 'dmg_boost_200');
  if (dmgBoost) {
    baseDamage *= dmgBoost.params.multiplier;
  }

  return Math.floor(baseDamage);
}

// Helper function to roll for critical hit on any damage
function rollCrit(baseDamage) {
  const p = GameState.player;
  const isCrit = GameState.rng.rand() < p.currentStats.finalCritRate / 100;
  
  if (isCrit) {
    const critDamage = baseDamage * (1 + p.currentStats.finalCritDmg / 100);
    
    // Track critical hits
    if (p.statistics) {
      p.statistics.criticalHits++;
    }
    
    return { damage: Math.floor(critDamage), crit: true };
  }
  
  return { damage: Math.floor(baseDamage), crit: false };
}

// Wrapper function that applies damage with automatic crit calculation
function applyCritDamage(enemy, baseDamage, ctx = {}) {
  // Apply weakness debuff if active (-50% damage)
  if (GameState.player.activeDebuffs && GameState.player.activeDebuffs.weakness) {
    baseDamage = Math.floor(baseDamage * GameState.player.activeDebuffs.weakness.multiplier);
  }
  
  const { damage, crit } = rollCrit(baseDamage);
  applyDamageToEnemy(enemy, damage, { ...ctx, crit });
}

function dealDamageToPlayer(amount, isCrit = false) {
  // Don't take damage if dead or invincible
  if (GameState.isDead || GameState.isInvincible) return;

  const oldHP = GameState.player.hp;
  GameState.player.hp = Math.max(0, GameState.player.hp - amount);
  trackShadeHPChange(GameState.player.hp - oldHP);

  // Track damage taken
  if (GameState.player.statistics) {
    GameState.player.statistics.totalDamageTaken += amount;
    if (amount > (GameState.player.statistics.highestDamageTaken || 0)) {
      GameState.player.statistics.highestDamageTaken = amount;
    }
  }
  
  // Show critical hit notification
  if (isCrit) {
    showNotification(`ðŸ’¥ Critical Hit! -${amount}`, 'danger');
  }
  
  if (GameState.player.hp <= 0) {
    handlePlayerDeath();
  }
}

function handlePlayerDeath() {
  GameState.isDead = true;
  GameState.canAttack = false;
  GameState.player.hp = 0;

  // Track challenge death
  trackDeath();

  // Track death
  if (GameState.player.statistics) {
    GameState.player.statistics.deaths++;
  }

  // Check if in any challenge (boss challenge or regular challenge)
  if (GameState.inBossChallenge || GameState.currentChallenge) {
    // Challenge failed - show challenge failure screen
    GameState.deathTimer = 3; // 3 seconds for challenge failure screen
    handleChallengeFailed();
  } else {
    // Normal death (not in a challenge)
    GameState.deathTimer = 5; // 5 seconds death screen

    // Show death screen
    const deathScreen = document.getElementById('death-screen');
    if (deathScreen) {
      deathScreen.classList.add('active');
    }
  }

  // Make player invisible
  const player = document.getElementById('player');
  if (player) {
    player.style.opacity = '0';
  }
}

function updateDeathSystem(dt) {
  // Update death timer
  if (GameState.isDead) {
    GameState.deathTimer -= dt;

    if (GameState.inBossChallenge || GameState.currentChallenge) {
      // Challenge failure - no timer display needed
    } else {
      // Update respawn timer display for normal death
      const respawnTimer = document.getElementById('respawn-timer');
      if (respawnTimer) {
        const seconds = Math.ceil(GameState.deathTimer);
        respawnTimer.textContent = `Respawning in ${seconds} second${seconds !== 1 ? 's' : ''}...`;
      }
    }

    if (GameState.deathTimer <= 0) {
      if (GameState.inBossChallenge || GameState.currentChallenge) {
        returnFromChallengeFailure();
      } else {
        respawnPlayer();
      }
    }
  }

  // Update invincibility timer
  if (GameState.isInvincible) {
    GameState.invincibilityTimer -= dt;

    if (GameState.invincibilityTimer <= 0) {
      GameState.isInvincible = false;
      const player = document.getElementById('player');
      if (player) {
        player.classList.remove('flashing');
      }
    }
  }
}

function respawnPlayer() {
  // Restore player HP
  GameState.player.hp = GameState.player.maxHp;
  GameState.isDead = false;
  GameState.isInvincible = true;
  GameState.invincibilityTimer = 3; // 3 seconds of invincibility
  GameState.canAttack = true;

  // Hide death screen
  const deathScreen = document.getElementById('death-screen');
  if (deathScreen) {
    deathScreen.classList.remove('active');
  }

  // Make player visible and flashing
  const player = document.getElementById('player');
  if (player) {
    player.style.opacity = '1';
    player.classList.add('flashing');
  }

  // Create damage burst effect
  createDamageBurst();

  // Deal AOE damage to all enemies (300% of player damage)
  dealRespawnDamage();
}

function handleChallengeFailed() {
  console.log('[CHALLENGE] handleChallengeFailed called (player died in challenge)');
  
  // Mark that the player died in the challenge
  if (GameState.challengeProgress) {
    GameState.challengeProgress.died = true;
  }
  
  // Clear any active spawn intervals
  if (GameState.challengeProgress && GameState.challengeProgress.spawnIntervals) {
    GameState.challengeProgress.spawnIntervals.forEach(intervalId => clearInterval(intervalId));
    GameState.challengeProgress.spawnIntervals = [];
  }
  
  // Hide challenge overlay
  hideChallengeOverlay();
  
  // Clear challenge flags
  GameState.suspendWaves = false;

  // Show challenge failure screen
  const challengeFailureScreen = document.getElementById('challenge-failure-screen');
  if (challengeFailureScreen) {
    challengeFailureScreen.classList.add('active');
  }

  // Update world display
  const worldSpan = document.getElementById('challenge-failure-world');
  if (worldSpan) {
    worldSpan.textContent = GameState.player.world;
  }

  // Remove all enemies
  GameState.enemies = [];

  showNotification('ðŸ’€ Challenge failed!', 'danger');
}

function returnFromChallengeFailure() {
  console.log('returnFromChallengeFailure called');

  // Clear challenge state
  GameState.inBossChallenge = false;
  GameState.isDead = false;
  GameState.canAttack = true;
  
  // Reset challenge
  GameState.currentChallenge = null;

  // Restore player HP
  GameState.player.hp = GameState.player.maxHp;

  // Hide challenge failure screen
  const challengeFailureScreen = document.getElementById('challenge-failure-screen');
  if (challengeFailureScreen) {
    challengeFailureScreen.classList.remove('active');
  }

  // Make player visible
  const player = document.getElementById('player');
  if (player) {
    player.style.opacity = '1';
  }

  // Update world progress UI
  updateWorldProgress();

  // Resume normal wave spawning
  GameState.waveTimer = 0;
  spawnWave();

  showNotification(`Returned to World ${GameState.player.world}`, 'info');
}
function createDamageBurst() {
  const stage = document.getElementById('stage');
  const playerContainer = document.getElementById('player-container');

  if (!stage || !playerContainer) return;

  const rect = playerContainer.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const burst = document.createElement('div');
  burst.className = 'damage-burst';
  burst.style.left = (rect.left - stageRect.left + rect.width / 2) + 'px';
  burst.style.top = (rect.top - stageRect.top + rect.height / 2) + 'px';

  stage.appendChild(burst);

  // Remove after animation completes
  setTimeout(() => {
    if (burst.parentNode) {
      burst.parentNode.removeChild(burst);
    }
  }, 800);
}

function dealRespawnDamage() {
  const playerDamage = computePlayerDamage();
  const baseRespawnDamage = playerDamage * 3; // 300% damage
  
  // Get actual player position (center of stage)
  const stage = document.getElementById('stage');
  const playerX = stage.clientWidth / 2;
  const playerY = stage.clientHeight / 2;
  const pushDistance = 200; // Distance to push enemies away

  GameState.enemies.forEach(enemy => {
    // Visual feedback for each enemy
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`) ||
                    document.querySelector(`[data-boss-id="${enemy.id}"]`) ||
                    document.querySelector(`[data-entity-id="${enemy.id}"]`);

    if (enemyEl) {
      // Flash effect on enemy
      enemyEl.style.filter = 'brightness(2) saturate(0)';
      setTimeout(() => {
        enemyEl.style.filter = '';
      }, 200);
    }

    // Deal damage with crit chance
    applyCritDamage(enemy, baseRespawnDamage, { type: 'physical', source: 'respawn' });
    
    // Push enemy away from player (radial knockback)
    const dx = enemy.position.x - playerX;
    const dy = enemy.position.y - playerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > 0.1) { // Avoid division by very small numbers
      // Normalize direction vector
      const ndx = dx / dist;
      const ndy = dy / dist;
      
      // Store previous position for smooth interpolation
      enemy.prevX = enemy.position.x;
      enemy.prevY = enemy.position.y;
      
      // Push enemy outward from player center
      enemy.position.x = enemy.position.x + (ndx * pushDistance);
      enemy.position.y = enemy.position.y + (ndy * pushDistance);
    }
  });

  // Filter out dead enemies
  GameState.enemies = GameState.enemies.filter(enemy => {
    if (enemy.hp <= 0) {
      onEnemyDeath(enemy);
      return false;
    }
    return true;
  });
}

// ========== Equipment Generation ==========
const SLOT_ICONS = {
  helmet: 'â›‘ï¸',
  chestplate: 'ðŸ›¡ï¸',
  leggings: 'ðŸ‘–',
  boots: 'ðŸ‘¢',
  ring: 'ðŸ’',
  weapon: 'âš”ï¸'
};

// Base stat ranges (only for the main stat of equipment)
const BASE_STAT_RANGES = {
  common: {
    HP: [10, 50], ATK: [10, 50], SPD: [2, 5], 'DMG%': [10, 25]
  },
  uncommon: {
    HP: [600, 1000], ATK: [600, 1000], SPD: [45, 60], 'DMG%': [200, 250]
  },
  rare: {
    HP: [6000, 6500], ATK: [6000, 6500], SPD: [120, 150], 'DMG%': [600, 650]
  },
  epic: {
    HP: [15000, 18000], ATK: [15000, 18000], SPD: [300, 350], 'DMG%': [1200, 1500]
  },
  legendary: {
    HP: [30000, 35000], ATK: [30000, 35000], SPD: [550, 600], 'DMG%': [3000, 3500]
  },
  mythic: {
    HP: [50000, 55000], ATK: [50000, 55000], SPD: [1200, 1500], 'DMG%': [5500, 6000]
  },
  divine: {
    HP: [100000, 120000], ATK: [100000, 120000], SPD: [2500, 3000], 'DMG%': [12000, 15000]
  }
};

// Level 100 target values for base stats
const BASE_STAT_LEVEL100 = {
  common: {
    HP: 500, ATK: 500, SPD: 30, 'DMG%': 150
  },
  uncommon: {
    HP: 5000, ATK: 5000, SPD: 100, 'DMG%': 500
  },
  rare: {
    HP: 10000, ATK: 10000, SPD: 250, 'DMG%': 1000
  },
  epic: {
    HP: 25000, ATK: 25000, SPD: 500, 'DMG%': 2500
  },
  legendary: {
    HP: 50000, ATK: 50000, SPD: 1000, 'DMG%': 5000
  },
  mythic: {
    HP: 100000, ATK: 100000, SPD: 2500, 'DMG%': 10000
  },
  divine: {
    HP: 200000, ATK: 200000, SPD: 5000, 'DMG%': 20000
  }
};

// Affix ranges (for additional attributes on equipment)
const AFFIX_RANGES = {
  common: {
    HP: [10, 50], 'HP%': [2, 5], ATK: [10, 50], 'ATK%': [2, 5],
    SPD: [2, 5], 'DMG%': [5, 10], 'Crit Rate': [5, 10], 'Crit Damage': [10, 50]
  },
  uncommon: {
    HP: [75, 150], 'HP%': [5, 8], ATK: [75, 150], 'ATK%': [5, 8],
    SPD: [5, 10], 'DMG%': [10, 20], 'Crit Rate': [5, 15], 'Crit Damage': [25, 75]
  },
  rare: {
    HP: [250, 500], 'HP%': [8, 10], ATK: [250, 500], 'ATK%': [8, 10],
    SPD: [10, 15], 'DMG%': [20, 30], 'Crit Rate': [5, 20], 'Crit Damage': [50, 100]
  },
  epic: {
    HP: [500, 1000], 'HP%': [10, 15], ATK: [500, 1000], 'ATK%': [10, 15],
    SPD: [15, 20], 'DMG%': [30, 50], 'Crit Rate': [5, 25], 'Crit Damage': [75, 150]
  },
  legendary: {
    HP: [1250, 2500], 'HP%': [15, 25], ATK: [1250, 2500], 'ATK%': [15, 25],
    SPD: [20, 25], 'DMG%': [50, 75], 'Crit Rate': [5, 30], 'Crit Damage': [100, 200]
  },
  mythic: {
    HP: [2500, 5000], 'HP%': [25, 35], ATK: [2500, 5000], 'ATK%': [25, 35],
    SPD: [25, 35], 'DMG%': [75, 100], 'Crit Rate': [5, 35], 'Crit Damage': [100, 250]
  },
  divine: {
    HP: [5000, 10000], 'HP%': [35, 50], ATK: [5000, 10000], 'ATK%': [35, 50],
    SPD: [35, 50], 'DMG%': [100, 150], 'Crit Rate': [10, 50], 'Crit Damage': [150, 350]
  }
};

const AFFIX_POOL = [
  { name: 'HP', weight: 50 },
  { name: 'HP%', weight: 50 },
  { name: 'ATK', weight: 50 },
  { name: 'ATK%', weight: 50 },
  { name: 'SPD', weight: 35 },
  { name: 'DMG%', weight: 35 },
  { name: 'Crit Rate', weight: 15 },
  { name: 'Crit Damage', weight: 15 }
];


// ========== ENCHANTMENT SYSTEM ==========

// Enchantment color
const ENCHANTMENT_COLOR = '#a855f7'; // Purple color for enchantments

// Enchantment definitions with slot restrictions
const ENCHANTMENTS = {
  // Weapon-only enchantments
  flame: {
    name: 'Flame',
    slots: ['weapon'],
    description: 'Each attack deals 125% Fire DMG over 2s, 20% chance to summon fireball (250% Fire DMG AoE)',
    color: ENCHANTMENT_COLOR
  },
  thunder: {
    name: 'Thunder',
    slots: ['weapon'],
    description: 'Each attack deals 125% Lightning DMG, 50% chain to 2nd enemy (100%), 25% to 3rd (75%)',
    color: ENCHANTMENT_COLOR
  },
  wind_burst: {
    name: 'Wind Burst',
    slots: ['weapon'],
    description: 'Each attack deals 125% Wind DMG, pushback enemy. Death creates 250% Wind AoE',
    color: ENCHANTMENT_COLOR
  },
  freeze: {
    name: 'Freeze',
    slots: ['weapon'],
    description: 'Each attack deals 125% Cryo DMG and freezes enemy for 3s',
    color: ENCHANTMENT_COLOR
  },
  rage: {
    name: 'Rage',
    slots: ['weapon'],
    description: 'Each attack deals 125% Physical DMG + 250% AoE (20% HP). <50% HP: +50% SPD, +200% Physical DMG',
    color: ENCHANTMENT_COLOR
  },
  star_burst: {
    name: 'Star Burst',
    slots: ['weapon'],
    description: 'Each attack deals 125% Aether DMG, summons 2 stars that shoot at enemies (75% DMG)',
    color: ENCHANTMENT_COLOR
  },
  
  // Ring/Weapon enchantments
  spellcaster: {
    name: 'Spellcaster',
    slots: ['ring', 'weapon'],
    description: 'Summon random element AoE on enemy (125% DMG/tick for 3s)',
    color: ENCHANTMENT_COLOR
  },
  bounty_hunter: {
    name: 'Bounty Hunter',
    slots: ['ring', 'weapon'],
    description: 'Every 30s, mark enemy (20x HP). Defeat for 10x coins + damage rain (125% Physical DMG)',
    color: ENCHANTMENT_COLOR
  },
  scepter_spawner: {
    name: 'Scepter Spawner',
    slots: ['ring', 'weapon'],
    description: 'Every 30s, launch 3 balls that hover around enemies (125% Aether DMG for 3s)',
    color: ENCHANTMENT_COLOR
  },
  multishot: {
    name: 'Multishot',
    slots: ['ring', 'weapon'],
    description: 'Every 30s, hit 3 enemies (125% Physical), bounce 2 coins 3x (7.7% of total coins)',
    color: ENCHANTMENT_COLOR
  },
  strength: {
    name: 'Strength',
    slots: ['ring', 'weapon'],
    description: '+200% ATK',
    color: ENCHANTMENT_COLOR
  },
  damage_boost: {
    name: 'Damage Boost',
    slots: ['ring', 'weapon'],
    description: '+150% DMG',
    color: ENCHANTMENT_COLOR
  },
  elemental_boost: {
    name: 'Elemental Boost',
    slots: ['ring', 'weapon'],
    description: '+120% Elemental DMG',
    color: ENCHANTMENT_COLOR
  },
  
  // Armor-only enchantments
  hp_boost: {
    name: 'HP Boost',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: '+150% HP',
    color: ENCHANTMENT_COLOR
  },
  spd_boost: {
    name: 'SPD Boost',
    slots: ['boots'],
    description: '+50% Speed',
    color: ENCHANTMENT_COLOR
  },
  protection: {
    name: 'Protection',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: 'Reduce damage taken by 20%',
    color: ENCHANTMENT_COLOR
  },
  thorns: {
    name: 'Thorns',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: 'When hit, deal 125% Poison DMG back to attacker',
    color: ENCHANTMENT_COLOR
  },
  shock: {
    name: 'Shock',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: 'When hit, deal 125% Lightning DMG back, 50% chain to 2nd (100%), 25% to 3rd (75%)',
    color: ENCHANTMENT_COLOR
  },
  burn: {
    name: 'Burn',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: 'When hit, deal 125% Fire DMG back + 125% Fire DMG over 2s',
    color: ENCHANTMENT_COLOR
  },
  fortune: {
    name: 'Fortune',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: '+200% Coin gain',
    color: ENCHANTMENT_COLOR
  },
  expert_hunter: {
    name: 'Expert Hunter',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: '+200% EXP gain',
    color: ENCHANTMENT_COLOR
  },
  luck: {
    name: 'Luck',
    slots: ['helmet', 'chestplate', 'leggings', 'boots'],
    description: 'Increase drop chance, coin gain, and higher rarity items',
    color: ENCHANTMENT_COLOR
  }
};

// Get enchantments available for a specific slot
function getEnchantmentsForSlot(slot) {
  return Object.keys(ENCHANTMENTS).filter(key => {
    return ENCHANTMENTS[key].slots.includes(slot);
  });
}

// Get random enchantment for a slot
function getRandomEnchantment(slot) {
  const available = getEnchantmentsForSlot(slot);
  if (available.length === 0) return null;
  return available[Math.floor(Math.random() * available.length)];
}

// Initialize enchantment slots on item (called when creating new item)
function initializeEnchantmentSlots(item) {
  if (item.type !== 'equipment') return;
  
  item.enchantments = [
    { id: getRandomEnchantment(item.slot), locked: true, unlockCost: 100 },
    { id: getRandomEnchantment(item.slot), locked: true, unlockCost: 200 },
    { id: getRandomEnchantment(item.slot), locked: true, unlockCost: 300 }
  ];
}

// Check if item has any unlocked enchantments
function hasUnlockedEnchantments(item) {
  if (!item.enchantments) return false;
  return item.enchantments.some(e => !e.locked);
}

// Unlock enchantment slot
function unlockEnchantment(itemId, slotIndex) {
  const item = findItemById(itemId);
  if (!item || !item.enchantments) return false;
  
  const enchSlot = item.enchantments[slotIndex];
  if (!enchSlot || !enchSlot.locked) return false;
  
  const cost = enchSlot.unlockCost;
  if (GameState.player.gems < cost) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return false;
  }
  
  GameState.player.gems -= cost;
  showFloatingChange(-cost, 'gems');
  enchSlot.locked = false;
  
  showNotification(`âœ¨ Unlocked enchantment: ${ENCHANTMENTS[enchSlot.id].name}!`, 'success');
  renderInventory();
  renderPlayerStats();
  computeDerivedStats();
  
  // Update tooltip if currently shown
  const tooltip = document.getElementById('inventory-tooltip');
  if (tooltip.dataset.currentItemId === itemId) {
    const targetEl = document.querySelector(`[data-item-id="${itemId}"]`);
    if (targetEl) {
      const isEquipped = tooltip.dataset.isEquipped === 'true';
      showItemTooltip(item, targetEl, isEquipped);
    }
  }
  
  return true;
}

// Reroll enchantment
function rerollEnchantment(itemId, slotIndex) {
  const item = findItemById(itemId);
  if (!item || !item.enchantments) return false;
  
  const enchSlot = item.enchantments[slotIndex];
  if (!enchSlot || enchSlot.locked) return false;
  
  const rerollCost = 100;
  if (GameState.player.gems < rerollCost) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return false;
  }
  
  GameState.player.gems -= rerollCost;
  showFloatingChange(-rerollCost, 'gems');
  
  // Get new random enchantment for this slot
  const oldEnchId = enchSlot.id;
  let newEnchId = getRandomEnchantment(item.slot);
  
  // Try to avoid getting the same enchantment
  const available = getEnchantmentsForSlot(item.slot);
  if (available.length > 1) {
    let attempts = 0;
    while (newEnchId === oldEnchId && attempts < 10) {
      newEnchId = getRandomEnchantment(item.slot);
      attempts++;
    }
  }
  
  enchSlot.id = newEnchId;
  
  showNotification(`ðŸ”„ Rerolled to: ${ENCHANTMENTS[newEnchId].name}!`, 'info');
  renderInventory();
  renderPlayerStats();
  computeDerivedStats();
  
  // Update tooltip if currently shown
  const tooltip = document.getElementById('inventory-tooltip');
  if (tooltip.dataset.currentItemId === itemId) {
    const targetEl = document.querySelector(`[data-item-id="${itemId}"]`);
    if (targetEl) {
      const isEquipped = tooltip.dataset.isEquipped === 'true';
      showItemTooltip(item, targetEl, isEquipped);
    }
  }
  
  return true;
}

// Helper to find item by ID
function findItemById(itemId) {
  const p = GameState.player;
  
  // Check equipped items
  for (const slot in p.equipment) {
    if (p.equipment[slot] && p.equipment[slot].id === itemId) {
      return p.equipment[slot];
    }
  }
  
  // Check inventory
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (p.inventory[i] && p.inventory[i].id === itemId) {
      return p.inventory[i];
    }
  }
  
  return null;
}

// Get all active enchantments from equipped items
function getActiveEnchantments() {
  const p = GameState.player;
  const activeEnchantments = [];
  
  for (const slot in p.equipment) {
    const item = p.equipment[slot];
    if (item && item.enchantments) {
      item.enchantments.forEach(ench => {
        if (!ench.locked && ench.id) {
          activeEnchantments.push({
            id: ench.id,
            slot: item.slot,
            data: ENCHANTMENTS[ench.id]
          });
        }
      });
    }
  }
  
  return activeEnchantments;
}

// Check if specific enchantment is active
function hasEnchantment(enchantmentId) {
  const active = getActiveEnchantments();
  return active.some(e => e.id === enchantmentId);
}

// Count how many of a specific enchantment are active
function countEnchantment(enchantmentId) {
  const active = getActiveEnchantments();
  return active.filter(e => e.id === enchantmentId).length;
}


// ========== ENCHANTMENT EFFECT IMPLEMENTATIONS ==========

// Track enchantment timers
if (!GameState.enchantmentTimers) {
  GameState.enchantmentTimers = {};
}

// Apply on-hit weapon enchantments
function applyWeaponEnchantments(enemy, baseDamage) {
  const activeEnchantments = getActiveEnchantments();
  const weaponEnchantments = activeEnchantments.filter(e => 
    ['flame', 'thunder', 'wind_burst', 'freeze', 'rage', 'star_burst'].includes(e.id)
  );
  
  weaponEnchantments.forEach(ench => {
    switch(ench.id) {
      case 'flame':
        applyFlameEnchantment(enemy, baseDamage);
        break;
      case 'thunder':
        applyThunderEnchantment(enemy, baseDamage);
        break;
      case 'wind_burst':
        applyWindBurstEnchantment(enemy, baseDamage);
        break;
      case 'freeze':
        applyFreezeEnchantment(enemy, baseDamage);
        break;
      case 'rage':
        applyRageEnchantment(enemy, baseDamage);
        break;
      case 'star_burst':
        applyStarBurstEnchantment(enemy, baseDamage);
        break;
    }
  });
}

// Flame enchantment
function applyFlameEnchantment(enemy, baseDamage) {
  const damage = Math.floor(baseDamage * 1.25);
  
  // Apply burn DoT
  if (!enemy.enchantBurns) enemy.enchantBurns = [];
  enemy.enchantBurns.push({
    damage: damage,
    duration: 2,
    tickRate: 0.2,
    elapsed: 0
  });
  
  // 20% chance for fireball
  if (Math.random() < 0.20) {
    const fireballDamage = Math.floor(baseDamage * 2.5);
    setTimeout(() => {
      if (enemy.hp > 0) {
        spawnAoE(enemy.position.x, enemy.position.y, 80, fireballDamage, 'fire', { source: 'flame_enchant' });
      }
    }, 200);
  }
}

// Thunder enchantment
function applyThunderEnchantment(enemy, baseDamage) {
  const damage = Math.floor(baseDamage * 1.25);
  applyDamageToEnemy(enemy, damage, { type: 'lightning', source: 'thunder_enchant' });
  
  // 50% chance to chain
  if (Math.random() < 0.50) {
    const nearbyEnemies = GameState.enemies.filter(e => 
      e.id !== enemy.id && e.hp > 0
    );
    if (nearbyEnemies.length > 0) {
      const target2 = nearbyEnemies[Math.floor(Math.random() * nearbyEnemies.length)];
      const damage2 = Math.floor(baseDamage * 1.0);
      
      // Visual chain
      createLightningChain(enemy, target2);
      setTimeout(() => {
        applyDamageToEnemy(target2, damage2, { type: 'lightning', source: 'thunder_chain' });
        
        // 25% chance for 3rd chain
        if (Math.random() < 0.25) {
          const available3 = GameState.enemies.filter(e =>
            e.id !== enemy.id && e.id !== target2.id && e.hp > 0
          );
          if (available3.length > 0) {
            const target3 = available3[Math.floor(Math.random() * available3.length)];
            const damage3 = Math.floor(baseDamage * 0.75);
            createLightningChain(target2, target3);
            setTimeout(() => {
              applyDamageToEnemy(target3, damage3, { type: 'lightning', source: 'thunder_chain' });
            }, 150);
          }
        }
      }, 150);
    }
  }
}

// Wind Burst enchantment
function applyWindBurstEnchantment(enemy, baseDamage) {
  const damage = Math.floor(baseDamage * 1.25);
  applyDamageToEnemy(enemy, damage, { type: 'wind', source: 'wind_burst_enchant' });
  
  // Pushback effect
  const dx = enemy.position.x - (document.getElementById('stage').clientWidth / 2);
  const dy = enemy.position.y - (document.getElementById('stage').clientHeight / 2);
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > 0) {
    const pushDistance = 30;
    enemy.position.x += (dx / dist) * pushDistance;
    enemy.position.y += (dy / dist) * pushDistance;
  }
  
  // Mark for explosion on death
  enemy.windBurstMarked = true;
  enemy.windBurstDamage = Math.floor(baseDamage * 2.5);
}

// Freeze enchantment
function applyFreezeEnchantment(enemy, baseDamage) {
  const damage = Math.floor(baseDamage * 1.25);
  applyDamageToEnemy(enemy, damage, { type: 'cryo', source: 'freeze_enchant' });
  
  // Apply freeze (unless on cooldown)
  const now = Date.now();
  if (!enemy.freezeCooldownUntil || now >= enemy.freezeCooldownUntil) {
    enemy.frozen = true;
    enemy.frozenTimer = 3.0;
    enemy.originalSpeed = enemy.speed;
    enemy.speed = 0;
    
    // Set cooldown
    enemy.freezeCooldownUntil = now + 5000;
  }
}

// Rage enchantment
function applyRageEnchantment(enemy, baseDamage) {
  const damage = Math.floor(baseDamage * 1.25);
  applyDamageToEnemy(enemy, damage, { type: 'physical', source: 'rage_enchant' });
  
  // AoE based on player HP
  const p = GameState.player;
  const aoeDamage = Math.floor((p.currentStats?.finalHP || p.HP) * 0.20 * 2.5);
  spawnAoE(enemy.position.x, enemy.position.y, 100, aoeDamage, 'physical', { source: 'rage_aoe' });
}

// Star Burst enchantment
function applyStarBurstEnchantment(enemy, baseDamage) {
  const damage = Math.floor(baseDamage * 1.25);
  applyDamageToEnemy(enemy, damage, { type: 'aether', source: 'star_burst_enchant' });
  
  // Summon 2 stars
  for (let i = 0; i < 2; i++) {
    setTimeout(() => {
      summonStar(baseDamage);
    }, i * 100);
  }
}

function summonStar(baseDamage) {
  const randomEnemy = GameState.enemies[Math.floor(Math.random() * GameState.enemies.length)];
  if (!randomEnemy || randomEnemy.hp <= 0) return;
  
  const starDamage = Math.floor(baseDamage * 0.75);
  const stage = document.getElementById('stage');
  const startX = stage.clientWidth / 2;
  const startY = stage.clientHeight / 2;
  
  // Create star projectile
  const star = document.createElement('div');
  star.style.position = 'absolute';
  star.style.width = '20px';
  star.style.height = '20px';
  star.style.background = 'radial-gradient(circle, #fff8c2, #f4cf57)';
  star.style.borderRadius = '50%';
  star.style.boxShadow = '0 0 10px #fff8c2';
  star.style.left = startX + 'px';
  star.style.top = startY + 'px';
  star.style.zIndex = '100';
  star.textContent = 'â­';
  star.style.fontSize = '16px';
  star.style.display = 'flex';
  star.style.alignItems = 'center';
  star.style.justifyContent = 'center';
  stage.appendChild(star);
  
  // Animate to enemy
  const duration = 500;
  const startTime = Date.now();
  
  function animateStar() {
    const now = Date.now();
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    if (randomEnemy.hp <= 0 || progress >= 1) {
      if (randomEnemy.hp > 0) {
        applyDamageToEnemy(randomEnemy, starDamage, { type: 'aether', source: 'star_burst_star' });
      }
      star.remove();
      return;
    }
    
    const x = startX + (randomEnemy.position.x - startX) * progress;
    const y = startY + (randomEnemy.position.y - startY) * progress;
    star.style.left = x + 'px';
    star.style.top = y + 'px';
    
    requestAnimationFrame(animateStar);
  }
  
  animateStar();
}

// Process burn DoT from flame enchantment
function processEnchantmentBurns(dt) {
  GameState.enemies.forEach(enemy => {
    if (!enemy.enchantBurns || enemy.enchantBurns.length === 0) return;
    
    enemy.enchantBurns = enemy.enchantBurns.filter(burn => {
      burn.elapsed += dt;
      
      if (burn.elapsed >= burn.tickRate) {
        const tickDamage = Math.floor(burn.damage / (burn.duration / burn.tickRate));
        applyDamageToEnemy(enemy, tickDamage, { type: 'fire', source: 'flame_burn' });
        burn.elapsed = 0;
      }
      
      burn.duration -= dt;
      return burn.duration > 0;
    });
  });
}

// Update rage enchantment bonus
function updateRageEnchantmentBonus() {
  const hasRage = hasEnchantment('rage');
  const p = GameState.player;
  
  if (hasRage && (p.currentStats?.finalHP || p.HP) < (p.currentStats?.maxHP || p.HP) * 0.5) {
    if (!p.rageEnchantActive) {
      p.rageEnchantActive = true;
      computeDerivedStats(); // Recalculate with bonus
    }
  } else if (p.rageEnchantActive) {
    p.rageEnchantActive = false;
    computeDerivedStats();
  }
}

// Timed enchantments (Spellcaster, Bounty Hunter, Scepter Spawner, Multishot)
function updateTimedEnchantments(dt) {
  const now = Date.now();
  
  // Spellcaster
  if (hasEnchantment('spellcaster')) {
    if (!GameState.enchantmentTimers.spellcaster || now >= GameState.enchantmentTimers.spellcaster) {
      triggerSpellcaster();
      GameState.enchantmentTimers.spellcaster = now + 30000;
    }
  }
  
  // Bounty Hunter
  if (hasEnchantment('bounty_hunter')) {
    if (!GameState.enchantmentTimers.bounty_hunter || now >= GameState.enchantmentTimers.bounty_hunter) {
      triggerBountyHunter();
      GameState.enchantmentTimers.bounty_hunter = now + 30000;
    }
  }
  
  // Scepter Spawner
  if (hasEnchantment('scepter_spawner')) {
    if (!GameState.enchantmentTimers.scepter_spawner || now >= GameState.enchantmentTimers.scepter_spawner) {
      triggerScepterSpawner();
      GameState.enchantmentTimers.scepter_spawner = now + 30000;
    }
  }
  
  // Multishot
  if (hasEnchantment('multishot')) {
    if (!GameState.enchantmentTimers.multishot || now >= GameState.enchantmentTimers.multishot) {
      triggerMultishot();
      GameState.enchantmentTimers.multishot = now + 30000;
    }
  }
}

function triggerSpellcaster() {
  if (GameState.enemies.length === 0) return;
  
  const randomEnemy = GameState.enemies[Math.floor(Math.random() * GameState.enemies.length)];
  const elements = ['fire', 'lightning', 'wind', 'cryo', 'physical', 'aether'];
  const element = elements[Math.floor(Math.random() * elements.length)];
  const baseDamage = GameState.player.currentStats?.finalATK || GameState.player.ATK;
  const damage = Math.floor(baseDamage * 1.25);
  
  // Create AoE that persists for 3 seconds
  const aoeDuration = 3000;
  const tickRate = 200;
  const startTime = Date.now();
  
  const interval = setInterval(() => {
    if (Date.now() - startTime >= aoeDuration) {
      clearInterval(interval);
      return;
    }
    
    // Find enemies in area
    const enemiesInArea = findEnemiesInRadius(randomEnemy.position.x, randomEnemy.position.y, 80);
    enemiesInArea.forEach(e => {
      if (e.hp > 0) {
        const tickDamage = Math.floor(damage / (aoeDuration / tickRate));
        applyDamageToEnemy(e, tickDamage, { type: element, source: 'spellcaster_aoe' });
      }
    });
  }, tickRate);
  
  // Visual effect
  spawnShockwave(randomEnemy.position.x, randomEnemy.position.y, 80, getElementColor(element), aoeDuration);
}

function triggerBountyHunter() {
  if (GameState.enemies.length === 0) return;
  
  const randomEnemy = GameState.enemies[Math.floor(Math.random() * GameState.enemies.length)];
  
  // Mark as bounty target
  randomEnemy.bountyTarget = true;
  randomEnemy.originalMaxHp = randomEnemy.maxHp;
  randomEnemy.maxHp *= 20;
  randomEnemy.hp = Math.min(randomEnemy.hp * 20, randomEnemy.maxHp);
  
  // Visual indicator
  const enemyEl = document.querySelector(`[data-enemy-id="${randomEnemy.id}"]`);
  if (enemyEl) {
    enemyEl.style.border = '3px solid gold';
    enemyEl.style.boxShadow = '0 0 20px gold';
  }
  
  showNotification('ðŸŽ¯ Bounty target marked!', 'legendary');
}

function triggerScepterSpawner() {
  if (GameState.enemies.length === 0) return;
  
  const baseDamage = GameState.player.currentStats?.finalATK || GameState.player.ATK;
  const damage = Math.floor(baseDamage * 1.25);
  
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      spawnScepterBall(damage);
    }, i * 150);
  }
}

function spawnScepterBall(damage) {
  const stage = document.getElementById('stage');
  const centerX = stage.clientWidth / 2;
  const centerY = stage.clientHeight / 2;
  
  const ball = document.createElement('div');
  ball.style.position = 'absolute';
  ball.style.width = '16px';
  ball.style.height = '16px';
  ball.style.background = 'radial-gradient(circle, #fff8c2, #d4af37)';
  ball.style.borderRadius = '50%';
  ball.style.boxShadow = '0 0 8px #fff8c2';
  ball.style.zIndex = '100';
  stage.appendChild(ball);
  
  const startTime = Date.now();
  const duration = 3000;
  let angle = Math.random() * Math.PI * 2;
  const radius = 60;
  
  function animateBall() {
    const elapsed = Date.now() - startTime;
    if (elapsed >= duration) {
      ball.remove();
      return;
    }
    
    angle += 0.05;
    const x = centerX + Math.cos(angle) * radius;
    const y = centerY + Math.sin(angle) * radius;
    ball.style.left = x + 'px';
    ball.style.top = y + 'px';
    
    // Check collision with enemies
    GameState.enemies.forEach(enemy => {
      if (enemy.hp <= 0) return;
      const dx = enemy.position.x - x;
      const dy = enemy.position.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 40) {
        applyDamageToEnemy(enemy, damage, { type: 'aether', source: 'scepter_ball' });
      }
    });
    
    requestAnimationFrame(animateBall);
  }
  
  animateBall();
}

function triggerMultishot() {
  if (GameState.enemies.length === 0) return;
  
  const baseDamage = GameState.player.currentStats?.finalATK || GameState.player.ATK;
  const damage = Math.floor(baseDamage * 1.25);
  
  // Hit 3 random enemies
  const targets = [];
  for (let i = 0; i < Math.min(3, GameState.enemies.length); i++) {
    let enemy = GameState.enemies[Math.floor(Math.random() * GameState.enemies.length)];
    let attempts = 0;
    while (targets.includes(enemy) && attempts < 10) {
      enemy = GameState.enemies[Math.floor(Math.random() * GameState.enemies.length)];
      attempts++;
    }
    targets.push(enemy);
    applyDamageToEnemy(enemy, damage, { type: 'physical', source: 'multishot' });
  }
  
  // Bounce coins
  const coinDamage = Math.floor(GameState.player.coins * 0.077);
  let currentTargets = [...targets];
  
  for (let bounce = 0; bounce < 3; bounce++) {
    setTimeout(() => {
      const newTargets = [];
      for (let i = 0; i < 2; i++) {
        if (GameState.enemies.length === 0) break;
        const enemy = GameState.enemies[Math.floor(Math.random() * GameState.enemies.length)];
        newTargets.push(enemy);
        applyDamageToEnemy(enemy, coinDamage, { type: 'physical', source: 'multishot_coin', customColor: '#ffd700' });
      }
      currentTargets = newTargets;
    }, (bounce + 1) * 300);
  }
}

// Apply armor enchantments when player takes damage
function applyArmorEnchantments(attacker, damageDealt) {
  const activeEnchantments = getActiveEnchantments();
  const armorEnchantments = activeEnchantments.filter(e =>
    ['thorns', 'shock', 'burn'].includes(e.id)
  );
  
  armorEnchantments.forEach(ench => {
    const baseDamage = GameState.player.currentStats?.finalATK || GameState.player.ATK;
    const damage = Math.floor(baseDamage * 1.25);
    
    switch(ench.id) {
      case 'thorns':
        applyDamageToEnemy(attacker, damage, { type: 'poison', source: 'thorns_enchant' });
        break;
      case 'shock':
        applyThunderEnchantment(attacker, baseDamage);
        break;
      case 'burn':
        applyDamageToEnemy(attacker, damage, { type: 'fire', source: 'burn_enchant' });
        if (!attacker.enchantBurns) attacker.enchantBurns = [];
        attacker.enchantBurns.push({
          damage: damage,
          duration: 2,
          tickRate: 0.2,
          elapsed: 0
        });
        break;
    }
  });
}

// Helper to create lightning chain visual
function createLightningChain(from, to) {
  // Visual effect only
  const stage = document.getElementById('stage');
  const line = document.createElement('div');
  line.style.position = 'absolute';
  line.style.height = '2px';
  line.style.background = 'linear-gradient(90deg, #9b59b6, #fff)';
  line.style.boxShadow = '0 0 8px #9b59b6';
  line.style.zIndex = '90';
  line.style.transformOrigin = 'left center';
  
  const dx = to.position.x - from.position.x;
  const dy = to.position.y - from.position.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);
  
  line.style.left = from.position.x + 'px';
  line.style.top = from.position.y + 'px';
  line.style.width = dist + 'px';
  line.style.transform = `rotate(${angle}rad)`;
  
  stage.appendChild(line);
  setTimeout(() => line.remove(), 200);
}



function generateEquipment(slot, rarity, world, setId = null) {
  // Use BASE_STAT_RANGES for base attributes and AFFIX_RANGES for affixes

  // If setId provided, generate set item
  if (setId && EQUIPMENT_SETS[setId]) {
    const setData = EQUIPMENT_SETS[setId];
    if (!setData) {
      console.warn(`Invalid setId "${setId}" in generateEquipment, falling back to normal item`);
      setId = null;
    } else {
    const setItem = setData.items[slot];

    if (setItem) {
      const item = {
        id: `item_${GameState.itemIdCounter++}`,
        type: 'equipment',
        slot: setItem.slot,
        name: setItem.name,
        icon: setItem.icon,
        rarity: rarity,
        level: 1,
        stars: 0,
        setId: setId,
        setName: setData.name,
        element: setData.element,
        baseAttribute: { name: slot === 'helmet' || slot === 'weapon' ? 'ATK' : slot === 'boots' ? 'SPD' : slot === 'ring' ? 'DMG%' : 'HP', value: 0 },
        affixes: [],
        buyPrice: 0,
        sellPrice: 0,
        createdAtWorld: world
      };

      // Generate base attribute value
      const baseAttrName = item.baseAttribute.name;
      const baseRange = BASE_STAT_RANGES[item.rarity][baseAttrName];
      item.baseAttribute.value = GameState.rng.randInt(baseRange[0], baseRange[1]);
      item.initialBaseValue = item.baseAttribute.value; // Store initial value for level scaling

      // Initialize enchantment slots
      initializeEnchantmentSlots(item);
      
      // Generate affixes
      const availableAffixes = [...AFFIX_POOL];
      for (let i = 0; i < 4; i++) {
        const weights = availableAffixes.map(a => a.weight);
        const chosenAffix = GameState.rng.weightedChoice(availableAffixes, weights);
        const idx = availableAffixes.indexOf(chosenAffix);
        availableAffixes.splice(idx, 1);

        const range = AFFIX_RANGES[rarity][chosenAffix.name];
        const value = GameState.rng.randInt(range[0], range[1]);
        const unlockLevel = (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS[i] !== undefined)
          ? CONFIG.STAR_THRESHOLDS[i]
          : (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS.length
              ? CONFIG.STAR_THRESHOLDS[CONFIG.STAR_THRESHOLDS.length - 1] + (i - (CONFIG.STAR_THRESHOLDS.length - 1)) * 10
              : 10 + i * 10);

        item.affixes.push({
          name: chosenAffix.name,
          value: value,
          locked: true,
          unlockLevel: unlockLevel
        });
      }

      // Set weapon properties
      if (setItem.isWeapon && setItem.multiplier) {
        item.isWeapon = true;
        item.weaponMultiplier = setItem.multiplier;
      }

      // Calculate prices (set items are more expensive)
      item.buyPrice = Math.floor(CONFIG.BASE_SHOP_PRICE[rarity] * 1.5 * (1 + world * 0.1) * GameState.rng.randRange(0.9, 1.1));
      item.sellPrice = Math.floor(item.buyPrice * 0.3);

      return item;
    }
    }
  }

  // Original random equipment generation
  let baseAttrName;
  if (slot === 'helmet') baseAttrName = 'ATK';
  else if (slot === 'chestplate') baseAttrName = 'HP';
  else if (slot === 'leggings') baseAttrName = 'HP';
  else if (slot === 'boots') baseAttrName = 'SPD';
  else if (slot === 'ring') baseAttrName = 'DMG%';
  else if (slot === 'weapon') baseAttrName = 'ATK';

  const baseRange = BASE_STAT_RANGES[rarity][baseAttrName];
  const baseValue = GameState.rng.randInt(baseRange[0], baseRange[1]);

  const affixes = [];
  const availableAffixes = [...AFFIX_POOL];
  for (let i = 0; i < 4; i++) {
    const weights = availableAffixes.map(a => a.weight);
    const chosenAffix = GameState.rng.weightedChoice(availableAffixes, weights);
    const idx = availableAffixes.indexOf(chosenAffix);
    availableAffixes.splice(idx, 1);

    const range = AFFIX_RANGES[rarity][chosenAffix.name];
    const value = GameState.rng.randInt(range[0], range[1]);
    const unlockLevel = (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS[i] !== undefined)
      ? CONFIG.STAR_THRESHOLDS[i]
      : (CONFIG.STAR_THRESHOLDS && CONFIG.STAR_THRESHOLDS.length
          ? CONFIG.STAR_THRESHOLDS[CONFIG.STAR_THRESHOLDS.length - 1] + (i - (CONFIG.STAR_THRESHOLDS.length - 1)) * 10
          : 10 + i * 10);

    affixes.push({
      name: chosenAffix.name,
      value: value,
      locked: true,
      unlockLevel: unlockLevel
    });
  }

  const buyPrice = Math.floor(CONFIG.BASE_SHOP_PRICE[rarity] * (1 + world * 0.1) * GameState.rng.randRange(0.9, 1.1));
  const sellPrice = Math.floor(buyPrice * 0.3);

  return {
    id: `item_${GameState.itemIdCounter++}`,
    type: 'equipment',
    slot: slot,
    name: `${rarity.charAt(0).toUpperCase() + rarity.slice(1)} ${slot.charAt(0).toUpperCase() + slot.slice(1)}`,
    rarity: rarity,
    level: 1,
    stars: 0,
    baseAttribute: { name: baseAttrName, value: baseValue },
    initialBaseValue: baseValue, // Store initial value for level scaling
    affixes: affixes,
    buyPrice: buyPrice,
    sellPrice: sellPrice,
    createdAtWorld: world
  };
}

function rollRarity() {
  const probs = CONFIG.RARITY_PROB;
  const total = Object.values(probs).reduce((sum, p) => sum + p, 0);
  const r = GameState.rng.rand() * total;

  let cumulative = 0;
  for (const [rarity, prob] of Object.entries(probs)) {
    cumulative += prob;
    if (r <= cumulative) return rarity;
  }
  return 'common';
}

// ========== Enemy Creation ==========
// ========== Enemy Categories ==========
// Enemies are organized by size/threat level categories
// Each category unlocks at different world thresholds
const ENEMY_CATEGORIES = {
  SMALL: {
    types: ['small', 'assassin'],
    unlockWorlds: {
      'small': 1,      // Available from World 1
      'assassin': 3    // Unlocks at World 3
    }
  },
  NORMAL: {
    types: ['normal', 'tank', 'ranger', 'mage'],
    unlockWorlds: {
      'normal': 1,     // Available from World 1
      'ranger': 3,     // Unlocks at World 3
      'tank': 6,       // Unlocks at World 6
      'mage': 9        // Unlocks at World 9
    }
  },
  BIG: {
    types: ['big', 'necromancer'],
    unlockWorlds: {
      'big': 1,          // Available from World 1
      'necromancer': 9   // Unlocks at World 9
    }
  },
  ELITE: {
    types: ['elite', 'berserker', 'paladin', 'demon'],
    unlockWorlds: {
      'elite': 1,      // Available from World 1
      'berserker': 6,  // Unlocks at World 6
      'paladin': 12,   // Unlocks at World 12
      'demon': 12      // Unlocks at World 12
    }
  },
  BOSS: {
    types: ['boss', 'archboss'],
    unlockWorlds: {
      'boss': 1,       // Available from World 1
      'archboss': 12   // Unlocks at World 12
    }
  }
};

// Helper function to get available enemy types for a given category and world
function getAvailableEnemyTypes(category, world) {
  const categoryData = ENEMY_CATEGORIES[category];
  if (!categoryData) return [];
  
  return categoryData.types.filter(type => {
    const unlockWorld = categoryData.unlockWorlds[type];
    return world >= unlockWorld;
  });
}

const ENEMY_BASE_HP = { 
  small: 120, normal: 360, big: 600, elite: 1000, boss: 6000,
  // Categorized new enemies
  assassin: 180,      // small category
  tank: 800,          // normal category
  ranger: 320,        // normal category
  mage: 500,          // normal category
  necromancer: 700,   // big category
  berserker: 750,     // elite category
  paladin: 1100,      // elite category
  demon: 1400,        // elite category
  archboss: 8000      // boss category
};
const ENEMY_BASE_ATK = { 
  small: 1, normal: 3, big: 6, elite: 10, boss: 30,
  // Categorized new enemies
  assassin: 8,        // small category
  tank: 4,            // normal category
  ranger: 5,          // normal category
  mage: 15,           // normal category
  necromancer: 18,    // big category
  berserker: 12,      // elite category
  paladin: 14,        // elite category
  demon: 22,          // elite category
  archboss: 50        // boss category
};
const ENEMY_BASE_RESIST = { 
  small: 0, normal: 2, big: 5, elite: 8, boss: 10,
  // Categorized new enemies
  assassin: 3,        // small category
  tank: 12,           // normal category
  ranger: 4,          // normal category
  mage: 10,           // normal category
  necromancer: 15,    // big category
  berserker: 6,       // elite category
  paladin: 18,        // elite category
  demon: 20,          // elite category
  archboss: 25        // boss category
};
const ENEMY_ATTACK_INTERVAL = { 
  small: 3.0, normal: 3.5, big: 4.5, elite: 3.0, boss: 2.5,
  // Categorized new enemies
  assassin: 2.0,      // small category
  tank: 5.0,          // normal category
  ranger: 4.0,        // normal category
  mage: 3.5,          // normal category
  necromancer: 4.0,   // big category
  berserker: 2.8,     // elite category
  paladin: 3.2,       // elite category
  demon: 2.2,         // elite category
  archboss: 2.0       // boss category
};
const ENEMY_BASE_EXP = { 
  small: 5, normal: 10, big: 25, elite: 50, boss: 100,
  // Categorized new enemies
  assassin: 8,        // small category
  tank: 12,           // normal category
  ranger: 10,         // normal category
  mage: 15,           // normal category
  necromancer: 30,    // big category
  berserker: 55,      // elite category
  paladin: 65,        // elite category
  demon: 80,          // elite category
  archboss: 150       // boss category
};
const ENEMY_ICONS = { 
  small: 'ðŸ€', normal: 'ðŸ§Ÿ', big: 'ðŸ‘¹', elite: 'ðŸ‘¿', boss: 'ðŸ‰',
  // Categorized new enemies
  assassin: 'ðŸ—¡ï¸',     // small category
  tank: 'ðŸ›¡ï¸',         // normal category
  ranger: 'ðŸ¹',       // normal category
  mage: 'ðŸ”®',         // normal category
  necromancer: 'ðŸ’€',  // big category
  berserker: 'âš”ï¸',    // elite category
  paladin: 'âšœï¸',      // elite category
  demon: 'ðŸ˜ˆ',        // elite category
  archboss: 'ðŸ‘‘'      // boss category
};

function createEnemy(type, world, position) {
  // Progressive scaling - starts easier (2.5 HP scale, 1.75 ATK scale for worlds 1-3), 
  // then gets much harder (uses config values 1.75 HP, 1.25 ATK)
  const hpScale = world <= 3 ? 2.5 : CONFIG.ENEMY_HP_SCALE;
  const atkScale = world <= 3 ? 1.75 : CONFIG.ENEMY_ATK_SCALE;
  
  const hp = Math.floor(ENEMY_BASE_HP[type] * Math.pow(hpScale, world - 1));
  const atk = Math.floor(ENEMY_BASE_ATK[type] * Math.pow(atkScale, world - 1));
  const resist = ENEMY_BASE_RESIST[type] + (world - 1) * CONFIG.ENEMY_RESIST_BONUS_PER_WORLD;

  // Base enemy stats
  const baseSpeed = {
    small: 80, normal: 60, big: 50, elite: 70, boss: 40,
    assassin: 120, tank: 35, ranger: 65, berserker: 75,
    mage: 65, necromancer: 50, paladin: 60, demon: 65, archboss: 60
  };

  const enemy = {
    id: `enemy_${GameState.enemyIdCounter++}`,
    type: type,
    world: world,
    hp: hp,
    maxHp: hp,
    atk: atk,
    resistancePct: Math.min(95, resist),
    attackInterval: ENEMY_ATTACK_INTERVAL[type],
    position: position || randomEdgePosition(),
    speed: baseSpeed[type] || 60,
    engaged: false,
    engageTimer: 0,
    expValue: ENEMY_BASE_EXP[type] * world,
    dropProfile: {
      coinBase: CONFIG.ENEMY_BASE_COIN[type] || CONFIG.ENEMY_BASE_COIN['normal'],
      gemChancePct: ['big', 'elite', 'boss', 'tank', 'berserker', 'mage', 'necromancer', 'paladin', 'demon', 'archboss'].includes(type) 
        ? (type === 'boss' || type === 'archboss' ? 100 : type === 'elite' || type === 'necromancer' || type === 'demon' ? 50 : 20)
        : 0
    }
  };
  
  // Debug logging for archboss
  if (type === 'archboss') {
    console.log('[ARCHBOSS] Created with:', {
      id: enemy.id,
      position: enemy.position,
      speed: enemy.speed,
      type: enemy.type
    });
  }

  // Add special abilities for new enemy types
  switch(type) {
    case 'assassin':
      // Assassin: Critical Strike - 50% chance to deal double damage
      enemy.specialAbility = 'critical_strike';
      enemy.critChance = 0.50;
      break;
    
    case 'tank':
      // Tank: Shield Block - 25% damage reduction
      enemy.specialAbility = 'shield_block';
      enemy.damageReduction = 0.25;
      break;
    
    case 'ranger':
      // Ranger: Long Range - Attacks from farther away (2x)
      enemy.specialAbility = 'long_range';
      enemy.attackRangeMultiplier = 2;
      break;
    
    case 'berserker':
      // Berserker: Rage Mode - Gains 20% speed and 50% attack when below 50% HP
      enemy.specialAbility = 'rage_mode';
      enemy.rageThreshold = 0.5;
      enemy.rageActive = false;
      break;
    
    case 'mage':
      // Mage: Arcane Bolt - Shoots potion every 8 seconds with random debuff
      enemy.specialAbility = 'arcane_bolt';
      enemy.potionTimer = 0;
      enemy.potionCooldown = 8.0;
      break;
    
    case 'necromancer':
      // Necromancer: Life Drain - Heals 15% of damage dealt
      enemy.specialAbility = 'life_drain';
      enemy.lifeDrainPct = 0.15;
      break;
    
    case 'paladin':
      // Paladin: Holy Aura - Regenerates 10% HP per second
      enemy.specialAbility = 'holy_aura';
      enemy.regenPctPerSec = 0.10;
      enemy.regenTimer = 0;
      break;
    
    case 'demon':
      // Demon: Burning Strike - Applies damage over time (10% of attack over 3 seconds)
      enemy.specialAbility = 'burning_strike';
      enemy.burnDuration = 3;
      enemy.burnMultiplier = 0.10;
      break;
    
    case 'archboss':
      // Archboss: Supreme Power - Multiple abilities
      enemy.specialAbility = 'supreme_power';
      enemy.enrageThreshold = 0.5;  // Enrage at 50% HP
      enemy.enrageActive = false;
      enemy.lifeDrainThreshold = 0.10;  // Life drain starts at 10% HP
      enemy.lifeDrainActive = false;
      enemy.lifeDrainPctPerSec = 0.005;  // 0.5% per second
      enemy.hasSummoned = false;  // Track if summon has been used
      break;
  }

  return enemy;
}

function randomEdgePosition() {
  const stage = document.getElementById('stage');
  const w = stage.clientWidth;
  const h = stage.clientHeight;
  const side = GameState.rng.randInt(0, 3);

  if (side === 0) return { x: GameState.rng.randRange(0, w), y: -50 };
  if (side === 1) return { x: w + 50, y: GameState.rng.randRange(0, h) };
  if (side === 2) return { x: GameState.rng.randRange(0, w), y: h + 50 };
  return { x: -50, y: GameState.rng.randRange(0, h) };
}

// ========== Enemy Special Abilities ==========
function handleEnemySpecialAbilities(enemy, dt) {
  if (!enemy.specialAbility) return;
  
  const hpPct = enemy.hp / enemy.maxHp;
  
  // Berserker: Rage Mode (50% HP threshold, +20% speed, +50% attack)
  if (enemy.specialAbility === 'rage_mode' && !enemy.rageActive && hpPct <= enemy.rageThreshold) {
    enemy.rageActive = true;
    const originalSpeed = enemy.speed / 1.0;  // Get base speed
    const originalAtk = enemy.atk / 1.0;      // Get base attack
    enemy.speed = Math.floor(originalSpeed * 1.2);
    enemy.atk = Math.floor(originalAtk * 1.5);
    showNotification('âš”ï¸ Berserker enraged!', 'danger');
  }
  
  // Archboss: Enrage at 50% HP (+20% speed, +50% attack)
  if (enemy.specialAbility === 'supreme_power' && !enemy.enrageActive && hpPct <= enemy.enrageThreshold) {
    enemy.enrageActive = true;
    const baseSpeed = 35;  // Archboss base speed
    const baseAtk = 50;    // Archboss base attack
    enemy.speed = Math.floor(baseSpeed * 1.2);
    enemy.atk = Math.floor(baseAtk * 1.5);
    showNotification('ðŸ‘‘ Archboss entered supreme state!', 'legendary');
  }
  
  // Archboss: Summon at 50% HP (one-time)
  if (enemy.specialAbility === 'supreme_power' && !enemy.hasSummoned && hpPct <= 0.5) {
    enemy.hasSummoned = true;
    summonEnemies(enemy, 5, 1);  // 5 random enemies + 1 elite
    showNotification('ðŸ‘‘ Archboss summoned reinforcements!', 'danger');
  }
  
  // Archboss: Life Drain at 10% HP (0.5% regen per second, stops at 10%)
  if (enemy.specialAbility === 'supreme_power' && hpPct <= enemy.lifeDrainThreshold && hpPct < 0.10) {
    if (!enemy.lifeDrainActive) {
      enemy.lifeDrainActive = true;
      showNotification('ðŸ‘‘ Archboss is draining life force!', 'legendary');
    }
    const healAmount = Math.floor(enemy.maxHp * enemy.lifeDrainPctPerSec * dt);
    const maxHeal = enemy.maxHp * 0.10;  // Cap at 10% HP
    enemy.hp = Math.min(maxHeal, enemy.hp + healAmount);
  }
  
  // Paladin: Holy Aura (10% HP Regeneration per second)
  if (enemy.specialAbility === 'holy_aura') {
    enemy.regenTimer = (enemy.regenTimer || 0) + dt;
    if (enemy.regenTimer >= 1.0) {
      enemy.regenTimer -= 1.0;
      const healAmount = Math.floor(enemy.maxHp * enemy.regenPctPerSec);
      enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
    }
  }
  
  // Mage: Arcane Bolt - Shoot potion every 8 seconds
  if (enemy.specialAbility === 'arcane_bolt' && enemy.engaged) {
    enemy.potionTimer = (enemy.potionTimer || 0) + dt;
    if (enemy.potionTimer >= enemy.potionCooldown) {
      enemy.potionTimer = 0;
      shootPoisonPotion(enemy);
    }
  }
  
  // Tank: Visual indicator for shield
  if (enemy.specialAbility === 'shield_block') {
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl && !enemyEl.style.boxShadow.includes('blue')) {
      enemyEl.style.boxShadow = '0 0 12px rgba(100, 150, 255, 0.8)';
    }
  }
}

function summonEnemies(boss, randomCount, eliteCount) {
  const world = boss.world;
  const stage = document.getElementById('stage');
  const bossX = boss.position.x;
  const bossY = boss.position.y;
  
  // Summon random enemies from SMALL, NORMAL, and BIG categories
  const availableSmall = getAvailableEnemyTypes('SMALL', world);
  const availableNormal = getAvailableEnemyTypes('NORMAL', world);
  const availableBig = getAvailableEnemyTypes('BIG', world);
  const allAvailable = [...availableSmall, ...availableNormal, ...availableBig];
  
  for (let i = 0; i < randomCount; i++) {
    const type = allAvailable[Math.floor(Math.random() * allAvailable.length)];
    const enemy = createEnemy(type, world);
    // Spawn near the boss
    enemy.position.x = bossX + (Math.random() - 0.5) * 200;
    enemy.position.y = bossY + (Math.random() - 0.5) * 200;
    enemy.prevX = enemy.position.x;
    enemy.prevY = enemy.position.y;
    GameState.enemies.push(enemy);
  }
  
  // Summon elite enemies using available elite types
  const availableElites = getAvailableEnemyTypes('ELITE', world);
  for (let i = 0; i < eliteCount; i++) {
    const type = availableElites[Math.floor(Math.random() * availableElites.length)];
    const enemy = createEnemy(type, world);
    enemy.position.x = bossX + (Math.random() - 0.5) * 200;
    enemy.position.y = bossY + (Math.random() - 0.5) * 200;
    enemy.prevX = enemy.position.x;
    enemy.prevY = enemy.position.y;
    GameState.enemies.push(enemy);
  }
}

function shootPoisonPotion(mage) {
  // Create visual projectile
  const stage = document.getElementById('stage');
  const playerX = stage.clientWidth / 2;
  const playerY = stage.clientHeight / 2;
  
  // Select random debuff
  const debuffs = ['slowness', 'weakness', 'poison', 'harmness'];
  const selectedDebuff = debuffs[Math.floor(Math.random() * debuffs.length)];
  
  // Apply debuff to player
  applyPoisonDebuff(selectedDebuff, mage.atk);
  
  showNotification(`ðŸ”® Mage cast ${selectedDebuff}!`, 'danger');
}

function applyPoisonDebuff(debuffType, mageAtk) {
  if (!GameState.player.activeDebuffs) {
    GameState.player.activeDebuffs = {};
  }
  
  const duration = 3.0; // 3 seconds
  const endTime = Date.now() + duration * 1000;
  
  switch(debuffType) {
    case 'slowness':
      GameState.player.activeDebuffs.slowness = {
        endTime: endTime,
        color: '#808080'
      };
      break;
    
    case 'weakness':
      GameState.player.activeDebuffs.weakness = {
        endTime: endTime,
        multiplier: 0.5  // 50% damage reduction
      };
      break;
    
    case 'poison':
      GameState.player.activeDebuffs.poison = {
        endTime: endTime,
        damage: Math.floor(mageAtk * 1.2),  // 120% of mage attack
        tickInterval: 1.0,  // 1 second per tick
        nextTick: Date.now() + 1000
      };
      break;
    
    case 'harmness':
      GameState.player.activeDebuffs.harmness = {
        endTime: endTime,
        multiplier: 1.5  // +50% damage taken
      };
      break;
  }
}

function updatePlayerDebuffs() {
  if (!GameState.player.activeDebuffs) return;
  
  const now = Date.now();
  
  // Update poison ticks
  if (GameState.player.activeDebuffs.poison) {
    const poison = GameState.player.activeDebuffs.poison;
    if (now >= poison.nextTick && now < poison.endTime) {
      dealDamageToPlayer(poison.damage);
      poison.nextTick = now + poison.tickInterval * 1000;
    }
    if (now >= poison.endTime) {
      delete GameState.player.activeDebuffs.poison;
    }
  }
  
  // Clean up expired debuffs
  for (const [debuffType, debuff] of Object.entries(GameState.player.activeDebuffs)) {
    if (now >= debuff.endTime) {
      delete GameState.player.activeDebuffs[debuffType];
    }
  }
  
  // Apply visual indicator
  const player = document.getElementById('player');
  if (player) {
    if (GameState.player.activeDebuffs.slowness) {
      player.style.filter = 'grayscale(0.8)';
    } else if (GameState.player.activeDebuffs.weakness) {
      player.style.filter = 'brightness(0.6)';
    } else if (GameState.player.activeDebuffs.poison) {
      player.style.filter = 'hue-rotate(90deg) brightness(0.8)';
    } else if (GameState.player.activeDebuffs.harmness) {
      player.style.filter = 'hue-rotate(180deg) brightness(1.2)';
    } else {
      player.style.filter = '';
    }
  }
}

function applyBurnToPlayer(baseDamage, duration, multiplier) {
  const burnDamage = Math.floor(baseDamage * multiplier);
  const tickInterval = 1.0; // 1 second per tick
  const totalTicks = Math.floor(duration / tickInterval);
  
  if (!GameState.player.activeBurns) {
    GameState.player.activeBurns = [];
  }
  
  GameState.player.activeBurns.push({
    damage: burnDamage,
    ticksRemaining: totalTicks,
    tickTimer: 0,
    tickInterval: tickInterval
  });
  
  showNotification('ðŸ”¥ Burning!', 'danger');
}

function updatePlayerBurns(dt) {
  if (!GameState.player.activeBurns || GameState.player.activeBurns.length === 0) return;
  
  GameState.player.activeBurns.forEach(burn => {
    burn.tickTimer += dt;
    if (burn.tickTimer >= burn.tickInterval) {
      burn.tickTimer -= burn.tickInterval;
      burn.ticksRemaining--;
      dealDamageToPlayer(burn.damage);
    }
  });
  
  GameState.player.activeBurns = GameState.player.activeBurns.filter(b => b.ticksRemaining > 0);
}

// ========== Enemy Update Logic ==========
function updateEnemies(dt) {
  const stage = document.getElementById('stage');
  const playerX = stage.clientWidth / 2;
  const playerY = stage.clientHeight / 2;

  GameState.enemies.forEach(enemy => {
    // Handle frozen state
    if (enemy.frozen && enemy.frozenTimer !== undefined) {
      enemy.frozenTimer -= dt;
      if (enemy.frozenTimer <= 0) {
        enemy.frozen = false;
        enemy.speed = enemy.originalSpeed || enemy.speed;
        delete enemy.frozenTimer;

        // Remove frozen visual effect
        const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
        if (enemyEl) {
          enemyEl.style.filter = '';
        }

        // 3-piece Glacier: Frozen Bomb - explosion after unfreezing
        if (getSetCount('glacier') >= 3) {
          const explosionDmg = Math.floor((GameState.player.currentStats?.finalATK || GameState.player.ATK) * 1.20);
          applyCritDamage(enemy, explosionDmg, { type: 'cryo', source: 'frozen_bomb', setId: 'glacier'});

          const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
          if (enemyEl) {
            const rect = enemyEl.getBoundingClientRect();
            spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 60, getElementColor('cryo'), 300);
          }
        }
      } else {
        // Apply frozen visual effect
        const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
        if (enemyEl && !enemyEl.style.filter.includes('brightness')) {
          enemyEl.style.filter = 'brightness(1.5) saturate(0.3) hue-rotate(180deg)';
        }
      }
    }

    // Visual indicator for freeze-immune enemies (on cooldown)
    const now = Date.now();
    if (enemy.freezeCooldownUntil && now < enemy.freezeCooldownUntil) {
      const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
      if (enemyEl && !enemy.frozen) {
        // Add a subtle red tint to show immunity
        enemyEl.style.boxShadow = '0 0 10px rgba(255, 100, 100, 0.6)';
      }
    } else if (enemy.freezeCooldownUntil && now >= enemy.freezeCooldownUntil) {
      // Remove immunity visual
      const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
      if (enemyEl) {
        enemyEl.style.boxShadow = '';
      }
    }

    // Handle special abilities
    handleEnemySpecialAbilities(enemy, dt);

    const dx = playerX - enemy.position.x;
    const dy = playerY - enemy.position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // Calculate engage radius (ranger has longer range)
    const engageRadius = enemy.attackRangeMultiplier 
      ? CONFIG.ENGAGE_RADIUS_PX * enemy.attackRangeMultiplier 
      : CONFIG.ENGAGE_RADIUS_PX;

    if (distance > engageRadius) {
      enemy.engaged = false;
      let ndx = dx / distance;
      let ndy = dy / distance;
      
      // Group cohesion: if enemy is part of a group, adjust movement to stay with group
      if (enemy.groupCohesion && enemy.groupId) {
        const groupMembers = GameState.enemies.filter(e => 
          e.groupId === enemy.groupId && e.id !== enemy.id && e.hp > 0
        );
        
        if (groupMembers.length > 0) {
          // Calculate group center
          let centerX = 0, centerY = 0;
          groupMembers.forEach(member => {
            centerX += member.position.x;
            centerY += member.position.y;
          });
          centerX /= groupMembers.length;
          centerY /= groupMembers.length;
          
          // Calculate distance to group center
          const toCenterX = centerX - enemy.position.x;
          const toCenterY = centerY - enemy.position.y;
          const distToCenter = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
          
          // If too far from group (>100px), blend movement toward group center
          if (distToCenter > 100) {
            const cohesionStrength = 0.3; // 30% movement toward group
            const centerNdx = toCenterX / distToCenter;
            const centerNdy = toCenterY / distToCenter;
            
            ndx = ndx * (1 - cohesionStrength) + centerNdx * cohesionStrength;
            ndy = ndy * (1 - cohesionStrength) + centerNdy * cohesionStrength;
            
            // Re-normalize
      
      // Debug logging for archboss movement
      if (enemy.type === 'archboss') {
        console.log('[ARCHBOSS MOVE]', {
          id: enemy.id,
          speed: enemy.speed,
          position: { x: enemy.position.x, y: enemy.position.y },
          ndx, ndy, dt,
          movement: { x: ndx * enemy.speed * dt, y: ndy * enemy.speed * dt }
        });
      }
            const newLength = Math.sqrt(ndx * ndx + ndy * ndy);
            if (newLength > 0) {
              ndx /= newLength;
              ndy /= newLength;
            }
          }
        }
      }
      
      enemy.position.x += ndx * enemy.speed * dt;
      enemy.position.y += ndy * enemy.speed * dt;
    } else {
      if (!enemy.engaged) {
        enemy.engaged = true;
        enemy.engageTimer = 0;
      }
      enemy.engageTimer += dt;
      if (enemy.engageTimer >= enemy.attackInterval) {
        enemy.engageTimer -= enemy.attackInterval;
        
        // Calculate damage with special abilities
        let damage = enemy.atk;
        let isCrit = false;
        
        // Assassin: Critical Strike (50% chance)
        if (enemy.specialAbility === 'critical_strike' && Math.random() < (enemy.critChance || 0)) {
          damage *= 2;
          isCrit = true;
        }
        
        // Berserker: Rage bonus (+50% attack)
        if (enemy.rageActive && enemy.specialAbility === 'rage_mode') {
          // Already applied in handleEnemySpecialAbilities
        }
        
        // Archboss: Enrage bonus (+50% attack)
        if (enemy.enrageActive && enemy.specialAbility === 'supreme_power') {
          // Already applied in handleEnemySpecialAbilities
        }
        
        // Apply harmness debuff (+50% damage taken)
        if (GameState.player.activeDebuffs && GameState.player.activeDebuffs.harmness) {
          damage = Math.floor(damage * GameState.player.activeDebuffs.harmness.multiplier);
        }
        
        dealDamageToPlayer(damage, isCrit);
        
        // Apply armor enchantments (thorns, shock, burn)
        applyArmorEnchantments(enemy, damage);
        
        // Necromancer: Life Drain
        if (enemy.specialAbility === 'life_drain' && enemy.lifeDrainPct) {
          const healAmount = Math.floor(damage * enemy.lifeDrainPct);
          enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
        }
        
        // Demon: Burning Strike (DOT)
        if (enemy.specialAbility === 'burning_strike') {
          applyBurnToPlayer(enemy.atk, enemy.burnDuration, enemy.burnMultiplier);
        }
      }
    }
  });

  GameState.enemies = GameState.enemies.filter(enemy => {
    if (enemy.hp <= 0) {
      onEnemyDeath(enemy);
      return false;
    }
    return true;
  });
}

// ========== Death & Drops ==========
function onEnemyDeath(enemy) {
  const p = GameState.player;

  // Track challenge progress
  trackChallengeProgress(enemy);

  // Handle enchantment effects on enemy death
  // Wind Burst explosion
  if (enemy.windBurstMarked && enemy.lastHit && enemy.lastHit.type === 'wind') {
    const explosionDamage = enemy.windBurstDamage || 0;
    spawnAoE(enemy.position.x, enemy.position.y, 80, explosionDamage, 'wind', { source: 'wind_burst_explosion' });
  }
  
  // Bounty Hunter reward
  if (enemy.bountyTarget) {
    // 10x coins
    const bountyCoins = Math.floor(
      enemy.dropProfile.coinBase *
      (1 + p.world * 0.5) *
      GameState.rng.randRange(0.8, 1.2) *
      (1 + p.luck / 100) *
      10
    );
    p.coins += bountyCoins;
    showFloatingChange(bountyCoins, 'coins');
    showNotification(`ðŸŽ¯ Bounty collected! +${bountyCoins.toLocaleString()} coins`, 'legendary');
    
    // Damage rain area
    const rainDuration = 5000;
    const tickRate = 200;
    const baseDamage = GameState.player.currentStats?.finalATK || GameState.player.ATK;
    const rainDamage = Math.floor(baseDamage * 1.25);
    const startTime = Date.now();
    
    const interval = setInterval(() => {
      if (Date.now() - startTime >= rainDuration) {
        clearInterval(interval);
        return;
      }
      
      const enemiesInArea = findEnemiesInRadius(enemy.position.x, enemy.position.y, 100);
      enemiesInArea.forEach(e => {
        if (e.hp > 0) {
          const tickDamage = Math.floor(rainDamage / (rainDuration / tickRate));
          applyDamageToEnemy(e, tickDamage, { type: 'physical', source: 'bounty_rain' });
        }
      });
    }, tickRate);
    
    // Visual rain effect
    spawnShockwave(enemy.position.x, enemy.position.y, 100, '#ffd700', rainDuration);
  }
  
  // Apply expert hunter enchantment exp bonus
  const expertHunterCount = countEnchantment('expert_hunter');
  if (expertHunterCount > 0) {
    p.exp += enemy.expValue * expertHunterCount * 2; // +200% per enchantment
  }

  // Track statistics
  if (p.statistics) {
    p.statistics.totalKills++;
    if (enemy.type === 'boss' || enemy.type === 'archboss') {
      p.statistics.bossesDefeated++;
    }
  }

  p.exp += enemy.expValue;
  if (p.statistics) {
    p.statistics.totalExpGained += enemy.expValue;
  }

  let coins = Math.floor(
    enemy.dropProfile.coinBase *
    (1 + p.world * 0.5) *
    GameState.rng.randRange(0.8, 1.2) *
    (1 + p.luck / 100)
  );

  const coinsBoost = p.activeEffects.find(e => e.id === 'coins_boost_200');
  if (coinsBoost) coins *= coinsBoost.params.multiplier;

  if (getSetCount('nightwing') >= 3) coins *= 1.5;
  
  // Apply Fortune enchantment (+200% per)
  const fortuneCount = countEnchantment('fortune');
  if (fortuneCount > 0) {
    coins *= (1 + fortuneCount * 2.0);
  }
  
  // Apply Luck enchantment (already factored into p.luck)

  p.coins += Math.floor(coins);
  if (p.statistics) {
    p.statistics.totalCoinsEarned += Math.floor(coins);
  }
  showFloatingChange(coins, 'coins');

  if (enemy.type === 'elite' && GameState.rng.rand() < enemy.dropProfile.gemChancePct / 100) {
    const gemAmount = 1 + Math.floor(p.world / 5);
    p.gems += gemAmount;
    if (p.statistics) {
      p.statistics.totalGemsEarned += gemAmount;
    }
    showFloatingChange(gemAmount, 'gems');
  }
  if (enemy.type === 'boss' || enemy.type === 'archboss') {
    const gemAmount = 1 + Math.floor(p.world / 5);
    p.gems += gemAmount;
    if (p.statistics) {
      p.statistics.totalGemsEarned += gemAmount;
    }
    showFloatingChange(gemAmount, 'gems');
  }

  const baseChance = CONFIG.BASE_EQUIP_DROP_CHANCE_PCT[enemy.type] || 0;
  let finalChance = (baseChance / 100) * (1 + p.luck / 100);
  
  // Apply Luck enchantment (additional bonus)
  const luckCount = countEnchantment('luck');
  if (luckCount > 0) {
    finalChance *= (1 + luckCount * 0.5); // +50% per luck enchantment
  }

  if (GameState.rng.rand() < finalChance) {
    const rarity = rollRarity();
    const slots = ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon'];
    const slot = slots[GameState.rng.randInt(0, slots.length - 1)];
    
    // Chance to drop set equipment (5% base, scales with world)
    let item;
    const setDropChance = Math.min(0.05 + (p.world * 0.01), 0.30); // 5% base, +1% per world, max 30%
    if (GameState.rng.rand() < setDropChance) {
      // Drop a set item with random rarity (same distribution as normal items)
      const availableSets = Object.keys(EQUIPMENT_SETS);
      const randomSet = availableSets[GameState.rng.randInt(0, availableSets.length - 1)];
      item = generateEquipment(slot, rarity, p.world, randomSet); // Set items now use random rarity
    } else {
      // Drop normal equipment
      item = generateEquipment(slot, rarity, p.world);
    }
    
    addToInventory(item);
    if (p.statistics) {
      p.statistics.itemsFound++;
    }
  }

  GameState.worldProgress.enemiesKilledThisWorld++;
  if (enemy.type === 'elite' || enemy.type === 'boss' || enemy.type === 'archboss') {
    GameState.worldProgress.elitesKilledThisWorld++;
  }

  showDrop(enemy.position, 'ðŸ’°');

  handleSetBonusOnKill(enemy);

  checkLevelUp();
  updateWorldProgress();
}

function checkLevelUp() {
  const p = GameState.player;
  
  // Three-tier XP curve system
  let expNeeded;
  if (p.level <= 15) {
    // Levels 1-15: Full exponential curve
    expNeeded = 100 * Math.pow(1.5, p.level - 1);
  } else if (p.level <= 30) {
    // Levels 16-30: Transition period - slow down a bit
    const baseXP = 100 * Math.pow(1.5, 14); // XP at level 15
    const levelsAbove15 = p.level - 15;
    // Use 1.01 multiplier instead of 1.5 for slower growth
    expNeeded = baseXP * Math.pow(1.1, levelsAbove15);
  } else {
    // Levels 31+: Much slower polynomial growth
    const baseXP = 100 * Math.pow(1.5, 14) * Math.pow(1.1, 15); // XP at level 30
    const levelsAbove30 = p.level - 30;
    expNeeded = baseXP + (levelsAbove30 * levelsAbove30 * 3200);
  }

  while (p.exp >= expNeeded) {
    p.exp -= expNeeded;
    p.level++;
    p.baseStats.ATK += 10;
    p.baseStats.HP += 20;
    p.baseStats.SPD += 1;
    
    // Recalculate expNeeded for next level
    if (p.level <= 15) {
      expNeeded = 100 * Math.pow(1.5, p.level - 1);
    } else if (p.level <= 30) {
      const baseXP = 100 * Math.pow(1.5, 14);
      const levelsAbove15 = p.level - 15;
      expNeeded = baseXP * Math.pow(1.1, levelsAbove15);
    } else {
      const baseXP = 100 * Math.pow(1.5, 14) * Math.pow(1.1, 15);
      const levelsAbove30 = p.level - 30;
      expNeeded = baseXP + (levelsAbove30 * levelsAbove30 * 3200);
    }
    
    computeDerivedStats();
    p.hp = p.maxHp;
    showNotification(`â­ Level Up! You are now level ${p.level}`, 'success');
  }
}

// ========== Wave Spawning ==========
function spawnWave() {
  if (GameState.suspendWaves) return;

  const p = GameState.player;
  
  // Dynamic enemy cap: starts at 10, increases by 5 per world, max 50
  const enemyCap = Math.min(50, 10 + (p.world - 1) * 5);
  const currentEnemyCount = GameState.enemies.length;
  
  if (currentEnemyCount >= enemyCap) {
    return; // Already at cap
  }

  // Define enemy weights based on world level
  let typeWeights;
  
  if (p.world >= 12) {
    // World 12+: All enemy types
    typeWeights = { 
      small: 10, normal: 20, big: 8, elite: 4,
      assassin: 8, tank: 6, ranger: 8, berserker: 6,
      mage: 8, necromancer: 5, paladin: 4, demon: 3 
    };
  } else if (p.world >= 9) {
    // World 9-11: + mage, necromancer
    typeWeights = { 
      small: 12, normal: 22, big: 10, elite: 5,
      assassin: 10, tank: 8, ranger: 10, berserker: 8,
      mage: 10, necromancer: 7
    };
  } else if (p.world >= 6) {
    // World 6-8: + tank, berserker
    typeWeights = { 
      small: 15, normal: 25, big: 12, elite: 6,
      assassin: 12, tank: 10, ranger: 12, berserker: 10
    };
  } else if (p.world >= 3) {
    // World 3-5: + assassin, ranger
    typeWeights = { 
      small: 20, normal: 30, big: 15, elite: 8,
      assassin: 15, ranger: 15
    };
  } else {
    // World 1-2: Original enemies only
    typeWeights = { small: 30, normal: 50, big: 15, elite: 5 };
  }
  
  const enemiesNeeded = enemyCap - currentEnemyCount;

  // 15% chance to spawn a group of 5-12 enemies together
  const spawnGroup = Math.random() < 0.15 && enemiesNeeded >= 5;
  
  if (spawnGroup) {
    // Group spawn: 5-12 enemies at once, spawning close together
    const groupSize = Math.min(Math.floor(Math.random() * 8) + 5, enemiesNeeded);
    
    // Pick a shared spawn position for the group
    const groupPosition = randomEdgePosition();
    const groupId = `group_${Date.now()}_${Math.random()}`;
    
    for (let i = 0; i < groupSize; i++) {
      const type = GameState.rng.weightedChoice(
        Object.keys(typeWeights),
        Object.values(typeWeights)
      );
      
      // Spawn enemies in a small cluster around the group position (within 80px radius)
      const angle = (i / groupSize) * Math.PI * 2;
      const radius = 30 + Math.random() * 50; // 30-80px from center
      const offsetX = Math.cos(angle) * radius;
      const offsetY = Math.sin(angle) * radius;
      
      const position = {
        x: groupPosition.x + offsetX,
        y: groupPosition.y + offsetY
      };
      
      const enemy = createEnemy(type, p.world, position);
      enemy.groupId = groupId; // Mark as part of a group
      enemy.groupCohesion = true; // Enable group movement behavior
      GameState.enemies.push(enemy);
      enemy.prevX = enemy.position.x;
      enemy.prevY = enemy.position.y;
    }
  } else {
    // Continuous spawn: spawn 1-2 enemies to continuously fill to cap
    const spawnCount = Math.min(Math.floor(Math.random() * 2) + 1, enemiesNeeded);
    
    for (let i = 0; i < spawnCount; i++) {
      const type = GameState.rng.weightedChoice(
        Object.keys(typeWeights),
        Object.values(typeWeights)
      );
      const enemy = createEnemy(type, p.world);
      GameState.enemies.push(enemy);
      enemy.prevX = enemy.position.x;
      enemy.prevY = enemy.position.y;
    }
  }
}

// ========== Inventory Management ==========
function cleanInventory() {
  // Don't compact the inventory - we use sparse arrays for visual positioning
  // Just ensure no undefined values cause issues
  // Keep the array sparse but valid
  if (GameState.player && GameState.player.inventory) {
    // Only remove completely invalid entries, keep the structure
    for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
      if (GameState.player.inventory[i] === null) {
        delete GameState.player.inventory[i];
      }
    }
  }
}

function getInventoryCount() {
  // Count actual items in inventory (non-null, non-undefined)
  if (!GameState.player || !GameState.player.inventory) return 0;
  let count = 0;
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] != null) {
      count++;
    }
  }
  return count;
}

function addToInventory(item) {
  cleanInventory();
  if (getInventoryCount() >= CONFIG.MAX_INVENTORY_SLOTS) {
    // Inventory is full - auto-sell the item
    if (item.sellPrice) {
      GameState.player.coins += item.sellPrice;
      if (GameState.player.statistics) {
        GameState.player.statistics.totalCoinsEarned += item.sellPrice;
      }
      showFloatingChange(item.sellPrice, 'coins');
      showNotification(`ðŸ’° Inventory full! Auto-sold ${item.name} for ${item.sellPrice.toLocaleString()} coins`, 'warning');
      return false;
    } else {
      showNotification('âš ï¸ Inventory full!', 'warning');
      return false;
    }
  }

  // Find first empty slot
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] == null) {
      GameState.player.inventory[i] = item;
      showNotification(`ðŸ“¦ Obtained: ${item.name}`, 'info');
      return true;
    }
  }

  // Fallback: should not reach here after cleanInventory, but auto-sell if it does
  if (item.sellPrice) {
    GameState.player.coins += item.sellPrice;
    if (GameState.player.statistics) {
      GameState.player.statistics.totalCoinsEarned += item.sellPrice;
    }
    showFloatingChange(item.sellPrice, 'coins');
    showNotification(`ðŸ’° Inventory full! Auto-sold ${item.name} for ${item.sellPrice.toLocaleString()} coins`, 'warning');
  } else {
    showNotification('âš ï¸ Inventory full!', 'warning');
  }
  return false;
}

function equipItem(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  const slot = item.slot;
  const currentItem = GameState.player.equipment[slot];

  // Find and remove the item from inventory (sparse array)
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      delete GameState.player.inventory[i];
      break;
    }
  }

  // Equip the new item
  GameState.player.equipment[slot] = item;

  // If there was an old equipped item, add it to first empty inventory slot
  if (currentItem) {
    for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
      if (GameState.player.inventory[i] == null) {
        GameState.player.inventory[i] = currentItem;
        break;
      }
    }
  }

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();
  hideTooltip();
}

function unequipItem(slot) {
  const item = GameState.player.equipment[slot];
  if (!item) return;

  cleanInventory();
  if (getInventoryCount() >= CONFIG.MAX_INVENTORY_SLOTS) {
    showNotification('âš ï¸ Inventory full!', 'warning');
    return;
  }

  // Find first empty slot
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] == null) {
      GameState.player.inventory[i] = item;
      GameState.player.equipment[slot] = null;

      computeDerivedStats();
      renderInventory();
      renderPlayerStats();
      hideTooltip();
      return;
    }
  }
}

function sellItem(itemId) {
  const item = findItem(itemId);
  if (!item) return;

  // Show confirmation modal
  const modal = document.getElementById('sell-modal');
  const modalBody = document.getElementById('sell-modal-body');
  
  // Build item description for modal
  let itemDescription = `<strong>${item.name}</strong>`;
  if (item.type === 'equipment') {
    const rarityColor = `var(--color-${item.rarity})`;
    const stars = 'â­'.repeat(Math.floor(item.level / 20));
    itemDescription = `<strong style="color: ${rarityColor};">${item.name}</strong> ${stars}<br>Level ${item.level}`;
  }
  
  modalBody.innerHTML = `
    Are you sure you want to sell:<br><br>
    ${itemDescription}<br><br>
    for <strong style="color: var(--accent-gold);">ðŸ’° ${item.sellPrice.toLocaleString()} coins</strong>?
  `;
  
  modal.setAttribute('aria-hidden', 'false');
  
  // Store the itemId for the confirm handler
  modal.dataset.pendingSellItemId = itemId;
}

function confirmSellItem() {
  const modal = document.getElementById('sell-modal');
  const itemId = modal.dataset.pendingSellItemId;
  
  if (!itemId) return;
  
  const item = findItem(itemId);
  if (!item) {
    modal.setAttribute('aria-hidden', 'true');
    return;
  }

  GameState.player.coins += item.sellPrice;
  showFloatingChange(item.sellPrice, 'coins');

  // Remove from sparse inventory
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      delete GameState.player.inventory[i];
      break;
    }
  }

  // Also check if item is equipped and remove it from equipment slot
  if (item.type === 'equipment') {
    for (const slot in GameState.player.equipment) {
      if (GameState.player.equipment[slot]?.id === itemId) {
        GameState.player.equipment[slot] = null;
        computeDerivedStats();
        renderPlayerStats();
        break;
      }
    }
  }

  renderInventory();
  hideTooltip();
  modal.setAttribute('aria-hidden', 'true');
  showNotification(`ðŸ’° Sold ${item.name} for ${item.sellPrice} coins`, 'success');
}

function upgradeItem(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  // cap item level at 100
  if (typeof item.level === 'number' && item.level >= 100) {
    if (item.rarity === 'divine') {
      showNotification('âš ï¸ Item is already at MAX LEVEL!', 'warning');
    } else {
      showNotification('âš ï¸ Item is level 100! Use Enhance to promote to next rarity.', 'info');
    }
    return;
  }

  const cost = getUpgradeCost(item);
  if (GameState.player.coins < cost.coins) {
    showNotification('âš ï¸ Not enough coins!', 'warning');
    return;
  }
  if (GameState.player.gems < cost.gems) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state BEFORE any operations
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  GameState.player.coins -= cost.coins;
  showFloatingChange(-cost.coins, 'coins');
  GameState.player.gems -= cost.gems;
  showFloatingChange(-cost.gems, 'gems');

  // increment, but do not exceed 100
  item.level = Math.min(100, (item.level || 0) + 1);

  if (CONFIG.STAR_THRESHOLDS.includes(item.level)) {
    item.stars++;
    showNotification(`â­ ${item.name} reached ${item.stars} stars!`, 'legendary');
  }

  // Unlock affixes when their required level is reached
  item.affixes.forEach(aff => {
    if (aff.locked && typeof aff.unlockLevel === 'number' && item.level >= aff.unlockLevel) {
      aff.locked = false;
      showNotification(`ðŸ”“ New attribute unlocked for ${item.name}: ${aff.name}!`, 'info');
    }
  });

  // Upgrade stat increase - linear interpolation from Level 1 to Level 100
  // Calculate what the stat should be at the new level
  if (item.initialBaseValue === undefined) {
    // Store initial value if not already stored (for old items)
    item.initialBaseValue = item.baseAttribute.value;
  }
  
  const level1Value = item.initialBaseValue;
  const level100Value = BASE_STAT_LEVEL100[item.rarity][item.baseAttribute.name];
  
  // Linear interpolation: value = level1 + (level100 - level1) * ((currentLevel - 1) / 99)
  const progress = (item.level - 1) / 99; // 0 at level 1, 1 at level 100
  const targetValue = Math.floor(level1Value + (level100Value - level1Value) * progress);
  
  item.baseAttribute.value = targetValue;

  // Update sell price based on new item value
  updateItemSellPrice(item);

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    // Use requestAnimationFrame to ensure DOM is fully updated
    requestAnimationFrame(() => {
      try {
        // Find the slot element for this item
        let slotEl = null;
        if (tooltipIsEquipped) {
          // Item is equipped - find the equipment slot
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          // Item is in inventory - find the inventory slot (need to search properly in sparse array)
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (GameState.player.inventory[i] && GameState.player.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex !== -1) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }

        // Re-show the tooltip to keep it visible
        if (slotEl) {
          showItemTooltip(item, slotEl, tooltipIsEquipped);
        }
      } catch (e) {
        console.warn('Failed to update tooltip after upgrade:', e);
      }
    });
  }
}

function getUpgradeCost(item) {
  const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
  const coins = Math.floor(baseCost * Math.pow(1.055, item.level - 1));

  const nextLevel = item.level + 1;
  let gems = 0;
  if (CONFIG.STAR_THRESHOLDS.includes(nextLevel)) {
    gems = CONFIG.STAR_GEM_COSTS[nextLevel.toString()] || 0;
  }

  return { coins, gems };
}

// Calculate the current value of an item based on its level and upgrades
function getItemCurrentValue(item) {
  if (!item || item.type !== 'equipment') return item.buyPrice || 0;
  
  // Start with base buy price
  let totalValue = item.buyPrice || 0;
  
  // Add value for each level upgrade (sum of all upgrade costs from level 1 to current level)
  const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
  for (let lvl = 1; lvl < item.level; lvl++) {
    const upgradeCost = Math.floor(baseCost * Math.pow(1.055, lvl - 1));
    totalValue += upgradeCost;
    
    // Add gem costs for star thresholds
    if (CONFIG.STAR_THRESHOLDS.includes(lvl + 1)) {
      const gemCost = CONFIG.STAR_GEM_COSTS[(lvl + 1).toString()] || 0;
      // Convert gems to coins at a rate (e.g., 1 gem = 1000 coins)
      totalValue += gemCost * 1000;
    }
  }
  
  return totalValue;
}

// Update an item's sell price based on its current value
function updateItemSellPrice(item) {
  if (!item || item.type !== 'equipment') return;
  const currentValue = getItemCurrentValue(item);
  item.sellPrice = Math.floor(currentValue * 0.5); // 50% of current value
}

function enhanceItem(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  // Can only enhance at level 100
  if (item.level < 100) {
    showNotification('âš ï¸ Item must be level 100 to enhance!', 'warning');
    return;
  }

  // Cannot enhance divine items (max rarity)
  if (item.rarity === 'divine') {
    showNotification('âš ï¸ Divine items cannot be enhanced further!', 'warning');
    return;
  }

  // Enhancement cost: base upgrade cost + 15 gems
  const cost = getUpgradeCost(item);
  const enhanceCost = {
    coins: cost.coins,
    gems: 15
  };

  if (GameState.player.coins < enhanceCost.coins) {
    showNotification('âš ï¸ Not enough coins!', 'warning');
    return;
  }
  if (GameState.player.gems < enhanceCost.gems) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state BEFORE any operations
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  // Pay the cost
  GameState.player.coins -= enhanceCost.coins;
  showFloatingChange(-enhanceCost.coins, 'coins');
  GameState.player.gems -= enhanceCost.gems;
  showFloatingChange(-enhanceCost.gems, 'gems');

  // Determine next rarity
  const rarityOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary', 'mythic', 'divine'];
  const currentRarityIndex = rarityOrder.indexOf(item.rarity);
  const nextRarity = rarityOrder[currentRarityIndex + 1];

  if (!nextRarity) {
    showNotification('âš ï¸ Cannot enhance this item further!', 'warning');
    return;
  }

  // Store old rarity for notification
  const oldRarity = item.rarity;

  // Promote to next rarity
  item.rarity = nextRarity;

  // Reset level and stars
  item.level = 1;
  item.stars = 0;

  // Lock all affixes again
  item.affixes.forEach(aff => {
    aff.locked = true;
  });
  
  // IMPORTANT: Enchantments are preserved during enhancement
  // Enchantments remain in their current state (locked/unlocked)
  // and unlock costs do NOT increase

  // Generate new base stat value for the new rarity (random from new rarity's range)
  const baseAttrName = item.baseAttribute.name;
  const newBaseRange = BASE_STAT_RANGES[nextRarity][baseAttrName];
  const newBaseValue = GameState.rng.randInt(newBaseRange[0], newBaseRange[1]);
  
  // Update base attribute and store as new initial value
  item.baseAttribute.value = newBaseValue;
  item.initialBaseValue = newBaseValue;

  // Keep existing affixes but upgrade their values to new rarity ranges
  item.affixes.forEach(affix => {
    const range = AFFIX_RANGES[nextRarity][affix.name];
    if (range) {
      // Keep the same affix, but scale value to new rarity range
      const oldRange = AFFIX_RANGES[oldRarity][affix.name];
      if (oldRange) {
        // Calculate percentage position in old range
        const oldMin = oldRange[0];
        const oldMax = oldRange[1];
        const oldSpan = oldMax - oldMin;
        const percentage = oldSpan > 0 ? (affix.value - oldMin) / oldSpan : 0.5;
        
        // Apply same percentage to new range
        const newMin = range[0];
        const newMax = range[1];
        const newSpan = newMax - newMin;
        affix.value = Math.floor(newMin + (newSpan * percentage));
      } else {
        // Fallback: random value in new range
        affix.value = GameState.rng.randInt(range[0], range[1]);
      }
    }
  });

  // Update name if it's a generic item (not a set item)
  if (!item.setId) {
    item.name = `${nextRarity.charAt(0).toUpperCase() + nextRarity.slice(1)} ${item.slot.charAt(0).toUpperCase() + item.slot.slice(1)}`;
  }

  // Update buy price to reflect new rarity (using same formula as generateEquipment)
  const world = item.createdAtWorld || GameState.player.world || 1;
  item.buyPrice = Math.floor(CONFIG.BASE_SHOP_PRICE[nextRarity] * (1 + world * 0.1));
  
  // Update sell price based on new value (now at level 1 of new rarity)
  updateItemSellPrice(item);

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  showNotification(`âœ¨ Enhanced ${item.name} to ${nextRarity}!`, 'legendary');

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    requestAnimationFrame(() => {
      try {
        let slotEl = null;
        if (tooltipIsEquipped) {
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (GameState.player.inventory[i] && GameState.player.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex !== -1) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }

        if (slotEl) {
          slotEl.dispatchEvent(new Event('click', { bubbles: false }));
        }
      } catch (err) {
        console.error('Error reopening tooltip after enhance:', err);
      }
    });
  }
}

// Quick enhance: upgrades item to level 100 and then enhances to next rarity
function quickEnhanceItem(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  if (item.level >= 100) {
    showNotification('âš ï¸ Item is already at level 100!', 'warning');
    return;
  }

  if (item.rarity === 'divine') {
    showNotification('âš ï¸ Divine items cannot be enhanced further!', 'warning');
    return;
  }

  // Calculate total cost to upgrade to level 100 and enhance
  let totalCoins = 0;
  let totalGems = 0;
  const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
  
  for (let lvl = item.level; lvl < 100; lvl++) {
    const upgradeCost = Math.floor(baseCost * Math.pow(1.055, lvl - 1));
    totalCoins += upgradeCost;
    
    const nextLevel = lvl + 1;
    if (CONFIG.STAR_THRESHOLDS.includes(nextLevel)) {
      totalGems += CONFIG.STAR_GEM_COSTS[nextLevel.toString()] || 0;
    }
  }
  
  // Add enhancement cost
  const finalUpgradeCost = Math.floor(baseCost * Math.pow(1.055, 99));
  totalCoins += finalUpgradeCost;
  totalGems += 15; // Enhancement gem cost

  const p = GameState.player;
  if (p.coins < totalCoins) {
    showNotification('âš ï¸ Not enough coins!', 'warning');
    return;
  }
  if (p.gems < totalGems) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state BEFORE any operations
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  // Pay the cost
  p.coins -= totalCoins;
  showFloatingChange(-totalCoins, 'coins');
  p.gems -= totalGems;
  showFloatingChange(-totalGems, 'gems');

  // Upgrade to level 100
  const oldLevel = item.level;
  item.level = 100;
  item.stars = 5;

  // Unlock all affixes
  item.affixes.forEach(aff => {
    aff.locked = false;
  });

  // Update base stat to level 100 value
  if (item.initialBaseValue === undefined) {
    item.initialBaseValue = item.baseAttribute.value;
  }
  
  const level1Value = item.initialBaseValue;
  const level100Value = BASE_STAT_LEVEL100[item.rarity][item.baseAttribute.name];
  item.baseAttribute.value = level100Value;

  // Now enhance to next rarity
  const rarityOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary', 'mythic', 'divine'];
  const currentRarityIndex = rarityOrder.indexOf(item.rarity);
  const nextRarity = rarityOrder[currentRarityIndex + 1];

  if (nextRarity) {
    const oldRarity = item.rarity;
    item.rarity = nextRarity;
    item.level = 1;
    item.stars = 0;

    // Lock all affixes again
    item.affixes.forEach(aff => {
      aff.locked = true;
    });

    // Generate new base stat value for the new rarity
    const baseAttrName = item.baseAttribute.name;
    const newBaseRange = BASE_STAT_RANGES[nextRarity][baseAttrName];
    const newBaseValue = GameState.rng.randInt(newBaseRange[0], newBaseRange[1]);
    
    item.baseAttribute.value = newBaseValue;
    item.initialBaseValue = newBaseValue;

    // Keep existing affixes but upgrade their values to new rarity ranges
    item.affixes.forEach(affix => {
      const range = AFFIX_RANGES[nextRarity][affix.name];
      if (range) {
        const oldRange = AFFIX_RANGES[oldRarity][affix.name];
        if (oldRange) {
          const oldMin = oldRange[0];
          const oldMax = oldRange[1];
          const oldSpan = oldMax - oldMin;
          const percentage = oldSpan > 0 ? (affix.value - oldMin) / oldSpan : 0.5;
          
          const newMin = range[0];
          const newMax = range[1];
          const newSpan = newMax - newMin;
          affix.value = Math.floor(newMin + (newSpan * percentage));
        } else {
          affix.value = GameState.rng.randInt(range[0], range[1]);
        }
      }
    });

    // Update name if it's a generic item
    if (!item.setId) {
      item.name = `${nextRarity.charAt(0).toUpperCase() + nextRarity.slice(1)} ${item.slot.charAt(0).toUpperCase() + item.slot.slice(1)}`;
    }

    // Update buy price to reflect new rarity
    const world = item.createdAtWorld || p.world || 1;
    item.buyPrice = Math.floor(CONFIG.BASE_SHOP_PRICE[nextRarity] * (1 + world * 0.1));
  }

  // Update sell price based on new value
  updateItemSellPrice(item);

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  showNotification(`âš¡ Quick Enhanced to ${nextRarity}! (Lvl ${oldLevel} â†’ Lvl 1 ${nextRarity})`, 'legendary');

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    requestAnimationFrame(() => {
      try {
        let slotEl = null;
        if (tooltipIsEquipped) {
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (p.inventory[i] && p.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex !== -1) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }
        
        if (slotEl) {
          showItemTooltip(item, slotEl, tooltipIsEquipped);
        }
      } catch (err) {
        console.error('Error reopening tooltip:', err);
      }
    });
  }
}

// Quick upgrade: upgrades item to a specific level (typically next star threshold)
function quickUpgradeItem(itemId, targetLevel) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  if (item.level >= targetLevel) {
    showNotification(`âš ï¸ Item is already at level ${targetLevel} or higher!`, 'warning');
    return;
  }

  // Calculate total cost to upgrade to target level
  let totalCoins = 0;
  let totalGems = 0;
  const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
  
  for (let lvl = item.level; lvl < targetLevel; lvl++) {
    const upgradeCost = Math.floor(baseCost * Math.pow(1.055, lvl - 1));
    totalCoins += upgradeCost;
    
    const nextLevel = lvl + 1;
    if (CONFIG.STAR_THRESHOLDS.includes(nextLevel)) {
      totalGems += CONFIG.STAR_GEM_COSTS[nextLevel.toString()] || 0;
    }
  }

  const p = GameState.player;
  if (p.coins < totalCoins) {
    showNotification('âš ï¸ Not enough coins!', 'warning');
    return;
  }
  if (p.gems < totalGems) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state BEFORE any operations
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  // Pay the cost
  p.coins -= totalCoins;
  showFloatingChange(-totalCoins, 'coins');
  p.gems -= totalGems;
  showFloatingChange(-totalGems, 'gems');

  // Upgrade to target level
  const oldLevel = item.level;
  item.level = targetLevel;
  
  // Update stars based on level
  const starCount = CONFIG.STAR_THRESHOLDS.filter(threshold => targetLevel >= threshold).length;
  item.stars = starCount;

  // Unlock affixes that should be unlocked at this level
  item.affixes.forEach(aff => {
    if (aff.locked && typeof aff.unlockLevel === 'number' && targetLevel >= aff.unlockLevel) {
      aff.locked = false;
    }
  });

  // Update base stat to target level value
  if (item.initialBaseValue === undefined) {
    item.initialBaseValue = item.baseAttribute.value;
  }
  
  const level1Value = item.initialBaseValue;
  const level100Value = BASE_STAT_LEVEL100[item.rarity][item.baseAttribute.name];
  
  // Linear interpolation
  const progress = (targetLevel - 1) / 99;
  const targetValue = Math.floor(level1Value + (level100Value - level1Value) * progress);
  item.baseAttribute.value = targetValue;

  // Update sell price based on new value
  updateItemSellPrice(item);

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  showNotification(`âš¡ Quick Upgraded to Level ${targetLevel}! (${oldLevel} â†’ ${targetLevel})`, 'success');

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    requestAnimationFrame(() => {
      try {
        let slotEl = null;
        if (tooltipIsEquipped) {
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (p.inventory[i] && p.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex !== -1) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }
        
        if (slotEl) {
          showItemTooltip(item, slotEl, tooltipIsEquipped);
        }
      } catch (err) {
        console.error('Error reopening tooltip:', err);
      }
    });
  }
}

function useConsumable(itemId) {
  const item = findItem(itemId);
  if (!item || item.type !== 'consumable') return;

  // Remove from sparse inventory
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      delete GameState.player.inventory[i];
      break;
    }
  }

  const effect = {
    id: item.effectId,
    startedAtTs: Date.now(),
    durationSec: item.duration,
    params: item.params
  };
  GameState.player.activeEffects.push(effect);

  computeDerivedStats();
  renderInventory();
  hideTooltip();
  showNotification(`ðŸ§ª Consumed: ${item.name}`, 'success');
}

function rerollAffix(itemId, affixIndex) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  const affix = item.affixes[affixIndex];
  if (!affix) return;

  // Can only reroll unlocked affixes
  if (affix.locked) {
    showNotification('âš ï¸ Cannot reroll locked affixes!', 'warning');
    return;
  }

  // Cost: 15 gems
  const cost = 15;
  if (GameState.player.gems < cost) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  // Pay the cost
  GameState.player.gems -= cost;
  showFloatingChange(-cost, 'gems');

  // Reroll to a different affix
  const currentAffixName = affix.name;
  const availableAffixes = AFFIX_POOL.filter(a => {
    // Filter out affixes already on the item
    return !item.affixes.some(existing => existing.name === a.name);
  });

  if (availableAffixes.length === 0) {
    showNotification('âš ï¸ No other affixes available!', 'warning');
    return;
  }

  // Pick a random new affix
  const weights = availableAffixes.map(a => a.weight);
  const chosenAffix = GameState.rng.weightedChoice(availableAffixes, weights);
  
  // Get random value for new affix
  const range = AFFIX_RANGES[item.rarity][chosenAffix.name];
  const value = GameState.rng.randInt(range[0], range[1]);

  // Update the affix
  affix.name = chosenAffix.name;
  affix.value = value;

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  showNotification(`ðŸ”„ Rerolled affix to ${chosenAffix.name}!`, 'info');

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    requestAnimationFrame(() => {
      try {
        let slotEl = null;
        if (tooltipIsEquipped) {
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (GameState.player.inventory[i] && GameState.player.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex >= 0) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }
        if (slotEl) {
          showItemTooltip(item, slotEl, tooltipIsEquipped);
        }
      } catch (e) {
        console.error('Error reopening tooltip:', e);
      }
    });
  }
}

function rerollAffixValue(itemId, affixIndex) {
  const item = findItem(itemId);
  if (!item || item.type !== 'equipment') return;

  const affix = item.affixes[affixIndex];
  if (!affix) return;

  // Can only reroll unlocked affixes
  if (affix.locked) {
    showNotification('âš ï¸ Cannot reroll locked affixes!', 'warning');
    return;
  }

  // Cost: 50 gems
  const cost = 50;
  if (GameState.player.gems < cost) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  // Store tooltip state
  const tooltip = document.getElementById('inventory-tooltip');
  const tooltipWasOpen = tooltip && tooltip.getAttribute('aria-hidden') === 'false';
  const tooltipItemId = tooltip ? tooltip.dataset.currentItemId : null;
  const tooltipIsEquipped = tooltip ? tooltip.dataset.isEquipped === 'true' : false;

  // Pay the cost
  GameState.player.gems -= cost;
  showFloatingChange(-cost, 'gems');

  // Reroll the value (keep same affix name)
  const range = AFFIX_RANGES[item.rarity][affix.name];
  const oldValue = affix.value;
  affix.value = GameState.rng.randInt(range[0], range[1]);

  computeDerivedStats();
  renderInventory();
  renderPlayerStats();

  const change = affix.value - oldValue;
  const changeText = change > 0 ? `+${change}` : change.toString();
  showNotification(`ðŸŽ² Rerolled ${affix.name} value: ${oldValue} â†’ ${affix.value} (${changeText})`, 'info');

  // Keep the tooltip open if it was showing this item
  if (tooltipWasOpen && tooltipItemId === item.id) {
    requestAnimationFrame(() => {
      try {
        let slotEl = null;
        if (tooltipIsEquipped) {
          slotEl = document.getElementById(`equip-${item.slot === 'ring' ? 'ring-slot' : item.slot}`);
        } else {
          let itemIndex = -1;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (GameState.player.inventory[i] && GameState.player.inventory[i].id === item.id) {
              itemIndex = i;
              break;
            }
          }
          if (itemIndex >= 0) {
            slotEl = document.querySelector(`.inv-slot[data-index="${itemIndex}"]`);
          }
        }
        if (slotEl) {
          showItemTooltip(item, slotEl, tooltipIsEquipped);
        }
      } catch (e) {
        console.error('Error reopening tooltip:', e);
      }
    });
  }
}

function findItem(itemId) {
  // Search in sparse inventory array
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (GameState.player.inventory[i] && GameState.player.inventory[i].id === itemId) {
      return GameState.player.inventory[i];
    }
  }

  // Search in equipment
  for (const slot in GameState.player.equipment) {
    if (GameState.player.equipment[slot]?.id === itemId) {
      return GameState.player.equipment[slot];
    }
  }

  return null;
}

// ========== Shop System ==========
const CONSUMABLES = [
  { id: 'exp_boost_200', name: 'EXP Boost x3', icon: 'ðŸ“š', effectId: 'exp_boost_200', params: { multiplier: 3 } },
  { id: 'dmg_boost_200', name: 'Damage Boost x3', icon: 'âš¡', effectId: 'dmg_boost_200', params: { multiplier: 3 } },
  { id: 'coins_boost_200', name: 'Coins Boost x3', icon: 'ðŸ’°', effectId: 'coins_boost_200', params: { multiplier: 3 } }
];

function refreshShop() {
  const shop = GameState.shop;
  shop.offers.equipment = [];
  shop.offers.consumables = [];

  const slots = ['helmet', 'chestplate', 'leggings', 'boots', 'ring', 'weapon'];
  const setIds = Object.keys(EQUIPMENT_SETS);
  for (let i = 0; i < 6; i++) {
    const slot = slots[i % slots.length];
    const rarity = rollRarity();
    // 30% chance to generate a set item
    const isSetItem = GameState.rng.rand() < 0.50; // Increased set item rate
    const setId = isSetItem ? setIds[Math.floor(GameState.rng.rand() * setIds.length)] : null;
    const item = generateEquipment(slot, rarity, GameState.player.world, setId);
    shop.offers.equipment.push(item);
  }

  CONSUMABLES.forEach(cons => {
    shop.offers.consumables.push({
      id: `cons_${GameState.itemIdCounter++}`,
      type: 'consumable',
      name: cons.name,
      icon: cons.icon,
      effectId: cons.effectId,
      params: cons.params,
      duration: CONFIG.DEFAULT_CONSUMABLE_DURATION_S,
      price: 10,
      slot: null
    });
  });

  shop.lastRefreshTs = Date.now();
}

function buyShopItem(itemId) {
  // Find the item in shop offers
  const shop = GameState.shop;
  let item = shop.offers.equipment.find(i => i.id === itemId);
  if (!item) {
    item = shop.offers.consumables.find(i => i.id === itemId);
  }
  if (!item) {
    showNotification('âš ï¸ Item not found!', 'warning');
    return;
  }

  const p = GameState.player;
  const cost = item.type === 'consumable' ? item.price : item.buyPrice;
  const currency = item.type === 'consumable' ? 'gems' : 'coins';

  // Check if already sold out
  if (item.soldOut) {
    showNotification('âš ï¸ Item already sold!', 'warning');
    return;
  }

  if (currency === 'coins' && p.coins < cost) {
    showNotification('âš ï¸ Not enough coins!', 'warning');
    return;
  }
  if (currency === 'gems' && p.gems < cost) {
    showNotification('âš ï¸ Not enough gems!', 'warning');
    return;
  }

  cleanInventory();  // Clean before checking
  if (getInventoryCount() >= CONFIG.MAX_INVENTORY_SLOTS) {
    showNotification('âš ï¸ Inventory full!', 'warning');
    return;
  }

  if (currency === 'coins') {
    p.coins -= cost;
    showFloatingChange(-cost, 'coins');
  }
  else {
    p.gems -= cost;
    showFloatingChange(-cost, 'gems');
  }

  const itemCopy = { ...item, id: `item_${GameState.itemIdCounter++}` };

  // Find first empty slot
  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    if (p.inventory[i] == null) {
      p.inventory[i] = itemCopy;
      break;
    }
  }

  // Track purchase
  if (p.statistics) {
    p.statistics.itemsPurchased++;
  }

  // Mark item as sold out
  item.soldOut = true;

  showNotification(`ðŸ›’ Purchased: ${item.name}`, 'success');
  hideTooltip();
  renderShop();
  renderInventory();
}

// Continue in part 3...
// ========== UI Rendering ==========
function renderUI() {
  const p = GameState.player;

  document.getElementById('coins').textContent = Math.floor(p.coins).toLocaleString();
  document.getElementById('gems').textContent = Math.floor(p.gems).toLocaleString();
  document.getElementById('level').textContent = `Lv ${p.level}`;
  document.getElementById('world').textContent = `World ${p.world}`;

  // Use same three-tier XP formula as checkLevelUp
  let expNeeded;
  if (p.level <= 15) {
    // Levels 1-15: Full exponential curve
    expNeeded = 100 * Math.pow(1.5, p.level - 1);
  } else if (p.level <= 30) {
    // Levels 16-30: Transition period - slow down a bit
    const baseXP = 100 * Math.pow(1.5, 14);
    const levelsAbove15 = p.level - 15;
    expNeeded = baseXP * Math.pow(1.3, levelsAbove15);
  } else {
    // Levels 31+: Much slower polynomial growth
    const baseXP = 100 * Math.pow(1.5, 14) * Math.pow(1.3, 15);
    const levelsAbove30 = p.level - 30;
    expNeeded = baseXP + (levelsAbove30 * levelsAbove30 * 800);
  }
  
  const expPct = Math.min(100, (p.exp / expNeeded) * 100);
  document.getElementById('exp-fill').style.width = `${expPct}%`;
  document.getElementById('exp-text').textContent = `${Math.floor(p.exp).toLocaleString()} / ${Math.floor(expNeeded).toLocaleString()}`;

  const hpPct = Math.max(0, (p.hp / p.maxHp) * 100);
  document.getElementById('player-hp-fill').style.width = `${hpPct}%`;
  document.getElementById('player-hp-text').textContent = `${Math.floor(p.hp).toLocaleString()} / ${Math.floor(p.maxHp).toLocaleString()}`;

  renderEquipmentRing();
  updateActiveEffects();
  updateAttackRangeCircle();
}

function renderEquipmentRing() {
  const ring = document.getElementById('equip-ring');
  ring.innerHTML = '';

  const slots = ['helmet', 'weapon', 'chestplate', 'boots', 'leggings', 'ring'];
  const angleStep = (Math.PI * 2) / slots.length;

  slots.forEach((slot, i) => {
    const item = GameState.player.equipment[slot];
    if (!item) return;

    const angle = angleStep * i - Math.PI / 2;
    const x = Math.cos(angle) * CONFIG.EQUIP_RENDER_RADIUS_PX;
    const y = Math.sin(angle) * CONFIG.EQUIP_RENDER_RADIUS_PX;

    const icon = document.createElement('div');
    icon.className = `equipped-icon rarity-${item.rarity}`;
    // Use item.icon if available (for set items), otherwise fall back to SLOT_ICONS
    icon.textContent = item.icon || SLOT_ICONS[slot];
    icon.style.left = `${80 + x}px`;
    icon.style.top = `${80 + y}px`;
    icon.style.transform = 'translate(-50%, -50%)';
    ring.appendChild(icon);
  });
}

function updateAttackRangeCircle() {
  const p = GameState.player;
  const weaponItem = p.equipment && p.equipment.weapon;
  const circle = document.getElementById('attack-range-circle');

  if (!circle) return;

  // Show attack range circle if player has a weapon equipped
  if (weaponItem) {
    circle.classList.add('visible');

    // Get weapon range - use increased range for set weapons
    let range = CONFIG.ENGAGE_RADIUS_PX;
    if (weaponItem.setId) {
      // Set weapons have increased range (50% more)
      range = CONFIG.ENGAGE_RADIUS_PX * 1.5;
    }

    // Set circle size (diameter = 2 * radius)
    const diameter = range * 2;
    circle.style.width = `${diameter}px`;
    circle.style.height = `${diameter}px`;

    // Set circle color based on weapon rarity
    const rarityColors = {
      common: 'var(--color-common)',
      uncommon: 'var(--color-uncommon)',
      rare: 'var(--color-rare)',
      epic: 'var(--color-epic)',
      legendary: 'var(--color-legendary)',
      mythic: 'var(--color-mythic)',
      divine: 'var(--color-divine)'
    };

    const color = rarityColors[weaponItem.rarity] || '#888';
    circle.style.borderColor = color;
  } else {
    // No weapon equipped - hide the circle
    circle.classList.remove('visible');
  }
}

function renderSetBonuses() {
  const p = GameState.player;
  const container = document.getElementById('set-bonuses-display');
  if (!container) return;

  if (!p.activeSets || Object.keys(p.activeSets).length === 0) {
    container.innerHTML = '';
    container.style.display = 'none';
    return;
  }

  container.style.display = 'block';
  let html = '<div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin: 12px 0; border: 2px solid var(--accent-gold);">';
  html += '<div style="font-family: var(--font-display); font-size: 14px; font-weight: 700; color: var(--accent-gold); margin-bottom: 8px;">âš¡ Set Bonuses</div>';

  Object.keys(p.activeSets).forEach(setId => {
    const count = p.activeSets[setId];
    // Safety check: Skip if set doesn't exist in EQUIPMENT_SETS
    if (!EQUIPMENT_SETS[setId]) return;
    const setData = EQUIPMENT_SETS[setId];
    if (!setData) return;

    html += `<div style="margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">`;
    html += `<div style="font-weight: 700; color: var(--accent-gold); margin-bottom: 4px;">${setData.name} (${count}/6)</div>`;

    [2, 3, 4, 6].forEach(tier => {
      const bonus = setData.bonuses[tier];
      if (!bonus) return;

      const active = count >= tier;
      const color = active ? 'var(--text-primary)' : 'var(--text-dim)';
      const weight = active ? '600' : '400';
      html += `<div style="font-size: 11px; color: ${color}; font-weight: ${weight}; padding: 2px 0;">`;
      html += `<span style="color: ${active ? '#4fc3f7' : 'var(--text-dim)'};">${tier}:</span> ${bonus.desc}`;
      html += `</div>`;
    });

    html += `</div>`;
  });

  html += '</div>';
  container.innerHTML = html;
}

function renderInventory() {
  const p = GameState.player;
  cleanInventory();  // Clean inventory before rendering

  Object.keys(p.equipment).forEach(slot => {
    const slotEl = document.getElementById(`equip-${slot === 'ring' ? 'ring-slot' : slot}`);
    const item = p.equipment[slot];

    if (item) {
      slotEl.innerHTML = `
        <span class="item-icon">${item.icon || SLOT_ICONS[slot]}</span>
        <span class="item-level">L${item.level}</span>
        ${item.stars > 0 ? `<span class="item-stars">${'â­'.repeat(item.stars)}</span>` : ''}
      `;
      slotEl.className = `equip-slot filled rarity-${item.rarity}${hasUnlockedEnchantments(item) ? ' enchanted' : ''}`;
      slotEl.onclick = () => showItemTooltip(item, slotEl, true);
      slotEl.draggable = true;
    } else {
      slotEl.innerHTML = SLOT_ICONS[slot];
      slotEl.className = 'equip-slot';
      slotEl.onclick = null;
      slotEl.draggable = false;
    }
  });

  for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
    const slotEl = document.querySelector(`.inv-slot[data-index="${i}"]`);
    const item = p.inventory[i];

    if (item) {
      const icon = item.type === 'equipment' ? (item.icon || SLOT_ICONS[item.slot]) : item.icon;
      slotEl.innerHTML = `
        <span class="item-icon">${icon}</span>
        ${item.level ? `<span class="item-level">L${item.level}</span>` : ''}
        ${item.stars > 0 ? `<span class="item-stars">${'â­'.repeat(item.stars)}</span>` : ''}
      `;
      slotEl.className = `inv-slot filled ${item.rarity ? `rarity-${item.rarity}` : ''}${hasUnlockedEnchantments(item) ? ' enchanted' : ''}`;
      slotEl.onclick = () => showItemTooltip(item, slotEl, false);
      slotEl.draggable = true;
    } else {
      slotEl.innerHTML = '';
      slotEl.className = 'inv-slot';
      slotEl.onclick = null;
      slotEl.draggable = false;
    }
  }

  // Update inventory resources display (only if elements exist)
  const invCoinsEl = document.getElementById('inv-coins');
  const invGemsEl = document.getElementById('inv-gems');
  if (invCoinsEl) invCoinsEl.textContent = Math.floor(p.coins).toLocaleString();
  if (invGemsEl) invGemsEl.textContent = Math.floor(p.gems).toLocaleString();

  // Update active effects display in inventory
  updateActiveEffects();

  // Set bonuses are now shown in tooltips, no separate display needed
}

// Drag and drop handlers for inventory
let draggedSlotIndex = null;
let draggedEquipSlot = null;

document.addEventListener('dragstart', (e) => {
  // Handle inventory slots
  if (e.target.classList.contains('inv-slot') && e.target.classList.contains('filled')) {
    draggedSlotIndex = parseInt(e.target.dataset.index);
    draggedEquipSlot = null;
    e.target.classList.add('dragging');
  }
  // Handle equipment slots
  else if (e.target.classList.contains('equip-slot') && e.target.classList.contains('filled')) {
    draggedEquipSlot = e.target.dataset.slot;
    draggedSlotIndex = null;
    e.target.classList.add('dragging');
  }
});

document.addEventListener('dragend', (e) => {
  if (e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')) {
    e.target.classList.remove('dragging');
    draggedSlotIndex = null;
    draggedEquipSlot = null;
  }
});

document.addEventListener('dragover', (e) => {
  const slot = e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')
    ? e.target
    : e.target.closest('.inv-slot') || e.target.closest('.equip-slot');

  if (slot) {
    e.preventDefault();
    slot.classList.add('drag-over');
  }
});

document.addEventListener('dragleave', (e) => {
  const slot = e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')
    ? e.target
    : e.target.closest('.inv-slot') || e.target.closest('.equip-slot');

  if (slot) {
    slot.classList.remove('drag-over');
  }
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  const targetSlot = e.target.classList.contains('inv-slot') || e.target.classList.contains('equip-slot')
    ? e.target
    : e.target.closest('.inv-slot') || e.target.closest('.equip-slot');

  if (!targetSlot) return;

  targetSlot.classList.remove('drag-over');
  const p = GameState.player;

  // Case 1: Dragging from inventory to inventory (swap/reorder)
  if (draggedSlotIndex !== null && targetSlot.classList.contains('inv-slot')) {
    const targetIndex = parseInt(targetSlot.dataset.index);

    if (draggedSlotIndex !== targetIndex) {
      const draggedItem = p.inventory[draggedSlotIndex];
      const targetItem = p.inventory[targetIndex];

      // Only proceed if there is actually an item to drag
      if (draggedItem) {
        // Swap the items (or move to empty slot)
        if (targetIndex < CONFIG.MAX_INVENTORY_SLOTS) {
          // Perform the swap
          p.inventory[draggedSlotIndex] = targetItem;  // Put target item (or undefined) at source
          p.inventory[targetIndex] = draggedItem;      // Put dragged item at target

          // Clean up undefined at source if target was empty
          if (!targetItem) {
            delete p.inventory[draggedSlotIndex];
          }
        } else {
          // Target beyond max slots, place at last slot
          p.inventory[CONFIG.MAX_INVENTORY_SLOTS - 1] = draggedItem;
          delete p.inventory[draggedSlotIndex];
        }
      }

      renderInventory();
      hideTooltip();
    }
  }
  // Case 2: Dragging from inventory to equipment (equip)
  else if (draggedSlotIndex !== null && targetSlot.classList.contains('equip-slot')) {
    const item = p.inventory[draggedSlotIndex];
    const targetEquipSlot = targetSlot.dataset.slot;

    if (item && item.type === 'equipment' && item.slot === targetEquipSlot) {
      // Remove item from sparse inventory
      delete p.inventory[draggedSlotIndex];

      // Swap: unequip current item to inventory, equip new item
      const oldEquipped = p.equipment[targetEquipSlot];
      p.equipment[targetEquipSlot] = item;

      // If there was an old equipped item, put it at the same inventory slot
      if (oldEquipped) {
        p.inventory[draggedSlotIndex] = oldEquipped;
      }

      computeDerivedStats();
      renderInventory();
      renderPlayerStats();
      hideTooltip();
    }
  }
  // Case 3: Dragging from equipment to inventory (unequip)
  else if (draggedEquipSlot !== null && targetSlot.classList.contains('inv-slot')) {
    const targetIndex = parseInt(targetSlot.dataset.index);
    const equippedItem = p.equipment[draggedEquipSlot];

    if (equippedItem) {
      cleanInventory();
      const invItem = p.inventory[targetIndex];

      if (!invItem) {
        // Simple unequip to empty slot - check if there is space
        if (getInventoryCount() < CONFIG.MAX_INVENTORY_SLOTS) {
          // Place at the target slot
          p.inventory[targetIndex] = equippedItem;
          p.equipment[draggedEquipSlot] = null;
        } else {
          showNotification('âš ï¸ Inventory full!', 'warning');
          computeDerivedStats();
          renderInventory();
          renderPlayerStats();
          hideTooltip();
          return;
        }
      } else if (invItem.type === 'equipment' && invItem.slot === draggedEquipSlot) {
        // Swap compatible equipment
        p.equipment[draggedEquipSlot] = invItem;  // Equip the inventory item
        p.inventory[targetIndex] = equippedItem;  // Put equipped item in inventory slot
      } else {
        // Can't swap - target slot has incompatible item
        showNotification('âš ï¸ Cannot swap incompatible items', 'warning');
        computeDerivedStats();
        renderInventory();
        renderPlayerStats();
        hideTooltip();
        return;
      }

      computeDerivedStats();
      renderInventory();
      renderPlayerStats();
      hideTooltip();
    }
  }
  // Case 4: Dragging from equipment to equipment (swap slots)
  else if (draggedEquipSlot !== null && targetSlot.classList.contains('equip-slot')) {
    const targetEquipSlot = targetSlot.dataset.slot;

    if (draggedEquipSlot !== targetEquipSlot) {
      const item1 = p.equipment[draggedEquipSlot];
      const item2 = p.equipment[targetEquipSlot];

      // Only swap if both items match their target slots
      if (item1 && item1.slot === targetEquipSlot && (!item2 || item2.slot === draggedEquipSlot)) {
        p.equipment[draggedEquipSlot] = item2;
        p.equipment[targetEquipSlot] = item1;

        computeDerivedStats();
        renderInventory();
        renderPlayerStats();
        hideTooltip();
      }
    }
  }
});

function renderPlayerStats() {
  const stats = GameState.player.currentStats;
  const bonuses = GameState.player.statBonuses || { atkBonus: 0, hpBonus: 0, spdBonus: 0, dmgBonus: 0 };
  const playerStats = GameState.player.statistics;

  // Helper function to format stat with bonus
  const formatStatWithBonus = (value, bonus) => {
    if (bonus > 0) {
      return `${Math.floor(value).toLocaleString()} <span style="color: var(--text-bonus);">(+${Math.floor(bonus).toLocaleString()})</span>`;
    }
    return Math.floor(value).toLocaleString();
  };

  // Update inventory stats (combat only)
  document.getElementById('stat-atk').innerHTML = formatStatWithBonus(stats.finalATK, bonuses.atkBonus);
  document.getElementById('stat-hp').innerHTML = formatStatWithBonus(stats.finalHP, bonuses.hpBonus);
  document.getElementById('stat-spd').innerHTML = formatStatWithBonus(stats.finalSPD, bonuses.spdBonus);
  document.getElementById('stat-dmg').innerHTML = formatStatWithBonus(stats.finalDMGPct, bonuses.dmgBonus) + '%';
  document.getElementById('stat-crit-rate').textContent = `${Math.floor(stats.finalCritRate).toLocaleString()}%`;
  document.getElementById('stat-crit-dmg').textContent = `${Math.floor(stats.finalCritDmg).toLocaleString()}%`;

  // Update stats overlay - combat stats
  const atkDetail = document.getElementById('stat-atk-detail');
  const hpDetail = document.getElementById('stat-hp-detail');
  const spdDetail = document.getElementById('stat-spd-detail');
  const dmgDetail = document.getElementById('stat-dmg-detail');
  const critRateDetail = document.getElementById('stat-crit-rate-detail');
  const critDmgDetail = document.getElementById('stat-crit-dmg-detail');

  if (atkDetail) atkDetail.innerHTML = formatStatWithBonus(stats.finalATK, bonuses.atkBonus);
  if (hpDetail) hpDetail.innerHTML = formatStatWithBonus(stats.finalHP, bonuses.hpBonus);
  if (spdDetail) spdDetail.innerHTML = formatStatWithBonus(stats.finalSPD, bonuses.spdBonus);
  if (dmgDetail) dmgDetail.innerHTML = formatStatWithBonus(stats.finalDMGPct, bonuses.dmgBonus) + '%';
  if (critRateDetail) critRateDetail.textContent = `${Math.floor(stats.finalCritRate)}%`;
  if (critDmgDetail) critDmgDetail.textContent = `${Math.floor(stats.finalCritDmg)}%`;

  // Update player statistics
  if (playerStats) {
    const totalKillsEl = document.getElementById('stat-total-kills');
    const bossesEl = document.getElementById('stat-bosses');
    const worldsEl = document.getElementById('stat-worlds');
    const deathsEl = document.getElementById('stat-deaths');
    const critsEl = document.getElementById('stat-crits');
    const dmgDealtEl = document.getElementById('stat-dmg-dealt');
    const dmgTakenEl = document.getElementById('stat-dmg-taken');
    const highestDmgDealtEl = document.getElementById('stat-highest-dmg-dealt');
    const highestDmgTakenEl = document.getElementById('stat-highest-dmg-taken');
    const coinsEarnedEl = document.getElementById('stat-coins-earned');
    const gemsEarnedEl = document.getElementById('stat-gems-earned');
    const expGainedEl = document.getElementById('stat-exp-gained');
    const itemsFoundEl = document.getElementById('stat-items-found');
    const itemsBoughtEl = document.getElementById('stat-items-bought');
    const playtimeEl = document.getElementById('stat-playtime');

    if (totalKillsEl) totalKillsEl.textContent = playerStats.totalKills.toLocaleString();
    if (bossesEl) bossesEl.textContent = playerStats.bossesDefeated.toLocaleString();
    if (worldsEl) worldsEl.textContent = playerStats.worldsCompleted.toLocaleString();
    if (deathsEl) deathsEl.textContent = playerStats.deaths.toLocaleString();
    if (critsEl) critsEl.textContent = playerStats.criticalHits.toLocaleString();
    if (dmgDealtEl) dmgDealtEl.textContent = Math.floor(playerStats.totalDamageDealt).toLocaleString();
    if (dmgTakenEl) dmgTakenEl.textContent = Math.floor(playerStats.totalDamageTaken).toLocaleString();
    if (highestDmgDealtEl) highestDmgDealtEl.textContent = Math.floor(playerStats.highestDamageDealt || 0).toLocaleString();
    if (highestDmgTakenEl) highestDmgTakenEl.textContent = Math.floor(playerStats.highestDamageTaken || 0).toLocaleString();
    if (coinsEarnedEl) coinsEarnedEl.textContent = Math.floor(playerStats.totalCoinsEarned).toLocaleString();
    if (gemsEarnedEl) gemsEarnedEl.textContent = Math.floor(playerStats.totalGemsEarned).toLocaleString();
    if (expGainedEl) expGainedEl.textContent = Math.floor(playerStats.totalExpGained).toLocaleString();
    if (itemsFoundEl) itemsFoundEl.textContent = playerStats.itemsFound.toLocaleString();
    if (itemsBoughtEl) itemsBoughtEl.textContent = playerStats.itemsPurchased.toLocaleString();

    // Calculate and display play time
    if (playtimeEl) {
      const currentSession = (Date.now() - playerStats.sessionStartTime) / 1000;
      const totalSeconds = Math.floor(playerStats.totalPlayTime + currentSession);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      playtimeEl.textContent = `${hours}h ${minutes}m`;
    }
  }

  // Apply enchanted class to player if they have enchanted items equipped
  const playerEl = document.getElementById('player');
  if (playerEl) {
    const hasEnchantedEquipment = Object.values(GameState.player.equipment).some(item => 
      item && hasUnlockedEnchantments(item)
    );
    if (hasEnchantedEquipment) {
      playerEl.classList.add('enchanted');
    } else {
      playerEl.classList.remove('enchanted');
    }
  }
}

function renderShop() {
  const shop = GameState.shop;
  const p = GameState.player;

  // Update coins and gems display
  const shopCoinsEl = document.getElementById('shop-coins');
  const shopGemsEl = document.getElementById('shop-gems');
  if (shopCoinsEl) shopCoinsEl.textContent = Math.floor(p.coins).toLocaleString();
  if (shopGemsEl) shopGemsEl.textContent = Math.floor(p.gems).toLocaleString();

  const equipGrid = document.getElementById('shop-equipment-grid');
  equipGrid.innerHTML = '';
  shop.offers.equipment.forEach(item => {
    const div = document.createElement('div');
    const isSoldOut = item.soldOut || false;
    div.className = `shop-item rarity-${item.rarity}${isSoldOut ? ' sold-out' : ''}`;
    div.innerHTML = `
      <div class="shop-item-icon">${item.icon || SLOT_ICONS[item.slot]}</div>
      <div class="shop-item-name text-${item.rarity}">${item.name}</div>
      <div class="shop-item-price">ðŸ’° ${item.buyPrice.toLocaleString()}</div>
    `;
    if (!isSoldOut) {
      div.onclick = () => showShopItemTooltip(item, div);
    }
    equipGrid.appendChild(div);
  });

  const consGrid = document.getElementById('shop-consumables-grid');
  consGrid.innerHTML = '';
  shop.offers.consumables.forEach(item => {
    const div = document.createElement('div');
    const isSoldOut = item.soldOut || false;
    div.className = `shop-item${isSoldOut ? ' sold-out' : ''}`;
    div.innerHTML = `
      <div class="shop-item-icon">${item.icon}</div>
      <div class="shop-item-name">${item.name}</div>
      <div class="shop-item-price">ðŸ’Ž ${item.price.toLocaleString()}</div>
    `;
    if (!isSoldOut) {
      div.onclick = () => showShopItemTooltip(item, div);
    }
    consGrid.appendChild(div);
  });
}

function renderEnemies() {
  const layer = document.getElementById('enemy-layer');
  const existing = new Set(Array.from(layer.children).map(el => el.dataset.enemyId));

  GameState.enemies.forEach(enemy => {
    let el = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (!el) {
      el = document.createElement('div');
      el.className = `enemy ${enemy.type}`;
      el.dataset.enemyId = enemy.id;
      el.innerHTML = `
        ${ENEMY_ICONS[enemy.type]}
        <div class="enemy-hpbar"><div class="enemy-hp-fill"></div></div>
      `;
      el.onclick = () => attackEnemy(enemy);
      layer.appendChild(el);
      // Set initial position for newly created enemies
      el.style.transform = `translate(${enemy.position.x}px, ${enemy.position.y}px)`;
    }

    // Don't update transform here - smooth per-frame renderer handles all position updates

    const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
    el.querySelector('.enemy-hp-fill').style.width = `${hpPct}%`;

    existing.delete(enemy.id);
  });

  existing.forEach(id => {
    const el = document.querySelector(`[data-enemy-id="${id}"]`);
    if (el) el.remove();
  });
}

// ------------------- new helpers for weapon attacks & VFX -------------------
function getElementColor(el) {
  const map = {
    wind: '#2ecc71',         // green
    lightning: '#9b59b6',    // purple
    fire: '#ff8a4b',
    aether: '#fff8c2',       // light yellow
    cryo: '#5bc0ff',
    physical: '#ffffff'
  };
  return map[el] || '#ffffff';
}
function showElementDamage(damage, elementType, enemyEl, isCrit, customColor = null) {
  if (!enemyEl) return;
  const stage = document.getElementById('stage');
  if (!stage) return;

  // measure
  const rect = enemyEl.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const dmgEl = document.createElement('div');
  dmgEl.className = 'drop-item';
  dmgEl.textContent = isCrit ? `${damage.toLocaleString()}!` : `${damage.toLocaleString()}`;
  dmgEl.style.left = `${rect.left - stageRect.left + rect.width / 2}px`;
  dmgEl.style.top = `${rect.top - stageRect.top - 30}px`;
  dmgEl.style.color = customColor || getElementColor(elementType);
  dmgEl.style.fontWeight = 'bold';
  dmgEl.style.fontSize = '18px';
  dmgEl.style.textShadow = '0 1px 0 rgba(0,0,0,0.6)';

  const dropLayer = document.getElementById('drop-layer');
  if (dropLayer) {
    dropLayer.appendChild(dmgEl);
    setTimeout(() => dmgEl.remove(), 1800);
  }
}

/* ---------- Helper utilities ---------- */

function findEnemiesInRadius(x, y, radius) {
  // GameState.enemies expected to have .x/.y positions (or .position.x/.position.y)
  return GameState.enemies.filter(e => {
    const ex = (e.position && e.position.x) || e.x || 0;
    const ey = (e.position && e.position.y) || e.y || 0;
    const dx = ex - x, dy = ey - y;
    return (dx*dx + dy*dy) <= (radius * radius);
  });
}

function applyDamageToEnemy(enemy, dmg, ctx = {}) {
  if (!enemy || enemy.hp <= 0) return;
  
  // Tank: Shield Block - reduce damage
  if (enemy.specialAbility === 'shield_block' && enemy.damageReduction) {
    dmg = Math.floor(dmg * (1 - enemy.damageReduction));
  }
  
  enemy.hp -= dmg;
  // attach lastHit context for on-death detection
  enemy.lastHit = Object.assign({}, ctx, { damage: dmg, timestamp: Date.now() });

  // Track total damage dealt and highest damage dealt
  const p = GameState.player;
  if (p && p.statistics) {
    p.statistics.totalDamageDealt += dmg;
    if (dmg > (p.statistics.highestDamageDealt || 0)) {
      p.statistics.highestDamageDealt = dmg;
    }
  }

  // floating damage display: color by element (special-case aether & wind etc)
  const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
  if (enemyEl) {
    // Use yellow for coin damage, red for HP loss damage
    let customColor = null;
    if (ctx.source && (ctx.source.includes('coin') || ctx.source === 'rich_mans_blow' || ctx.source === 'wealth_rain')) {
      customColor = '#ffd700'; // Yellow for coins
    } else if (ctx.source && ctx.source.includes('hp_loss')) {
      customColor = '#ff3b3b'; // Red for HP loss
    }
    showElementDamage(Math.floor(dmg), ctx.type || 'physical', enemyEl, !!ctx.crit, customColor);
  }

  if (enemy.hp <= 0) {
    // spawn skywarden explosion if kill was wind + source set = skywarden and not spawned by explosion
    if (ctx.type === 'wind' && ctx.setId === 'skywarden' && !ctx.source?.includes?.('explosion')) {
      // spawn big explosion centered on enemy
      if (typeof spawnAoE === 'function') {
        const R = window.R_windExplosion || 80;
        spawnAoE(enemy.position?.x || enemy.x || 0, enemy.position?.y || enemy.y || 0, R, Math.floor((GameState.player.currentStats?.finalATK || GameState.player.ATK) * 0.35), 'wind', { source: 'skywarden_explosion' });
      } else {
        // fallback: shockwave visual
        const enemyElRect = enemyEl.getBoundingClientRect();
        spawnShockwave(enemyElRect.left + enemyElRect.width/2, enemyElRect.top + enemyElRect.height/2, 90, getElementColor('wind'), 360);
        // apply AoE damage manually
        const hits = findEnemiesInRadius(enemy.position?.x||enemy.x||0, enemy.position?.y||enemy.y||0, 80);
        for (const h of hits) {
          if (h.id === enemy.id) continue;
          applyDamageToEnemy(h, Math.floor((GameState.player.currentStats?.finalATK || GameState.player.ATK) * 0.35), { type:'wind', source:'skywarden_explosion', setId:'skywarden', isAoE:true });
        }
      }
    }
    // call onEnemyDeath as before
    onEnemyDeath(enemy);
    GameState.enemies = GameState.enemies.filter(e => e.id !== enemy.id);
  }
}

function applyStatus(enemy, statusName, data) {
  enemy.status = enemy.status || {};
  enemy.status[statusName] = Object.assign({ appliedAt: Date.now() }, data);
}

/* Lightweight projectile VFX factory (returns DOM node for additional control) */
function createProjectile(options) {
  // options: {fromX, fromY, toX, toY, color, size, travelMs, onArrive(callback(enemyHit)), pierce:false}
  const stage = document.getElementById('stage');
  if (!stage) return null;
  const stageRect = stage.getBoundingClientRect();
  const p = document.createElement('div');
  p.className = 'weapon-proj';
  Object.assign(p.style, {
    position: 'absolute',
    left: `${options.fromX - stageRect.left}px`,
    top: `${options.fromY - stageRect.top}px`,
    width: `${options.size||12}px`,
    height: `${options.size||12}px`,
    borderRadius: '50%',
    background: options.color || '#fff',
    boxShadow: `0 0 12px ${options.color||'#fff'}`,
    transform: 'translate(-50%,-50%)',
    zIndex: 60,
    pointerEvents: 'none',
    transition: `transform ${options.travelMs||260}ms linear, opacity 180ms linear`
  });
  stage.appendChild(p);

  // compute translation
  const dx = (options.toX - options.fromX);
  const dy = (options.toY - options.fromY);
  requestAnimationFrame(() => { p.style.transform = `translate(${dx}px, ${dy}px)`; });

  setTimeout(() => {
    // on arrive
    if (typeof options.onArrive === 'function') options.onArrive();
    // small impact flash
    const impact = document.createElement('div');
    Object.assign(impact.style, {
      position: 'absolute',
      left: `${options.toX - stageRect.left}px`,
      top: `${options.toY - stageRect.top}px`,
      transform: 'translate(-50%,-50%)',
      width: `${(options.size||12)*3}px`,
      height: `${(options.size||12)*3}px`,
      borderRadius: '50%',
      background: options.color || '#fff',
      opacity: 0.85,
      boxShadow: `0 0 22px ${options.color||'#fff'}`,
      zIndex: 61,
      pointerEvents: 'none'
    });
    stage.appendChild(impact);
    setTimeout(()=> impact.remove(), 280);
    p.remove();
  }, options.travelMs || 260);

  // safety remove
  setTimeout(()=>{ if(p.parentNode) p.remove(); }, (options.travelMs||260)+600);
  return p;
}

function spawnShockwave(x, y, radius, color, durationMs = 380) {
  const stage = document.getElementById('stage');
  if (!stage) return;
  const stageRect = stage.getBoundingClientRect();
  const w = document.createElement('div');
  Object.assign(w.style, {
    position: 'absolute',
    left: `${x - stageRect.left}px`,
    top: `${y - stageRect.top}px`,
    width: `4px`,
    height: `4px`,
    borderRadius: '50%',
    transform: 'translate(-50%,-50%)',
    zIndex: 59,
    pointerEvents: 'none',
    background: color,
    boxShadow: `0 0 22px ${color}`,
    opacity: '0.9',
    transition: `width ${durationMs}ms ease-out, height ${durationMs}ms ease-out, opacity ${durationMs}ms linear`
  });
  stage.appendChild(w);
  requestAnimationFrame(()=>{
    w.style.width = `${radius*2}px`;
    w.style.height = `${radius*2}px`;
    w.style.opacity = '0';
  });
  setTimeout(()=> w.remove(), durationMs+40);
}

function spawnAoE(x, y, radius, damage, element, options = {}) {
  // Find all enemies in the AoE radius
  const enemiesInArea = findEnemiesInRadius(x, y, radius);
  
  // Apply damage to each enemy
  enemiesInArea.forEach(enemy => {
    if (enemy.hp > 0) {
      applyDamageToEnemy(enemy, damage, { 
        type: element, 
        source: options.source || 'aoe',
        customColor: options.customColor
      });
    }
  });
  
  // Visual effect
  const color = options.customColor || getElementColor(element);
  spawnShockwave(x, y, radius, color, options.duration || 380);
}


/* ---------- safe player HP getters/setters ---------- */
function getPlayerHP(p) {
  return p.HP_current ?? p.currentHP ?? p.hp ?? (p.currentStats && p.currentStats.HP_current) ?? (p.HP_max ?? 0);
}
function setPlayerHP(p, value) {
  if (p.HP_current !== undefined) p.HP_current = value;
  else if (p.currentHP !== undefined) p.currentHP = value;
  else if (p.hp !== undefined) p.hp = value;
  else if (p.currentStats && p.currentStats.HP_current !== undefined) p.currentStats.HP_current = value;
  else p.HP_current = value;
}

/* ---------- SVG lightning arc (nice purple lightning) ---------- */
function createLightningArc(fromX, fromY, toX, toY, color, duration = 260) {
  // create an SVG path with jaggedness randomized to feel like lightning
  const stage = document.getElementById('stage');
  if (!stage) return;
  // create svg overlay if none
  let svg = document.getElementById('vfx-svg-overlay');
  if (!svg) {
    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('id','vfx-svg-overlay');
    svg.style.position = 'absolute';
    svg.style.left = '0';
    svg.style.top = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '999';
    stage.appendChild(svg);
  }
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  const dx = toX - fromX, dy = toY - fromY;
  const dist = Math.sqrt(dx*dx + dy*dy) || 1;
  // generate jagged midpoints
  const spikes = Math.max(2, Math.floor(dist / 60));
  const pts = [{x:fromX,y:fromY}];
  for (let i=1;i<spikes;i++){
    const t = i/spikes;
    const nx = fromX + dx * t + (Math.random()*40 - 20);
    const ny = fromY + dy * t + (Math.random()*40 - 20);
    pts.push({x:nx,y:ny});
  }
  pts.push({x:toX,y:toY});
  // build smooth polyline into path string
  let d = `M ${pts[0].x} ${pts[0].y}`;
  for (let i=1;i<pts.length;i++){
    d += ` L ${pts[i].x} ${pts[i].y}`;
  }
  path.setAttribute('d', d);
  path.setAttribute('stroke', color);
  path.setAttribute('stroke-width', 3);
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke-linecap', 'round');
  path.setAttribute('stroke-linejoin', 'round');
  path.style.opacity = '0.95';
  path.style.filter = 'drop-shadow(0 0 8px ' + color + ')';
  svg.appendChild(path);

  // animate fade out
  setTimeout(()=> {
    path.style.transition = `opacity ${Math.max(150,duration)}ms ease-out, stroke-width 180ms ease-out`;
    path.style.opacity = '0';
    path.setAttribute('stroke-width', 1);
    setTimeout(()=> path.remove(), Math.max(300,duration+80));
  }, duration);
  // return path node if caller wants to remove earlier
  return path;
}

/* ---------- Status tick processor (burn, slow expirations, etc) ----------
   Call processEnemyStatusTicks(deltaMs) from your main game tick loop.
*/
let _burnTickAcc = {}; // track last tick times per enemy for precise ticks if needed
function processEnemyStatusTicks(deltaMs) {
  // for each enemy
  const now = Date.now();
  for (const enemy of (GameState.enemies || [])) {
    if (!enemy.status) continue;
    // BURN: apply tick damage
    if (enemy.status.burn) {
      const s = enemy.status.burn;
      const elapsed = now - (s._lastTickAt || s.appliedAt || now);
      // tick every s.tickInterval (ms)
      if (elapsed >= (s.tickInterval || 1000)) {
        // compute number of ticks passed
        const ticks = Math.floor(elapsed / (s.tickInterval || 1000));
        for (let i=0;i<ticks;i++){
          // 3-piece: Burn - DoT scales by +8% of player ATK per tick
          let tickDmg = Math.floor(s.tickDamage || 0);
          if (getSetCount('emberkin') >= 3 && s.sourceSet === 'emberkin') {
            const atkScaling = Math.floor((GameState.player.currentStats?.finalATK || 0) * 0.08);
            tickDmg += atkScaling;
          }
          applyCritDamage(enemy, tickDmg, { type: 'fire', source: 'dot', setId: s.sourceSet || null});
        }
        s._lastTickAt = (s._lastTickAt || s.appliedAt || now) + ticks * (s.tickInterval || 1000);
      }
      // expire burn after duration
      if (now - (s.appliedAt || now) >= (s.duration || 5000)) {
        delete enemy.status.burn;
      }
    }

    // SLOW: visual and expiration
    if (enemy.status.slow) {
      const s = enemy.status.slow;
      // add visual to indicate slow
      addSlowVisual(enemy);
      if (now - (s.appliedAt || now) >= (s.duration || 3000)) {
        // remove slow
        delete enemy.status.slow;
        removeSlowVisual(enemy);
      }
    } else {
      // ensure visual removed if no slow
      removeSlowVisual(enemy);
    }
  }
}

/* slow visual functions (blue tint) */
function addSlowVisual(enemy) {
  const el = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
  if (!el) return;
  if (!el.classList.contains('vfx-slow')) {
    el.classList.add('vfx-slow');
    // define vfx-slow style if not already present (inject)
    if (!document.getElementById('vfx-slow-style')) {
      const st = document.createElement('style');
      st.id = 'vfx-slow-style';
      st.innerHTML = `
        .vfx-slow { filter: hue-rotate(200deg) saturate(120%) brightness(85%); transition: filter 180ms; box-shadow: 0 0 8px rgba(90,160,255,0.6); }
      `;
      document.head.appendChild(st);
    }
  }
}
function removeSlowVisual(enemy) {
  const el = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
  if (!el) return;
  el.classList.remove('vfx-slow');
}

/* ---------- Aegis orbiters system ---------- */
GameState.orbiters = GameState.orbiters || []; // global array for orbiters

function ensureAegisOrbiters(player) {
  // determine number of orbiters from equipped Aegis set pieces
  const weapon = player.equipment && player.equipment.weapon;
  if (!weapon || weapon.setId !== 'aegis') return; // only when Aegis equipped
  // base orb count = number of Aegis pieces equipped (we'll read computeDerivedStats or count)
  const piecesCount = (() => {
    const slots = ['helmet','chestplate','leggings','boots','ring','weapon'];
    let c = 0;
    for (const s of slots) {
      const it = player.equipment && player.equipment[s];
      if (it && it.setId === 'aegis') c++;
    }
    return c;
  })();
  const add = (piecesCount >= 4) ? 2 : 0;
  const orbCount = Math.max(1, piecesCount + add);

  // if existing orbiters match, do nothing
  if (GameState.orbiters.length >= orbCount) return;

  // spawn missing orbiters
  for (let i = GameState.orbiters.length; i < orbCount; i++) {
    GameState.orbiters.push({
      angle: (i / orbCount) * Math.PI * 2,
      radius: 80 + (i * 6),
      speed: 0.01 + (i * 0.002),
      size: 14,
      damage: Math.floor((player.currentStats?.finalATK || player.ATK) * 0.20),
      lastHitIds: new Set(), // to avoid repeated hits in same orbit tick
      createdAt: Date.now()
    });
  }
}

function updateOrbiters(deltaMs) {
  // called each tick. Move orbiters around player and check collisions
  const player = GameState.player;
  if (!player) return;
  // if player does not have Aegis equipped, clear orbiters
  const weapon = player.equipment && player.equipment.weapon;
  if (!weapon || weapon.setId !== 'aegis') {
    GameState.orbiters = [];
    return;
  }
  ensureAegisOrbiters(player);
  const playerEl = document.getElementById('player-container');
  if (!playerEl) return;

  const pRect = playerEl.getBoundingClientRect();
  const cx = pRect.left + pRect.width / 2;
  const cy = pRect.top + pRect.height / 2;

  // update each orb
  for (const orb of GameState.orbiters) {
    orb.angle += orb.speed * deltaMs;
    // compute position
    const ox = cx + Math.cos(orb.angle) * orb.radius;
    const oy = cy + Math.sin(orb.angle) * orb.radius;
    // draw DOM node for orb (create if not existing)
    if (!orb.el) {
      const el = document.createElement('div');
      el.className = 'aegis-orb';
      Object.assign(el.style, {
        position: 'absolute',
        left: `${ox}px`,
        top: `${oy}px`,
        width: `${orb.size}px`,
        height: `${orb.size}px`,
        transform: 'translate(-50%,-50%)',
        borderRadius: '50%',
        background: getElementColor('aether'),
        boxShadow: `0 0 12px ${getElementColor('aether')}`,
        pointerEvents: 'none',
        zIndex: 70
      });
      orb.el = el;
      document.getElementById('stage').appendChild(el);
    } else {
      orb.el.style.left = `${ox}px`;
      orb.el.style.top = `${oy}px`;
    }

    // collision with enemies: find any enemy whose center is within a small radius
    const hits = (GameState.enemies || []).filter(e => {
      const ex = (e.position?.x||e.x||0), ey = (e.position?.y||e.y||0);
      const dx = ex - ox, dy = ey - oy;
      return dx*dx + dy*dy <= ( (orb.size/2 + 18) * (orb.size/2 + 18) ); // collision radius
    });

    for (const en of hits) {
      if (orb.lastHitIds.has(en.id)) continue; // avoid repeating in same orb instance frequently
      applyDamageToEnemy(en, orb.damage, { type:'aether', source:'aegis_orb', setId:'aegis' });
      orb.lastHitIds.add(en.id);
      // clear the set after short timeout so orb can hit again later
      setTimeout(()=> orb.lastHitIds.delete(en.id), 600);
    }
  }
}

/* ---------- star projectile style helper (for Zephyr) ---------- */
function createStarProjectile(options) {
  // like createProjectile but star-shaped using clip-path + CSS
  const stage = document.getElementById('stage');
  if (!stage) return null;
  const stageRect = stage.getBoundingClientRect();
  const s = document.createElement('div');
  s.className = 'weapon-star';
  Object.assign(s.style, {
    position: 'absolute',
    left: `${options.fromX - stageRect.left}px`,
    top: `${options.fromY - stageRect.top}px`,
    width: `${options.size||14}px`,
    height: `${options.size||14}px`,
    pointerEvents: 'none',
    zIndex: 60,
    transform: 'translate(-50%,-50%)',
    transition: `transform ${options.travelMs||260}ms linear, opacity 180ms linear`,
    background: options.color || '#fff',
    clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
    boxShadow: `0 0 12px ${options.color||'#fff'}`
  });
  stage.appendChild(s);
  const dx = (options.toX - options.fromX);
  const dy = (options.toY - options.fromY);
  requestAnimationFrame(() => s.style.transform = `translate(${dx}px, ${dy}px)`);
  setTimeout(()=> {
    if (typeof options.onArrive === 'function') options.onArrive();
    s.remove();
  }, options.travelMs || 260);
  // safety remove
  setTimeout(()=> { if (s.parentNode) s.remove(); }, (options.travelMs||260) + 600);
}

/* ---------- Aegis circle spawner ---------- */
function spawnAegisCircle(centerX, centerY, index, totalCircles, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const radius = 60;
  const angleOffset = (index / totalCircles) * Math.PI * 2;
  const rotationSpeed = 2000; // ms per rotation

  const circle = document.createElement('div');
  circle.className = 'aegis-circle';
  Object.assign(circle.style, {
    position: 'absolute',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, #fff8c2, #f0e68c)',
    boxShadow: '0 0 15px #fff8c2',
    pointerEvents: 'none',
    zIndex: 55,
    left: `${centerX}px`,
    top: `${centerY}px`,
    transform: 'translate(-50%, -50%)'
  });

  stage.appendChild(circle);

  const startTime = Date.now();
  const duration = 3000; // circles last 3 seconds

  const animate = () => {
    const elapsed = Date.now() - startTime;
    if (elapsed > duration) {
      circle.remove();
      return;
    }

    const angle = angleOffset + (elapsed / rotationSpeed) * Math.PI * 2;
    const x = centerX + Math.cos(angle) * radius;
    const y = centerY + Math.sin(angle) * radius;

    circle.style.left = `${x}px`;
    circle.style.top = `${y}px`;

    // Check for enemy collisions
    const circleDmg = Math.floor((player.currentStats?.finalATK || player.ATK) * 0.10);
    GameState.enemies.forEach(enemy => {
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;
      const dist = Math.sqrt((x - enemyX)**2 + (y - enemyY)**2);
      if (dist < 30) { // collision radius
        applyCritDamage(enemy, circleDmg, { type: 'aether', source: 'aegis_circle', setId: 'aegis'});
      }
    });

    requestAnimationFrame(animate);
  };

  animate();
}

/* ---------- Fire zone creator ---------- */
function createFireZone(centerX, centerY, burnTick, duration, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const zone = document.createElement('div');
  zone.className = 'fire-zone';
  Object.assign(zone.style, {
    position: 'absolute',
    width: '120px',
    height: '120px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, rgba(255,138,75,0.4), rgba(255,69,0,0.2))',
    border: '2px solid rgba(255,138,75,0.6)',
    boxShadow: '0 0 20px rgba(255,138,75,0.5), inset 0 0 20px rgba(255,69,0,0.3)',
    pointerEvents: 'none',
    zIndex: 45,
    left: `${centerX}px`,
    top: `${centerY}px`,
    transform: 'translate(-50%, -50%)',
    animation: 'fire-pulse 1s infinite'
  });

  stage.appendChild(zone);

  // Track zone for damage ticks (applied in updateSetBonusesPeriodic like Bloodbath)
  const zoneData = {
    x: centerX,
    y: centerY,
    radius: 60,
    baseDamage: burnTick,
    startTime: Date.now(),
    duration: 10000, // Zone lasts 10 seconds
    burnDuration: 5000, // Each enemy burns for 5 seconds after entering
    element: zone,
    affectedEnemies: new Map() // enemyId -> { enteredAt, lastTickAt }
  };

  if (!player.emberkinFireZones) player.emberkinFireZones = [];
  player.emberkinFireZones.push(zoneData);

  // Remove zone after duration
  setTimeout(() => {
    if (zone.parentNode) zone.remove();
    player.emberkinFireZones = player.emberkinFireZones.filter(z => z !== zoneData);
  }, duration);
}

function spawnAegisHoveringBall(targetEnemy, ballDmg, duration, player, has3Piece, has6Piece) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const ball = document.createElement('div');
  Object.assign(ball.style, {
    position: 'absolute',
    width: '24px',
    height: '24px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, rgba(147,112,219,0.9), rgba(138,43,226,0.6))',
    border: '2px solid rgba(186,85,211,0.8)',
    boxShadow: '0 0 15px rgba(147,112,219,0.8)',
    pointerEvents: 'none',
    zIndex: 50
  });

  stage.appendChild(ball);

  let currentEnemy = targetEnemy;
  const startTime = Date.now();
  const hitInterval = 500; // Hit every 0.5 seconds
  let enemyDied = false;
  let deathPosition = null;

  const updateBall = setInterval(() => {
    const elapsed = Date.now() - startTime;

    // Check if ball should expire
    if (elapsed >= duration) {
      clearInterval(updateBall);
      ball.remove();
      return;
    }

    // Check if current enemy is still alive
    if (!GameState.enemies.find(e => e.id === currentEnemy.id)) {
      if (!enemyDied && has6Piece) {
        // Enemy just died - trigger 6-piece effect
        enemyDied = true;
        deathPosition = { x: currentEnemy.position?.x || currentEnemy.x || 0, y: currentEnemy.position?.y || currentEnemy.y || 0 };
        clearInterval(updateBall);
        ball.remove();

        // Spawn 2 balls that spin around the dead enemy for 3 seconds
        spawnAegis6PieceSpinBalls(deathPosition.x, deathPosition.y, player);
        return;
      }

      // Enemy died, find a random new enemy (if not 6-piece or already handled)
      const availableEnemies = GameState.enemies.filter(e => e.hp > 0);
      if (availableEnemies.length === 0) {
        clearInterval(updateBall);
        ball.remove();
        return;
      }
      currentEnemy = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
    }

    // Position ball to hover around current enemy
    const enemyEl = document.querySelector(`[data-enemy-id="${currentEnemy.id}"]`);
    if (enemyEl) {
      const rect = enemyEl.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      const angle = (elapsed / 1000) * Math.PI * 2; // Rotate around enemy
      const radius = 40;
      const offsetX = Math.cos(angle) * radius;
      const offsetY = Math.sin(angle) * radius;

      ball.style.left = `${rect.left - stageRect.left + rect.width/2 + offsetX}px`;
      ball.style.top = `${rect.top - stageRect.top + rect.height/2 + offsetY}px`;
    }
  }, 50);

  // Deal damage every hitInterval
  const damageInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;
    if (elapsed >= duration) {
      clearInterval(damageInterval);
      return;
    }

    // Check if current enemy still exists
    const enemy = GameState.enemies.find(e => e.id === currentEnemy.id);
    if (enemy) {
      applyCritDamage(enemy, ballDmg, { type: 'aether', source: 'weapon_ball', setId: 'aegis'});

      // 3-piece: Myth - 20% chance to spawn another ball (lasts 3 seconds)
      if (has3Piece && Math.random() < 0.20) {
        const mythBallDmg = Math.floor(ballDmg);
        setTimeout(() => {
          spawnAegisHoveringBall(enemy, mythBallDmg, 3000, player, false, false);
        }, 100);
      }
    } else {
      clearInterval(damageInterval);
    }
  }, hitInterval);
}

function spawnAegis6PieceSpinBalls(deathX, deathY, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const balls = [];
  const spinDuration = 3000;
  const startTime = Date.now();

  // Create 2 balls
  for (let i = 0; i < 2; i++) {
    const ball = document.createElement('div');
    Object.assign(ball.style, {
      position: 'absolute',
      width: '28px',
      height: '28px',
      borderRadius: '50%',
      background: 'radial-gradient(circle, rgba(186,85,211,1), rgba(138,43,226,0.7))',
      border: '2px solid rgba(147,112,219,1)',
      boxShadow: '0 0 20px rgba(147,112,219,1)',
      pointerEvents: 'none',
      zIndex: 52
    });
    stage.appendChild(ball);
    balls.push(ball);
  }

  const stageRect = stage.getBoundingClientRect();

  // Spin balls around death position
  const spinInterval = setInterval(() => {
    const elapsed = Date.now() - startTime;

    if (elapsed >= spinDuration) {
      clearInterval(spinInterval);

      // Launch balls to random enemies and explode
      balls.forEach((ball, index) => {
        setTimeout(() => {
          const availableEnemies = GameState.enemies.filter(e => e.hp > 0);
          if (availableEnemies.length > 0) {
            const targetEnemy = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
            const targetX = targetEnemy.position?.x || targetEnemy.x || 0;
            const targetY = targetEnemy.position?.y || targetEnemy.y || 0;

            // Animate ball moving to target
            ball.style.transition = 'all 0.5s ease-out';
            ball.style.left = `${targetX}px`;
            ball.style.top = `${targetY}px`;

            setTimeout(() => {
              // Explode and deal 200% aether damage
              const explosionDmg = Math.floor((player.currentStats?.finalATK || player.ATK) * 2.00);
              applyCritDamage(targetEnemy, explosionDmg, { type: 'aether', source: 'aegis_6piece_explosion', setId: 'aegis'});

              // Visual explosion
              const enemyEl = document.querySelector(`[data-enemy-id="${targetEnemy.id}"]`);
              if (enemyEl) {
                const rect = enemyEl.getBoundingClientRect();
                spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 80, '#9370db', 400);
              }

              ball.remove();
            }, 500);
          } else {
            ball.remove();
          }
        }, index * 100);
      });
      return;
    }

    // Spin balls around death position
    balls.forEach((ball, index) => {
      const angle = (elapsed / 1000) * Math.PI * 2 + (index * Math.PI); // Opposite sides
      const radius = 50;
      const offsetX = Math.cos(angle) * radius;
      const offsetY = Math.sin(angle) * radius;

      ball.style.left = `${deathX + offsetX}px`;
      ball.style.top = `${deathY + offsetY}px`;

      // Deal 80% damage every 500ms while spinning
      if (elapsed % 500 < 50) {
        const spinDmg = Math.floor((player.currentStats?.finalATK || player.ATK) * 0.80);
        const nearbyEnemies = findEnemiesInRadius(deathX + offsetX, deathY + offsetY, 40);
        nearbyEnemies.forEach(e => {
          applyCritDamage(e, spinDmg, { type: 'aether', source: 'aegis_6piece_spin', setId: 'aegis'});
        });
      }
    });
  }, 50);
}

function createCryoZone(centerX, centerY, aoeDmg, duration, player) {
  const stage = document.getElementById('stage');
  if (!stage) return;

  const zone = document.createElement('div');
  zone.className = 'cryo-zone';
  Object.assign(zone.style, {
    position: 'absolute',
    width: '140px',
    height: '140px',
    borderRadius: '50%',
    background: 'radial-gradient(circle, rgba(135,206,250,0.4), rgba(70,130,180,0.2))',
    border: '2px solid rgba(135,206,250,0.6)',
    boxShadow: '0 0 25px rgba(135,206,250,0.6), inset 0 0 25px rgba(70,130,180,0.3)',
    pointerEvents: 'none',
    zIndex: 45,
    left: `${centerX}px`,
    top: `${centerY}px`,
    transform: 'translate(-50%, -50%)',
    animation: 'fire-pulse 1.5s infinite'
  });

  stage.appendChild(zone);

  // Track which enemies are in the zone and apply freeze + DoT
  const affectedEnemies = new Map(); // enemyId -> { frozenAt, lastTickAt }

  // Check for enemies in zone every 100ms
  const checkInterval = setInterval(() => {
    GameState.enemies.forEach(enemy => {
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;
      const dist = Math.sqrt((centerX - enemyX)**2 + (centerY - enemyY)**2);

      if (dist < 70) { // zone radius
        const now = Date.now();

        // If enemy just entered zone, freeze them for 3 seconds
        if (!affectedEnemies.has(enemy.id)) {
          affectedEnemies.set(enemy.id, { frozenAt: now, lastTickAt: now });

          // Actually freeze the enemy (set frozen flag and stop movement)
          enemy.frozen = true;
          enemy.frozenTimer = 3.0; // 3 second freeze
          enemy.frozenAt = now;
          enemy.originalSpeed = enemy.speed;
          enemy.speed = 0;

          // Apply freeze visual (handled by updateEnemies now)
          const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
          if (enemyEl) {
            enemyEl.style.filter = 'brightness(1.5) saturate(0.3) hue-rotate(180deg)';
          }
        }

        // Deal damage every tick (1 second) for 3 seconds
        const enemyData = affectedEnemies.get(enemy.id);
        if (enemyData && now - enemyData.lastTickAt >= 1000 && now - enemyData.frozenAt < 3000) {
          applyCritDamage(enemy, aoeDmg, { type: 'cryo', source: 'weapon_zone', setId: 'glacier'});
          enemyData.lastTickAt = now;
        }
      }
    });
  }, 100);

  // Remove zone after duration
  setTimeout(() => {
    clearInterval(checkInterval);
    zone.remove();
  }, duration);
}

// Helper function to calculate weapon damage with all bonuses including DMG%
function calculateWeaponDamage(player, multiplier) {
  const baseATK = player.currentStats?.finalATK || player.ATK;
  const baseDmg = Math.floor(baseATK * multiplier);
  
  // Apply DMG% bonus
  const dmgPct = player.currentStats?.finalDMGPct || 0;
  const finalDmg = Math.floor(baseDmg * (1 + dmgPct / 100));
  
  return finalDmg;
}

const WEAPON_HANDLERS = {
  // Aquila Longbow (Skywarden) - wind green, pushback, big explosion on kill
  skywarden: (p, enemy, weapon) => {
    const element = 'wind';
    const baseDmg = Math.floor((p.currentStats?.finalATK || p.ATK || 0) * 1.20);
    const { damage: windDmg, crit: isCrit } = rollCrit(baseDmg);
    
    // arrow projectile (green)
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    const playerEl = document.getElementById('player-container');
    if (playerEl && enemyEl) {
      const fromR = playerEl.getBoundingClientRect();
      const toR = enemyEl.getBoundingClientRect();
      createProjectile({
        fromX: fromR.left + fromR.width/2, fromY: fromR.top + fromR.height/2,
        toX: toR.left + toR.width/2, toY: toR.top + toR.height/2,
        color: getElementColor(element), size: 36, travelMs: 200,
        onArrive: ()=> spawnShockwave(toR.left + toR.width/2, toR.top + toR.height/2, 24, getElementColor(element), 180)
      });
    }
    applyDamageToEnemy(enemy, windDmg, { type: element, source: 'weapon', setId: 'skywarden', crit: isCrit });

    // Randomly pushes that enemy and 2 nearby enemies back and deal 50% wind damage to them
    const pushbackRadius = 150;
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;
    const playerX = playerEl ? (playerEl.getBoundingClientRect().left + playerEl.getBoundingClientRect().width/2) : 0;
    const playerY = playerEl ? (playerEl.getBoundingClientRect().top + playerEl.getBoundingClientRect().height/2) : 0;

    // Find 2 nearby enemies (excluding the main target)
    const nearbyEnemies = findEnemiesInRadius(enemyX, enemyY, pushbackRadius).filter(e => e.id !== enemy.id);
    const shuffled = nearbyEnemies.sort(() => 0.5 - Math.random());
    const pushTargets = [enemy, ...shuffled.slice(0, 2)]; // Main target + 2 nearby
    const basePushDmg = Math.floor((p.currentStats?.finalATK || p.ATK || 0) * 0.50);

    pushTargets.forEach(target => {
      // Apply 50% wind damage to all 3 targets (with individual crit rolls)
      if (target.id !== enemy.id) {
        const { damage: pushDmg, crit: pushCrit } = rollCrit(basePushDmg);
        applyDamageToEnemy(target, pushDmg, { type: element, source: 'weapon_pushback', setId: 'skywarden', crit: pushCrit });
      }

      // Push enemy away from player
      const dx = (target.position?.x || target.x || 0) - playerX;
      const dy = (target.position?.y || target.y || 0) - playerY;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const pushDistance = 20;
      target.position.x += (dx / dist) * pushDistance;
      target.position.y += (dy / dist) * pushDistance;
    });

    // After enemy dies to wind damage, create AOE explosion (150% wind damage to surrounding enemies)
    if (enemy.hp <= 0) {
      const baseExplosionDmg = Math.floor((p.currentStats?.finalATK || p.ATK || 0) * 0.50);
      const explosionRadius = 120;

      if (enemyEl) {
        const eR = enemyEl.getBoundingClientRect();
        const centerX = eR.left + eR.width/2;
        const centerY = eR.top + eR.height/2;

        // Create expanding wind shockwave explosion
        spawnShockwave(centerX, centerY, 120, getElementColor(element), 500);

        // Add a second smaller shockwave for depth
        setTimeout(() => {
          spawnShockwave(centerX, centerY, 80, getElementColor(element), 300);
        }, 100);
      }

      const nearbyEnemiesExplosion = findEnemiesInRadius(enemyX, enemyY, explosionRadius);
      nearbyEnemiesExplosion.forEach(e => {
        if (e.id !== enemy.id) {
          const { damage: explosionDmg, crit: explCrit } = rollCrit(baseExplosionDmg);
          applyDamageToEnemy(e, explosionDmg, { type: element, source: 'weapon_explosion', setId: 'skywarden', crit: explCrit });

          // Push enemies away from explosion center
          const dx = (e.position?.x || e.x || 0) - enemyX;
          const dy = (e.position?.y || e.y || 0) - enemyY;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const pushDistance = 80;
          e.position.x += (dx / dist) * pushDistance;
          e.position.y += (dy / dist) * pushDistance;
        }
      });
    }
  },

  // Storm Pike (Stormbreaker) - purple lightning arc & chaining arcs
  stormbreaker: (p, enemy, weapon) => {
    const element = 'lightning';
    const main = calculateWeaponDamage(p, 1.20);
    const playerEl = document.getElementById('player-container');
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    let px = 0, py = 0, ex = 0, ey = 0;
    if (playerEl && enemyEl) {
      const pr = playerEl.getBoundingClientRect();
      const er = enemyEl.getBoundingClientRect();
      px = pr.left + pr.width/2; py = pr.top + pr.height/2;
      ex = er.left + er.width/2; ey = er.top + er.height/2;
      createLightningArc(px, py, ex, ey, getElementColor(element), 220);
    } else {
      createProjectile({ fromX: px, fromY: py, toX: ex, toY: ey, color: getElementColor(element), size: 10, travelMs: 200 });
    }
    applyCritDamage(enemy, main, { type: element, source: 'weapon', setId: 'stormbreaker'});

    const has3Piece = getSetCount('stormbreaker') >= 3;
    const has6Piece = getSetCount('stormbreaker') >= 6;
    const chainRadius = 200;
    const centerX = enemy.position?.x || enemy.x || 0;
    const centerY = enemy.position?.y || enemy.y || 0;

    if (has6Piece) {
      // Multishot: Create 3 lightning arcs to that enemy and 2 random enemies not nearby each other, 120% damage each
      const allEnemies = GameState.enemies.filter(e => e.id !== enemy.id && e.hp > 0);
      const multishotTargets = [];
      const usedIds = new Set([enemy.id]);

      // Select first random enemy
      if (allEnemies.length > 0) {
        const first = allEnemies[Math.floor(Math.random() * allEnemies.length)];
        multishotTargets.push(first);
        usedIds.add(first.id);

        // Select second random enemy NOT nearby the first one
        const firstX = first.position?.x || first.x || 0;
        const firstY = first.position?.y || first.y || 0;
        const minDistance = 200; // Minimum distance to be considered "not nearby"

        const farEnemies = allEnemies.filter(e => {
          if (usedIds.has(e.id)) return false;
          const ex = e.position?.x || e.x || 0;
          const ey = e.position?.y || e.y || 0;
          const dist = Math.sqrt((ex - firstX)**2 + (ey - firstY)**2);
          return dist >= minDistance;
        });

        if (farEnemies.length > 0) {
          const second = farEnemies[Math.floor(Math.random() * farEnemies.length)];
          multishotTargets.push(second);
          usedIds.add(second.id);
        } else if (allEnemies.length > 1) {
          // If no far enemies, just pick another random one
          const remaining = allEnemies.filter(e => !usedIds.has(e.id));
          if (remaining.length > 0) {
            const second = remaining[Math.floor(Math.random() * remaining.length)];
            multishotTargets.push(second);
            usedIds.add(second.id);
          }
        }
      }

      // Fire lightning arcs to the multishot targets
      multishotTargets.forEach((target, index) => {
        setTimeout(() => {
          const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
          if (playerEl && targetEl) {
            const pr = playerEl.getBoundingClientRect();
            const tr = targetEl.getBoundingClientRect();
            createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                             tr.left + tr.width/2, tr.top + tr.height/2,
                             getElementColor(element), 220);
          }
          const multishotDmg = calculateWeaponDamage(p, 1.20);
          applyCritDamage(target, multishotDmg, { type: element, source:'multishot', setId:'stormbreaker'});
        }, (index + 1) * 100);
      });

      // Then continue with guaranteed chains from 3-piece (from the multishot targets)
      if (multishotTargets.length > 0) {
        setTimeout(() => {
          const lastTarget = multishotTargets[multishotTargets.length - 1];
          const chainFrom = lastTarget;
          const chainFromPos = { x: chainFrom.position?.x || chainFrom.x || 0, y: chainFrom.position?.y || chainFrom.y || 0 };

          // At least 1 more guaranteed chain (total 4 hits including main + 2 multishot + 1 chain)
          const chainCandidates = findEnemiesInRadius(chainFromPos.x, chainFromPos.y, chainRadius).filter(e => !usedIds.has(e.id));
          if (chainCandidates.length > 0) {
            chainCandidates.sort((a,b) => {
              const ax = (a.position?.x||a.x||0)-chainFromPos.x, ay = (a.position?.y||a.y||0)-chainFromPos.y;
              const bx = (b.position?.x||b.x||0)-chainFromPos.x, by = (b.position?.y||b.y||0)-chainFromPos.y;
              return (ax*ax+ay*ay) - (bx*bx+by*by);
            });
            const chainTarget = chainCandidates[0];
            const chainTargetEl = document.querySelector(`[data-enemy-id="${chainTarget.id}"]`);
            const chainFromEl = document.querySelector(`[data-enemy-id="${chainFrom.id}"]`);

            if (chainFromEl && chainTargetEl) {
              const fr = chainFromEl.getBoundingClientRect();
              const tr = chainTargetEl.getBoundingClientRect();
              createLightningArc(fr.left + fr.width/2, fr.top + fr.height/2,
                               tr.left + tr.width/2, tr.top + tr.height/2,
                               getElementColor(element), 200);
              const chainDmg = calculateWeaponDamage(p, 1.20);
              applyCritDamage(chainTarget, chainDmg, { type: element, source:'multishot_chain', setId:'stormbreaker'});
            }
          }
        }, 400);
      }
    } else if (has3Piece) {
      // Lightning Surge: Guaranteed 2+ hits, 75% damage, 50% for 4th, 25% for 5th
      const usedIds = new Set([enemy.id]);
      let prevEnemy = enemy;
      const surgeDmg = calculateWeaponDamage(p, 0.75);

      // Guaranteed 2 hits
      for (let i = 0; i < 2; i++) {
        const candidates = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
        if (candidates.length === 0) break;

        candidates.sort((a,b) => {
          const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
          const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
          return (ax*ax+ay*ay) - (bx*bx+by*by);
        });
        const target = candidates[0];
        const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
        const prevEl = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);

        if (prevEl && targetEl) {
          const pr = prevEl.getBoundingClientRect();
          const tr = targetEl.getBoundingClientRect();
          setTimeout(() => {
            createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                             tr.left + tr.width/2, tr.top + tr.height/2,
                             getElementColor(element), 200);
            applyCritDamage(target, surgeDmg, { type: element, source:'lightning_surge', setId:'stormbreaker'});
          }, (i + 1) * 150);
        }

        usedIds.add(target.id);
        prevEnemy = target;
      }

      // 50% chance for 4th enemy
      if (Math.random() < 0.50) {
        const candidates = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
        if (candidates.length > 0) {
          candidates.sort((a,b) => {
            const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
            const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
            return (ax*ax+ay*ay) - (bx*bx+by*by);
          });
          const target = candidates[0];
          const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
          const prevEl = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
          if (prevEl && targetEl) {
            const pr = prevEl.getBoundingClientRect();
            const tr = targetEl.getBoundingClientRect();
            setTimeout(() => {
              createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                               tr.left + tr.width/2, tr.top + tr.height/2,
                               getElementColor(element), 200);
              applyCritDamage(target, surgeDmg, { type: element, source:'lightning_surge', setId:'stormbreaker'});
            }, 450);
          }
          usedIds.add(target.id);
          prevEnemy = target;

          // 25% chance for 5th enemy
          if (Math.random() < 0.25) {
            const candidates2 = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
            if (candidates2.length > 0) {
              candidates2.sort((a,b) => {
                const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
                const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
                return (ax*ax+ay*ay) - (bx*bx+by*by);
              });
              const target2 = candidates2[0];
              const target2El = document.querySelector(`[data-enemy-id="${target2.id}"]`);
              const prevEl2 = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
              if (prevEl2 && target2El) {
                const pr = prevEl2.getBoundingClientRect();
                const tr = target2El.getBoundingClientRect();
                setTimeout(() => {
                  createLightningArc(pr.left + pr.width/2, pr.top + pr.height/2,
                                   tr.left + tr.width/2, tr.top + tr.height/2,
                                   getElementColor(element), 200);
                  applyCritDamage(target2, surgeDmg, { type: element, source:'lightning_surge', setId:'stormbreaker'});
                }, 600);
              }
            }
          }
        }
      }
    } else {
      // Original chaining: 50% for 2nd (75%), 25% for 3rd (50%)
      const usedIds = new Set([enemy.id]);
      let prevEnemy = enemy;

      if (Math.random() < 0.50) {
        const candidates = findEnemiesInRadius(centerX, centerY, chainRadius).filter(e => !usedIds.has(e.id));
        if (candidates.length > 0) {
          candidates.sort((a,b) => {
            const ax = (a.position?.x||a.x||0)-centerX, ay = (a.position?.y||a.y||0)-centerY;
            const bx = (b.position?.x||b.x||0)-centerX, by = (b.position?.y||b.y||0)-centerY;
            return (ax*ax+ay*ay) - (bx*bx+by*by);
          });
          const target = candidates[0];
          const targetEl = document.querySelector(`[data-enemy-id="${target.id}"]`);
          const prevEl = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
          let fromX = centerX, fromY = centerY, toX = target.position?.x||target.x||0, toY = target.position?.y||target.y||0;
          if (prevEl) {
            const r = prevEl.getBoundingClientRect(); fromX = r.left + r.width/2; fromY = r.top + r.height/2;
          }
          if (targetEl) { const rr = targetEl.getBoundingClientRect(); toX = rr.left + rr.width/2; toY = rr.top + rr.height/2; }
          createLightningArc(fromX, fromY, toX, toY, getElementColor(element), 200);
          const chainDmg = calculateWeaponDamage(p, 0.75);
          applyCritDamage(target, chainDmg, { type: element, source:'weapon_chain', setId:'stormbreaker'});
          usedIds.add(target.id);
          prevEnemy = target;

          if (Math.random() < 0.25) {
            const centerX2 = target.position?.x || target.x || 0;
            const centerY2 = target.position?.y || target.y || 0;
            const candidates2 = findEnemiesInRadius(centerX2, centerY2, chainRadius).filter(e => !usedIds.has(e.id));
            if (candidates2.length > 0) {
              candidates2.sort((a,b) => {
                const ax = (a.position?.x||a.x||0)-centerX2, ay = (a.position?.y||a.y||0)-centerY2;
                const bx = (b.position?.x||b.x||0)-centerX2, by = (b.position?.y||b.y||0)-centerY2;
                return (ax*ax+ay*ay) - (bx*bx+by*by);
              });
              const target2 = candidates2[0];
              const target2El = document.querySelector(`[data-enemy-id="${target2.id}"]`);
              const prev2El = document.querySelector(`[data-enemy-id="${prevEnemy.id}"]`);
              let fromX2 = centerX2, fromY2 = centerY2, toX2 = target2.position?.x||target2.x||0, toY2 = target2.position?.y||target2.y||0;
              if (prev2El) {
                const r = prev2El.getBoundingClientRect(); fromX2 = r.left + r.width/2; fromY2 = r.top + r.height/2;
              }
              if (target2El) { const rr = target2El.getBoundingClientRect(); toX2 = rr.left + rr.width/2; toY2 = rr.top + rr.height/2; }
              createLightningArc(fromX2, fromY2, toX2, toY2, getElementColor(element), 230);
              const chainDmg2 = calculateWeaponDamage(p, 0.50);
              applyCritDamage(target2, chainDmg2, { type: element, source:'weapon_chain', setId:'stormbreaker'});
            }
          }
        }
      }
    }
  },

  bastion: (p, enemy, weapon) => {
    const element = 'physical';
    const atkComponent = (p.currentStats?.finalATK || p.ATK) * 1.20;
    const hpComponent = (getPlayerHP(p) || 0) * 0.30;
    const total = Math.floor(atkComponent + hpComponent);
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    const cx = enemyEl ? (enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2) : (enemy.x||0);
    const cy = enemyEl ? (enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2) : (enemy.y||0);
    spawnShockwave(cx, cy, 48, getElementColor('physical'), 360);
    applyCritDamage(enemy, total, { type: element, source:'weapon', setId:'bastion'});

    // AoE damage: 80% physical damage equal to 20% player HP
    const aoeHpComponent = (getPlayerHP(p) || 0) * 0.20;
    const aoeDmg = Math.floor(calculateWeaponDamage(p, 0.80) + aoeHpComponent);
    const aoeRadius = 100;
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;

    const nearbyEnemies = findEnemiesInRadius(enemyX, enemyY, aoeRadius);
    nearbyEnemies.forEach(e => {
      if (e.id !== enemy.id) {
        applyCritDamage(e, aoeDmg, { type: element, source: 'weapon_aoe', setId: 'bastion'});
      }
    });
  },

  // Raven's Volley - Repeating crossbow with bouncing coins
  nightwing: (p, enemy, weapon) => {
    const element = 'physical';
    const atkComp = (p.currentStats?.finalATK || p.ATK) * 1.20;
    const mainDmg = Math.floor(atkComp);

    // Main attack visual and damage
    const playerEl = document.getElementById('player-container');
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (playerEl && enemyEl) {
      const pR = playerEl.getBoundingClientRect();
      const eR = enemyEl.getBoundingClientRect();
      createProjectile({ fromX:pR.left+pR.width/2, fromY:pR.top+pR.height/2, toX:eR.left+eR.width/2, toY:eR.top+eR.height/2, color: getElementColor('physical'), size:10, travelMs:220 });
    }
    applyCritDamage(enemy, mainDmg, { type: element, source:'weapon', setId:'nightwing'});

    // After hit, spawn 2 bouncing coins that bounce 3 times each
    const coins = (p.coins || 0);
    const coinDmg = Math.floor(coins * 0.0077);

    for (let coinNum = 0; coinNum < 2; coinNum++) {
      let currentEnemy = enemy;
      const usedIds = new Set([enemy.id]);

      for (let bounce = 0; bounce < 3; bounce++) {
        setTimeout(() => {
          const candidates = GameState.enemies.filter(e => !usedIds.has(e.id));
          if (candidates.length === 0) return;

          const nextEnemy = candidates[Math.floor(Math.random() * candidates.length)];
          usedIds.add(nextEnemy.id);

          const fromEl = document.querySelector(`[data-enemy-id="${currentEnemy.id}"]`);
          const toEl = document.querySelector(`[data-enemy-id="${nextEnemy.id}"]`);

          if (fromEl && toEl) {
            const fromR = fromEl.getBoundingClientRect();
            const toR = toEl.getBoundingClientRect();
            createProjectile({
              fromX: fromR.left + fromR.width/2,
              fromY: fromR.top + fromR.height/2,
              toX: toR.left + toR.width/2,
              toY: toR.top + toR.height/2,
              color: '#ffd700',
              size: 12,
              travelMs: 200,
              onArrive: () => {
                applyCritDamage(nextEnemy, coinDmg, { type: element, source: 'weapon_coin', setId: 'nightwing'});
                showElementDamage(coinDmg, 'physical', toEl, false, '#ffd700');
              }
            });
          }

          currentEnemy = nextEnemy;
        }, bounce * 250 + coinNum * 100);
      }
    }
  },

  // Wraith Scythe - HP sacrifice with execute and lifesteal on kill
  shade: (p, enemy, weapon) => {
    const element = 'physical';
    const small = calculateWeaponDamage(p, 0.50);

    // Lose 2% max HP, but if player has lower than 2% max HP, set HP to 1
    const hpMax = p.maxHp || p.HP_max || 1;
    const currentHP = getPlayerHP(p);
    const twoPercentHP = Math.floor(hpMax * 0.02);

    let hpLost = twoPercentHP;
    let newHP = currentHP - hpLost;

    // If current HP is lower than 2% max HP or would go below 1, set to 1
    if (currentHP <= twoPercentHP || newHP < 1) {
      hpLost = Math.max(0, currentHP - 1);
      newHP = 1;
    }

    setPlayerHP(p, newHP);

    // Track HP loss for Overflow stacks
    if (!p.lossAccumulator) p.lossAccumulator = 0;
    p.lossAccumulator += hpLost;

    // Deal 200% physical damage + 200% of HP lost
    // 3-piece: Bloodbath - increase damage dealt by HP lost by 200% (so 200% becomes 400% total)
    let hpLostMultiplier = 2.00;
    if (getSetCount('shade') >= 3) {
      hpLostMultiplier = 4.00; // 200% base + 200% bonus = 400%
    }
    const execDmg = Math.floor(calculateWeaponDamage(p, 2.00) + hpLostMultiplier * hpLost);

    // Red execute VFX
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      createProjectile({
        fromX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2 + 120,
        fromY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2 - 40,
        toX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2,
        toY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2,
        color: '#ff3b3b', size: 26, travelMs: 180,
        onArrive: ()=> spawnShockwave(
          enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2,
          enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2,
          44, '#ff3b3b', 300
        )
      });
    }

    applyCritDamage(enemy, execDmg, { type: element, source:'weapon_hp_loss', setId:'shade'});

    // 3-piece: Bloodbath - create rain area for 5 seconds dealing 300% of HP lost every tick
    if (getSetCount('shade') >= 3) {
      const rainDmg = Math.floor(hpLost * 3.00);
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;

      // Create visual rain zone
      const stage = document.getElementById('stage');
      if (stage) {
        const rainZone = document.createElement('div');
        rainZone.style.cssText = `position:absolute;left:${enemyX}px;top:${enemyY}px;width:100px;height:100px;border-radius:50%;background:radial-gradient(circle,rgba(255,59,59,0.4),rgba(139,0,0,0.2));border:2px solid #8b0000;transform:translate(-50%,-50%);pointer-events:none;z-index:40;`;
        document.getElementById('enemy-layer').appendChild(rainZone);

        // Add rain particles
        const particleInterval = setInterval(() => {
          if (!rainZone.parentNode) {
            clearInterval(particleInterval);
            return;
          }

          for (let i = 0; i < 3; i++) {
            const particle = document.createElement('div');
            const offsetX = (Math.random() - 0.5) * 80;
            const offsetY = (Math.random() - 0.5) * 80;
            particle.style.cssText = `position:absolute;left:${enemyX + offsetX}px;top:${enemyY + offsetY - 60}px;width:2px;height:12px;background:linear-gradient(180deg,rgba(255,59,59,0.8),rgba(139,0,0,0.4));transform:translate(-50%,0);pointer-events:none;z-index:41;transition:all 0.6s linear;opacity:1;`;
            document.getElementById('enemy-layer').appendChild(particle);

            setTimeout(() => {
              particle.style.top = `${enemyY + offsetY + 40}px`;
              particle.style.opacity = '0';
            }, 10);

            setTimeout(() => particle.remove(), 650);
          }
        }, 150);

        setTimeout(() => clearInterval(particleInterval), 5000);

        // Track zone for damage ticks
        const zoneData = {
          x: enemyX,
          y: enemyY,
          radius: 50,
          damage: rainDmg,
          startTime: Date.now(),
          duration: 5000,
          element: rainZone
        };

        if (!p.shadeRainZones) p.shadeRainZones = [];
        p.shadeRainZones.push(zoneData);

        setTimeout(() => {
          if (rainZone.parentNode) rainZone.remove();
          p.shadeRainZones = p.shadeRainZones.filter(z => z !== zoneData);
        }, 5000);
      }
    }

    // If enemy dies, restore 5% max HP
    if (enemy.hp <= 0) {
      const healAmount = Math.floor(hpMax * 0.05);
      const newHPAfterHeal = Math.min(hpMax, getPlayerHP(p) + healAmount);
      setPlayerHP(p, newHPAfterHeal);

      // Track healing for Overflow stacks
      if (!p.healAccumulator) p.healAccumulator = 0;
      p.healAccumulator += healAmount;

      // Show heal visual
      showFloatingChange(healAmount, 'heal');
    }

    // 6-piece: Overflow - if player <50% HP, heal to full and create explosion
    if (getSetCount('shade') >= 6) {
      const currentHP = getPlayerHP(p);
      const halfHP = hpMax * 0.50;

      if (currentHP < halfHP) {
        setPlayerHP(p, hpMax);
        showFloatingChange(hpMax - currentHP, 'heal');

        // Create giant red explosion
        const stage = document.getElementById('stage');
        const playerEl = document.getElementById('player-container');
        if (playerEl && stage) {
          const rect = playerEl.getBoundingClientRect();
          const stageRect = stage.getBoundingClientRect();
          const explosionDmg = Math.floor((p.lossAccumulator || 0) * 5.00);

          // Create giant red explosion with shockwave
          const centerX = rect.left + rect.width/2;
          const centerY = rect.top + rect.height/2;

          spawnShockwave(centerX, centerY, 200, '#ff0000', 600);

          // Add explosion particles radiating outward
          for (let i = 0; i < 30; i++) {
            const angle = (i / 30) * Math.PI * 2;
            const distance = 200;
            const particleX = centerX + Math.cos(angle) * distance;
            const particleY = centerY + Math.sin(angle) * distance;

            const particle = document.createElement('div');
            particle.style.cssText = `position:absolute;left:${centerX - stageRect.left}px;top:${centerY - stageRect.top}px;width:16px;height:16px;border-radius:50%;background:radial-gradient(circle,rgba(255,59,59,1),rgba(139,0,0,0.6));transform:translate(-50%,-50%);pointer-events:none;z-index:65;transition:all 0.6s ease-out;opacity:1;box-shadow:0 0 12px rgba(255,59,59,0.8);`;
            stage.appendChild(particle);

            setTimeout(() => {
              particle.style.left = `${particleX - stageRect.left}px`;
              particle.style.top = `${particleY - stageRect.top}px`;
              particle.style.opacity = '0';
              particle.style.width = '4px';
              particle.style.height = '4px';
            }, 10);

            setTimeout(() => particle.remove(), 650);
          }

          const playerX = stage.clientWidth / 2;
          const playerY = stage.clientHeight / 2;

          GameState.enemies.forEach(e => {
            const dx = playerX - (e.position?.x || e.x || 0);
            const dy = playerY - (e.position?.y || e.y || 0);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= 200) {
              applyCritDamage(e, explosionDmg, { type: 'physical', source: 'overflow_explosion', setId: 'shade'});
            }
          });

          showNotification('ðŸ’€ Overflow! Full heal + massive explosion!', 'legendary');
        }
      }
    }
  },

  // Aegis Scepter - launches a ball that hovers around enemy dealing continuous damage
  aegis: (p, enemy, weapon) => {
    const element = 'aether';
    const has3Piece = getSetCount('aegis') >= 3;
    const has6Piece = getSetCount('aegis') >= 6;

    // Base ball: 120% damage, 2 second duration
    const dmg = calculateWeaponDamage(p, 1.20);
    applyCritDamage(enemy, dmg, { type: element, source:'weapon', setId:'aegis'});

    // Launch ball that hovers and deals damage
    const ballDmg = calculateWeaponDamage(p, 1.20);
    spawnAegisHoveringBall(enemy, ballDmg, 2000, p, has3Piece, has6Piece);
  },

  glacier: (p, enemy, weapon) => {
    const element = 'cryo';
    const cryoDmg = calculateWeaponDamage(p, 1.20);
    applyCritDamage(enemy, cryoDmg, { type: element, source:'weapon', setId:'glacier'});

    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      spawnShockwave(enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2, enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2, 28, getElementColor(element), 260);
    }

    // Freeze enemy for 2 seconds - if enemy is already frozen before, they can't be frozen again for 10 seconds
    const now = Date.now();
    if (!enemy.freezeCooldownUntil || now >= enemy.freezeCooldownUntil) {
      enemy.frozen = true;
      enemy.frozenTimer = 2.0; // 2 second freeze
      enemy.frozenAt = now;
      enemy.originalSpeed = enemy.speed;
      enemy.speed = 0; // Stop movement while frozen

      // Set cooldown: after unfrozen, can't freeze again for 10 seconds
      enemy.freezeCooldownUntil = now + 12000; // 2s freeze + 10s cooldown
    }

    // After enemy is dead, create a cryo AOE that freezes enemies
    if (enemy.hp <= 0) {
      const enemyX = enemy.position?.x || enemy.x || 0;
      const enemyY = enemy.position?.y || enemy.y || 0;
      const aoeDmg = calculateWeaponDamage(p, 0.10);

      // Create cryo AOE zone that freezes enemies for 3 seconds and deals 10% cryo damage every tick
      createCryoZone(enemyX, enemyY, aoeDmg, 5000, p);
    }
  },

  // Emberkin - Inferno Blade: instant damage + fire AoE zone
  emberkin: (p, enemy, weapon) => {
    const element = 'fire';
    const instant = calculateWeaponDamage(p, 1.20);
    const burnTick = calculateWeaponDamage(p, 0.20);

    applyCritDamage(enemy, instant, { type: element, source:'weapon', setId:'emberkin'});

    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      createProjectile({
        fromX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2 + 80,
        fromY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2 - 20,
        toX: enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2,
        toY: enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2,
        color: getElementColor(element), size: 18, travelMs: 200
      });
    }

    // Create fire AoE zone that lasts 10 seconds
    // Enemies entering or within the AOE take 20% fire damage every tick for 5 seconds
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;
    createFireZone(enemyX, enemyY, burnTick, 10000, p);
  },

  // Zephyr - Gale Daggers: stars (star-shaped) and explosions
  zephyr: (p, enemy, weapon) => {
    const element = 'aether';
    const main = calculateWeaponDamage(p, 1.20);
    applyCritDamage(enemy, main, { type: element, source:'weapon', setId:'zephyr'});

    // 4-piece: +2 stars (6 total)
    let nStars = 4;
    if (getSetCount('zephyr') >= 4) nStars = 6;

    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    const fromX = enemyEl ? (enemyEl.getBoundingClientRect().left + enemyEl.getBoundingClientRect().width/2) : (enemy.x||0);
    const fromY = enemyEl ? (enemyEl.getBoundingClientRect().top + enemyEl.getBoundingClientRect().height/2) : (enemy.y||0);

    const starDmg = calculateWeaponDamage(p, 0.50);

    for (let i=0;i<nStars;i++){
      const candidates = GameState.enemies.filter(e => e.id !== enemy.id);
      const randTarget = candidates.length ? candidates[Math.floor(Math.random()*candidates.length)] : null;
      const toX = randTarget ? (randTarget.position?.x||randTarget.x||0) : (fromX + (Math.random()*240 - 120));
      const toY = randTarget ? (randTarget.position?.y||randTarget.y||0) : (fromY + (Math.random()*240 - 120));

      createStarProjectile({
        fromX, fromY, toX, toY, color: getElementColor(element), size: 12, travelMs: 260,
        onArrive: ()=> {
          const hits = findEnemiesInRadius(toX, toY, 40);
          hits.forEach(h => {
            applyCritDamage(h, starDmg, { type: element, source:'weapon_star', setId:'zephyr'});

            // 3-piece: Blow - explosion on each star collision
            if (getSetCount('zephyr') >= 3) {
              const explosionDmg = calculateWeaponDamage(p, 0.50);
              const nearbyEnemies = findEnemiesInRadius(toX, toY, 80);
              nearbyEnemies.forEach(ne => {
                if (ne.id !== h.id) {
                  applyCritDamage(ne, explosionDmg, { type: element, source:'zephyr_explosion', setId:'zephyr'});
                }
              });
              const hitEl = document.querySelector(`[data-enemy-id="${h.id}"]`);
              if (hitEl) {
                const rect = hitEl.getBoundingClientRect();
                spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 60, getElementColor(element), 300);
              }
            }
          });

          // 6-piece: Bounce to another random enemy
          if (getSetCount('zephyr') >= 6 && hits.length > 0) {
            const bounceCandidates = GameState.enemies.filter(e => !hits.some(h => h.id === e.id));
            if (bounceCandidates.length > 0) {
              const bounceTarget = bounceCandidates[Math.floor(Math.random() * bounceCandidates.length)];
              const bounceToX = bounceTarget.position?.x || bounceTarget.x || 0;
              const bounceToY = bounceTarget.position?.y || bounceTarget.y || 0;

              setTimeout(() => {
                createStarProjectile({
                  fromX: toX, fromY: toY, toX: bounceToX, toY: bounceToY,
                  color: getElementColor(element), size: 12, travelMs: 260,
                  onArrive: () => {
                    applyCritDamage(bounceTarget, starDmg, { type: element, source:'weapon_star_bounce', setId:'zephyr'});
                    if (getSetCount('zephyr') >= 3) {
                      const explosionDmg = calculateWeaponDamage(p, 0.50);
                      const nearbyEnemies = findEnemiesInRadius(bounceToX, bounceToY, 80);
                      nearbyEnemies.forEach(ne => {
                        if (ne.id !== bounceTarget.id) {
                          applyCritDamage(ne, explosionDmg, { type: element, source:'zephyr_explosion', setId:'zephyr'});
                        }
                      });
                    }
                  }
                });
              }, 100);
            }
          }
        }
      });
    }
  }
}; // end WEAPON_HANDLERS
/* ---------- Updated attackEnemy to call weapon handler ---------- */

/* ---------- attackEnemy: updated to skip click when Aegis equipped ---------- */
function attackEnemy(enemy) {
  if (GameState.isDead || !GameState.canAttack) return;

  const player = GameState.player;
  const weaponItem = player.equipment && player.equipment.weapon;
  const hasSetWeapon = weaponItem && weaponItem.setId;
  const isAegisEquipped = weaponItem && weaponItem.setId === 'aegis';

  // If player has a weapon from a set: Deal ONLY Element Damage (no physical click damage)
  // If player has no weapon or non-set weapon: Deal physical damage normally
  if (!hasSetWeapon) {
    // No set weapon equipped - deal normal physical click damage
    const clickResult = computeDamage(enemy);
    enemy.hp -= clickResult.damage;
    enemy.lastHit = { type: 'physical', source: 'click', setId: null, damage: clickResult.damage };
    // show click number
    const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
    if (enemyEl) {
      const n = document.createElement('div');
      n.className = 'drop-item';
      n.textContent = clickResult.crit ? `${clickResult.damage.toLocaleString()}!` : `${clickResult.damage.toLocaleString()}`;
      n.style.left = `${enemy.position?.x || enemy.x || 0}px`;
      n.style.top = `${(enemy.position?.y || enemy.y || 0) - 30}px`;
      n.style.color = clickResult.crit ? '#ff0' : '#fff';
      n.style.fontWeight = '700';
      document.getElementById('drop-layer').appendChild(n);
      setTimeout(()=> n.remove(), 1400);
    }
  } else if (isAegisEquipped) {
    // Aegis special case: ensure orbiters spawn and show small pulse
    ensureAegisOrbiters(player);
    const playerEl = document.getElementById('player-container');
    if (playerEl) {
      const pr = playerEl.getBoundingClientRect();
      spawnShockwave(pr.left + pr.width/2, pr.top + pr.height/2, 32, getElementColor('aether'), 220);
    }
  }
  // Note: If hasSetWeapon is true (but not Aegis), we skip physical damage entirely
  // and only deal elemental damage through the weapon handler below

  // Weapon unique attack - deals ONLY elemental damage for set weapons
  if (weaponItem && weaponItem.isWeapon && weaponItem.setId) {
    const handler = WEAPON_HANDLERS[weaponItem.setId];
    if (handler) {
      try { handler(player, enemy, weaponItem); }
      catch(e){ console.error('weapon handler error', e); }
    } else {
      // fallback: elemental damage only
      const p = player;
      const weaponBase = calculateWeaponDamage(p, (weaponItem.weaponMultiplier || 1.20));
      // Apply DMG% bonus
      const dmgMultiplier = 1 + (p.currentStats?.finalDMGPct || 0) / 100;
      const finalWeaponDmg = Math.floor(weaponBase * dmgMultiplier);
      const el = weaponItem.element || (weaponItem.setId && (EQUIPMENT_SETS[weaponItem.setId]?.element || 'physical')) || 'physical';
      applyCritDamage(enemy, finalWeaponDmg, { type: el, source:'weapon', setId: weaponItem.setId||null});
    }
  }


  // Apply weapon enchantments
  if (enemy.hp > 0) {
    const baseDamage = player.currentStats?.finalATK || player.ATK;
    applyWeaponEnchantments(enemy, baseDamage);
  }
  // handle death if hp <= 0 (applyDamageToEnemy handles AoE explosion for skywarden)
  if (enemy.hp <= 0) {
    // onEnemyDeath already invoked inside applyDamageToEnemy
    // fallback in case click killed before weapon applied:
    if (enemy.lastHit && enemy.lastHit.type === 'wind' && enemy.lastHit.setId === 'skywarden') {
      // handled earlier; nothing extra
    }
  }
}

function showFloatingDamage(damage, isCrit, element) {
  if (!element) return;

  const stage = document.getElementById('stage');
  if (!stage) return;

  const rect = element.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const dmgEl = document.createElement('div');
  dmgEl.className = 'drop-item';
  dmgEl.textContent = isCrit ? `${damage.toLocaleString()}! âš¡` : damage.toLocaleString();
  dmgEl.style.left = `${rect.left - stageRect.left + rect.width / 2}px`;
  dmgEl.style.top = `${rect.top - stageRect.top - 30}px`;
  dmgEl.style.color = isCrit ? '#ff0' : '#ffa500';
  dmgEl.style.fontWeight = 'bold';
  dmgEl.style.fontSize = '18px';

  const dropLayer = document.getElementById('drop-layer');
  if (dropLayer) {
    dropLayer.appendChild(dmgEl);
    setTimeout(() => dmgEl.remove(), 2000);
  }
}

function showDrop(position, icon) {
  const drop = document.createElement('div');
  drop.className = 'drop-item';
  drop.textContent = icon;
  drop.style.left = `${position.x}px`;
  drop.style.top = `${position.y}px`;
  document.getElementById('drop-layer').appendChild(drop);
  setTimeout(() => drop.remove(), 2000);
}

// ========== Tooltip System ==========
// ========== Tooltip helpers & System ==========
function buildItemTooltipHtml(item, isEquipped) {
  let html = `
    <div class="tooltip-header-row">
      <div class="tooltip-header-left">
        <div class="tooltip-header text-${item.rarity || 'common'}">${item.name}</div>
        ${item.type === 'equipment' ? `<div class="tooltip-level">Level: ${item.level} ${item.stars > 0 ? `(${item.stars}â­)` : ''}</div>` : ''}
      </div>
      ${item.type === 'equipment' ? `
        <div class="tooltip-base-stat">
          <div class="base-stat-name">${item.baseAttribute.name}</div>
          <div class="base-stat-value">${item.baseAttribute.value.toLocaleString()}</div>
        </div>
      ` : ''}
    </div>
    <div class="tooltip-content">
  `;

  if (item.type === 'equipment') {
    // Add set information if item is part of a set
    if (item.setId && EQUIPMENT_SETS[item.setId]) {
      const setData = EQUIPMENT_SETS[item.setId];
      const p = GameState.player;
      const setCount = (p.activeSets && p.activeSets[item.setId]) || 0;

      html += `<div style="padding: 10px; margin: 8px 0; background: rgba(212,175,55,0.15); border: 2px solid var(--accent-gold); border-radius: 6px;">`;
      html += `<div style="color: var(--accent-gold); font-weight: 700; margin-bottom: 6px; font-size: 13px;">${setData.icon} ${setData.name} Set (${setCount}/6)</div>`;

      // Show weapon ability if this is a weapon
      if (item.slot === 'weapon' && setData.weaponName && setData.weaponDesc) {
        html += `<div style="padding: 6px; margin: 6px 0; background: rgba(0,0,0,0.3); border-left: 3px solid var(--accent-gold); font-size: 10px;">`;
        html += `<div style="color: var(--accent-gold-bright); font-weight: 600; margin-bottom: 3px;">âš”ï¸ ${setData.weaponName}</div>`;
        html += `<div style="color: var(--text-secondary); line-height: 1.4;">${setData.weaponDesc}</div>`;
        html += `</div>`;
      }

      // Show set bonuses
      html += `<div style="margin-top: 8px; font-size: 10px;">`;
      [2, 3, 4, 6].forEach(tier => {
        const bonus = setData.bonuses[tier];
        if (bonus) {
          const active = setCount >= tier;
          const color = active ? 'var(--text-primary)' : 'var(--text-dim)';
          const weight = active ? '600' : '400';
          const checkmark = active ? 'âœ“' : 'â—‹';
          html += `<div style="color: ${color}; font-weight: ${weight}; padding: 2px 0; line-height: 1.3;">`;
          html += `<span style="color: ${active ? '#4fc3f7' : 'var(--text-dim)'};">${checkmark} ${tier}-piece:</span> ${bonus.desc}`;
          html += `</div>`;
        }
      });
      html += `</div></div>`;
    }

    // Item attributes
    item.affixes.forEach((affix, affixIndex) => {
      const suffix = (affix.name.includes('%') || affix.name.includes('Crit')) ? '%' : '';
      if (affix.locked) {
        html += `<div class="tooltip-attr locked">${affix.name}: ${affix.value.toLocaleString()}${suffix} (Upgrade to level ${affix.unlockLevel})</div>`;
      } else {
        // Unlocked affix with reroll buttons
        html += `
          <div class="tooltip-attr" style="display: flex; align-items: center; justify-content: space-between; gap: 4px;">
            <span>${affix.name}: ${affix.value.toLocaleString()}${suffix}</span>
            <div style="display: flex; gap: 3px; flex-shrink: 0;">
              <button 
                class="reroll-btn" 
                data-action="reroll-affix" data-affix-index="${affixIndex}"
                title="Reroll affix type (15 gems)"
                style="padding: 2px 6px; font-size: 9px; background: rgba(76,175,80,0.2); border: 1px solid #4caf50; color: #4caf50; border-radius: 3px; cursor: pointer; white-space: nowrap;"
              >ðŸ”„ 15ðŸ’Ž</button>
              <button 
                class="reroll-btn" 
                data-action="reroll-affix-value" data-affix-index="${affixIndex}"
                title="Reroll affix value (50 gems)"
                style="padding: 2px 6px; font-size: 9px; background: rgba(33,150,243,0.2); border: 1px solid #2196f3; color: #2196f3; border-radius: 3px; cursor: pointer; white-space: nowrap;"
              >ðŸŽ² 50ðŸ’Ž</button>
            </div>
          </div>
        `;
      }
    });

    const cost = getUpgradeCost(item);
    
    // Determine upgrade/enhance button text and function
    let upgradeButton = '';
    let quickActionButton = '';
    
    if (item.level >= 100) {
      if (item.rarity === 'divine') {
        // Divine at level 100 - show MAX LEVEL (disabled)
        upgradeButton = `<button class="tooltip-btn secondary" disabled style="opacity: 0.5; cursor: not-allowed;">MAX LEVEL</button>`;
      } else {
        // Non-divine at level 100 - show Enhance button
        const enhanceCost = { coins: cost.coins, gems: 15 };
        upgradeButton = `<button class="tooltip-btn legendary" data-action="enhance" style="background: linear-gradient(135deg, #dc2367 0%, #9c27b0 100%); border-color: #dc2367;">Enhance (ðŸ’°${enhanceCost.coins.toLocaleString()}${enhanceCost.gems > 0 ? ` ðŸ’Ž${enhanceCost.gems}` : ''})</button>`;
      }
    } else {
      // Normal upgrade - fix spacing
      const gemText = cost.gems > 0 ? ` ðŸ’Ž${cost.gems.toLocaleString()}` : '';
      upgradeButton = `<button class="tooltip-btn secondary" data-action="upgrade">Upgrade (ðŸ’°${cost.coins.toLocaleString()}${gemText})</button>`;
      
      // PRIORITY 1: Try full enhancement first (if not already divine)
      if (item.rarity !== 'divine') {
        // Calculate total cost to upgrade to level 100 and enhance to next rarity
        let totalCoins = 0;
        let totalGems = 0;
        const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
        
        for (let lvl = item.level; lvl < 100; lvl++) {
          const upgradeCost = Math.floor(baseCost * Math.pow(1.055, lvl - 1));
          totalCoins += upgradeCost;
          
          const nextLevel = lvl + 1;
          if (CONFIG.STAR_THRESHOLDS.includes(nextLevel)) {
            totalGems += CONFIG.STAR_GEM_COSTS[nextLevel.toString()] || 0;
          }
        }
        
        // Add enhancement cost
        const finalUpgradeCost = Math.floor(baseCost * Math.pow(1.055, 99));
        totalCoins += finalUpgradeCost;
        totalGems += 15; // Enhancement gem cost
        
        // Check if player has enough resources for full enhancement
        const p = GameState.player;
        if (p.coins >= totalCoins && p.gems >= totalGems) {
          quickActionButton = `<button class="tooltip-btn legendary" data-action="quick-enhance" style="background: linear-gradient(135deg, #f4cf57 0%, #d4af37 100%); border-color: #f4cf57; color: #1a1410; font-weight: 700;">âš¡ Quick Enhance (ðŸ’°${totalCoins.toLocaleString()} ðŸ’Ž${totalGems})</button>`;
        }
      }
      
      // PRIORITY 2: If can't afford full enhancement, try next star threshold
      if (!quickActionButton) {
        const nextStarThreshold = CONFIG.STAR_THRESHOLDS.find(threshold => threshold > item.level);
        
        if (nextStarThreshold) {
          // Calculate cost to upgrade to next star
          let totalCoins = 0;
          let totalGems = 0;
          const baseCost = CONFIG.EQUIP_BASE_UPGRADE_COST[item.rarity];
          
          for (let lvl = item.level; lvl < nextStarThreshold; lvl++) {
            const upgradeCost = Math.floor(baseCost * Math.pow(1.055, lvl - 1));
            totalCoins += upgradeCost;
            
            const nextLevel = lvl + 1;
            if (CONFIG.STAR_THRESHOLDS.includes(nextLevel)) {
              totalGems += CONFIG.STAR_GEM_COSTS[nextLevel.toString()] || 0;
            }
          }
          
          // Check if player has enough resources for quick upgrade to next star
          const p = GameState.player;
          if (p.coins >= totalCoins && p.gems >= totalGems) {
            const gemText = totalGems > 0 ? ` ðŸ’Ž${totalGems}` : '';
            quickActionButton = `<button class="tooltip-btn legendary" data-action="quick-upgrade" data-target-level="${nextStarThreshold}" style="background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%); border-color: #4fc3f7; color: #ffffff; font-weight: 700;">âš¡ Quick to Lvl ${nextStarThreshold} (ðŸ’°${totalCoins.toLocaleString()}${gemText})</button>`;
          }
        }
      }
    }
    

    // Add enchantments section if item has enchantments (minimalistic display)
    if (item.enchantments && item.enchantments.length > 0) {
      item.enchantments.forEach((ench, index) => {
        if (ench && ench.id) {
          const enchData = ENCHANTMENTS[ench.id];
          const isLocked = ench.locked;
          
          if (isLocked) {
            // Locked enchantment: dimmed with lock emoji
            html += `
              <div class="tooltip-attr locked enchantment-attr" style="display: flex; align-items: center; justify-content: space-between; opacity: 0.5;">
                <span style="color: ${ENCHANTMENT_COLOR};">ðŸ”’ ${enchData.name}</span>
                <button 
                  class="enchant-btn" 
                  data-action="unlock-enchantment" 
                  data-ench-index="${index}"
                  style="padding: 2px 6px; font-size: 9px; background: rgba(168,85,247,0.2); border: 1px solid ${ENCHANTMENT_COLOR}; color: ${ENCHANTMENT_COLOR}; border-radius: 3px; cursor: pointer; white-space: nowrap;"
                >ðŸ’Ž${ench.unlockCost}</button>
              </div>
            `;
          } else {
            // Unlocked enchantment: full opacity with sparkle
            html += `
              <div class="tooltip-attr enchantment-attr" style="display: flex; align-items: center; justify-content: space-between;">
                <span style="color: ${ENCHANTMENT_COLOR}; font-weight: 600;">âœ¨ ${enchData.name}</span>
                <button 
                  class="enchant-btn" 
                  data-action="reroll-enchantment" 
                  data-ench-index="${index}"
                  style="padding: 2px 6px; font-size: 9px; background: rgba(168,85,247,0.2); border: 1px solid ${ENCHANTMENT_COLOR}; color: ${ENCHANTMENT_COLOR}; border-radius: 3px; cursor: pointer; white-space: nowrap;"
                >ðŸ”„ ðŸ’Ž100</button>
              </div>
            `;
          }
        }
      });
    }
    
    
    
    html += `
      </div>
      <div class="tooltip-actions">
        ${!isEquipped ? `<button class="tooltip-btn primary" data-action="equip">Equip</button>` : ''}
        ${isEquipped ? `<button class="tooltip-btn secondary" data-action="unequip" data-slot="${item.slot}">Unequip</button>` : ''}
        ${upgradeButton}
        ${quickActionButton}
        <button class="tooltip-btn danger" data-action="sell">Sell (ðŸ’°${item.sellPrice.toLocaleString()})</button>
      </div>
    `;
  } else if (item.type === 'consumable') {
    html += `
      <div>${item.name}</div>
      <div class="tooltip-actions">
        <button class="tooltip-btn primary" data-action="use-consumable">Use</button>
      </div>
      </div>
    `;
  }

  return html;
}

function buildShopItemTooltipHtml(item) {
  let html = `
    <div class="tooltip-header-row">
      <div class="tooltip-header-left">
        <div class="tooltip-header text-${item.rarity || 'common'}">${item.name}</div>
        ${item.type === 'equipment' ? `<div class="tooltip-level">Level: ${item.level} ${item.stars > 0 ? `(${item.stars}â­)` : ''}</div>` : ''}
      </div>
      ${item.type === 'equipment' ? `
        <div class="tooltip-base-stat">
          <div class="base-stat-name">${item.baseAttribute.name}</div>
          <div class="base-stat-value">${item.baseAttribute.value.toLocaleString()}</div>
        </div>
      ` : ''}
    </div>
    <div class="tooltip-content">
  `;

  if (item.type === 'equipment') {
    // Add set information if item is part of a set
    if (item.setId && EQUIPMENT_SETS[item.setId]) {
      const setData = EQUIPMENT_SETS[item.setId];
      const p = GameState.player;
      const setCount = (p.activeSets && p.activeSets[item.setId]) || 0;

      html += `<div style="padding: 10px; margin: 8px 0; background: rgba(212,175,55,0.15); border: 2px solid var(--accent-gold); border-radius: 6px;">`;
      html += `<div style="color: var(--accent-gold); font-weight: 700; margin-bottom: 6px; font-size: 13px;">${setData.icon} ${setData.name} Set (${setCount}/6)</div>`;

      // Show weapon ability if this is a weapon
      if (item.slot === 'weapon' && setData.weaponName && setData.weaponDesc) {
        html += `<div style="padding: 6px; margin: 6px 0; background: rgba(0,0,0,0.3); border-left: 3px solid var(--accent-gold); font-size: 10px;">`;
        html += `<div style="color: var(--accent-gold-bright); font-weight: 600; margin-bottom: 3px;">âš”ï¸ ${setData.weaponName}</div>`;
        html += `<div style="color: var(--text-secondary); line-height: 1.4;">${setData.weaponDesc}</div>`;
        html += `</div>`;
      }

      // Show set bonuses
      html += `<div style="margin-top: 8px; font-size: 10px;">`;
      [2, 3, 4, 6].forEach(tier => {
        const bonus = setData.bonuses[tier];
        if (bonus) {
          const active = setCount >= tier;
          const color = active ? 'var(--text-primary)' : 'var(--text-dim)';
          const weight = active ? '600' : '400';
          const checkmark = active ? 'âœ“' : 'â—‹';
          html += `<div style="color: ${color}; font-weight: ${weight}; padding: 2px 0; line-height: 1.3;">`;
          html += `<span style="color: ${active ? '#4fc3f7' : 'var(--text-dim)'};">${checkmark} ${tier}-piece:</span> ${bonus.desc}`;
          html += `</div>`;
        }
      });
      html += `</div></div>`;
    }

    item.affixes.forEach(affix => {
      const suffix = (affix.name.includes('%') || affix.name.includes('Crit')) ? '%' : '';
      if (affix.locked) {
        html += `<div class="tooltip-attr locked">${affix.name}: ${affix.value.toLocaleString()}${suffix} (Upgrade to level ${affix.unlockLevel})</div>`;
      } else {
        html += `<div class="tooltip-attr">${affix.name}: ${affix.value.toLocaleString()}${suffix}</div>`;
      }
    });

    // Add enchantments in shop (dimmed locked display)
    if (item.enchantments && item.enchantments.length > 0) {
      item.enchantments.forEach((ench, index) => {
        if (ench && ench.id) {
          const enchData = ENCHANTMENTS[ench.id];
          // In shop, all enchantments are shown as locked
          html += `
            <div class="tooltip-attr locked enchantment-attr" style="opacity: 0.5;">
              <span style="color: ${ENCHANTMENT_COLOR};">ðŸ”’ ${enchData.name}</span>
            </div>
          `;
        }
      });
    }

    html += `
      </div>
      <div class="tooltip-actions">
        <button class="tooltip-btn primary buy-shop-btn" data-item-id="${item.id}">Buy (ðŸ’°${item.buyPrice.toLocaleString()})</button>
      </div>
    `;
  } else if (item.type === 'consumable') {
    html += `
      <div style="padding: 8px;">${item.desc || item.name}</div>

      <div class="tooltip-actions">
        <button class="tooltip-btn primary buy-shop-btn" data-item-id="${item.id}">Buy (ðŸ’Ž${item.price.toLocaleString()})</button>
      </div>
    `;
  }

  return html;
}

function showShopItemTooltip(item, targetEl) {
  const tooltip = document.getElementById('inventory-tooltip');

  // Set content first
  tooltip.innerHTML = buildShopItemTooltipHtml(item);

  // Set border color based on item rarity
  const rarityColors = {
    common: 'var(--color-common)',
    uncommon: 'var(--color-uncommon)',
    rare: 'var(--color-rare)',
    epic: 'var(--color-epic)',
    legendary: 'var(--color-legendary)',
    mythic: 'var(--color-mythic)',
    divine: 'var(--color-divine)'
  };
  tooltip.style.borderColor = rarityColors[item.rarity] || 'var(--border-color)';

  // Store the current item ID for event delegation
  tooltip.dataset.currentItemId = item.id;
  tooltip.dataset.isEquipped = 'false';

  // Temporarily position offscreen to measure without showing
  const originalLeft = tooltip.style.left;
  const originalTop = tooltip.style.top;
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
  tooltip.setAttribute('aria-hidden', 'false');

  // Force a reflow to get dimensions
  tooltip.offsetHeight;

  const tooltipRect = tooltip.getBoundingClientRect();
  const rect = targetEl.getBoundingClientRect();

  // Calculate position
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

  let left = rect.right + 8;
  let top = rect.top;

  // Better mobile handling - center tooltip if it doesn't fit
  if (vw < 768) {
    // On mobile, center the tooltip horizontally if it would go offscreen
    if (tooltipRect.width > vw - 16) {
      left = 8;
    } else {
      left = Math.max(8, Math.min(vw - tooltipRect.width - 8, rect.left));
    }
    // Position below the target element on mobile
    top = rect.bottom + 8;
  } else {
    // Desktop behavior
    if (left + tooltipRect.width > vw - 8) {
      left = rect.left - tooltipRect.width - 8;
    }
    // If still offscreen on left, center it
    if (left < 8) {
      left = Math.max(8, (vw - tooltipRect.width) / 2);
    }
  }
  
  // Vertical positioning - ensure it stays on screen
  if (top + tooltipRect.height > vh - 8) {
    top = vh - tooltipRect.height - 8;
  }
  if (top < 8) top = 8;

  // Apply final position
  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

function hideTooltip() {
  const tooltip = document.getElementById('inventory-tooltip');
  tooltip.setAttribute('aria-hidden', 'true');

  // Clear any active effect tooltip timer
  if (GameState.effectTooltipTimer) {
    clearInterval(GameState.effectTooltipTimer);
    GameState.effectTooltipTimer = null;
  }
}

function showEffectTooltip(effect, targetEl) {
  const tooltip = document.getElementById('inventory-tooltip');

  // Clear any existing effect tooltip timer
  if (GameState.effectTooltipTimer) {
    clearInterval(GameState.effectTooltipTimer);
    GameState.effectTooltipTimer = null;
  }

  // Map effect IDs to readable info
  const effectData = {
    'exp_boost_200': { name: 'EXP Boost x3', description: 'Experience gain multiplied by 3', icon: 'ðŸ“š' },
    'dmg_boost_200': { name: 'Damage Boost x3', description: 'Damage output multiplied by 3', icon: 'âš¡' },
    'coins_boost_200': { name: 'Coins Boost x3', description: 'Coin drops multiplied by 3', icon: 'ðŸ’°' }
  };

  const data = effectData[effect.id] || { name: effect.id, description: 'Active effect', icon: 'âœ¨' };

  // Function to update the timer display
  const updateTimer = () => {
    const now = Date.now();
    const elapsed = (now - effect.startedAtTs) / 1000;
    const remaining = Math.max(0, effect.durationSec - elapsed);
    const minutes = Math.floor(remaining / 60);
    const seconds = Math.floor(remaining % 60);

    const timerEl = tooltip.querySelector('.effect-tooltip-timer');
    if (timerEl) {
      timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Close tooltip if effect expired
    if (remaining <= 0) {
      hideTooltip();
    }
  };

  // Initial render
  const now = Date.now();
  const elapsed = (now - effect.startedAtTs) / 1000;
  const remaining = Math.max(0, effect.durationSec - elapsed);
  const minutes = Math.floor(remaining / 60);
  const seconds = Math.floor(remaining % 60);

  tooltip.innerHTML = `
    <div class="tooltip-header-row">
      <div class="tooltip-header-left">
        <div class="tooltip-header text-legendary">${data.name}</div>
      </div>
      <div class="tooltip-base-stat">
        <div class="base-stat-name">TIME</div>
        <div class="base-stat-value effect-tooltip-timer" style="font-size: 20px;">${minutes}:${seconds.toString().padStart(2, '0')}</div>
      </div>
    </div>
    <div class="tooltip-content">
      <div style="text-align: center; font-size: 48px; margin: 8px 0;">${data.icon}</div>
      <div style="margin-top: 8px;">${data.description}</div>
    </div>
  `;
  // Clear item ID since this is an effect tooltip, not an item tooltip
  delete tooltip.dataset.currentItemId;
  delete tooltip.dataset.isEquipped;


  // Start updating the timer every second
  GameState.effectTooltipTimer = setInterval(updateTimer, 1000);

  // Temporarily position offscreen to measure
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
  tooltip.setAttribute('aria-hidden', 'false');

  // Force reflow
  tooltip.offsetHeight;

  const tooltipRect = tooltip.getBoundingClientRect();
  const rect = targetEl.getBoundingClientRect();

  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

  let left = rect.right + 8;
  let top = rect.top;

  // Better mobile handling
  if (vw < 768) {
    if (tooltipRect.width > vw - 16) {
      left = 8;
    } else {
      left = Math.max(8, Math.min(vw - tooltipRect.width - 8, rect.left));
    }
    top = rect.bottom + 8;
  } else {
    if (left + tooltipRect.width > vw - 8) {
      left = rect.left - tooltipRect.width - 8;
    }
    if (left < 8) {
      left = Math.max(8, (vw - tooltipRect.width) / 2);
    }
  }
  
  if (top + tooltipRect.height > vh - 8) {
    top = vh - tooltipRect.height - 8;
  }
  if (top < 8) top = 8;

  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

function showItemTooltip(item, targetEl, isEquipped) {
  const tooltip = document.getElementById('inventory-tooltip');
  const rect = targetEl.getBoundingClientRect();

  // build content using helper
  tooltip.innerHTML = buildItemTooltipHtml(item, isEquipped);

  // Set border color based on item rarity
  const rarityColors = {
    common: 'var(--color-common)',
    uncommon: 'var(--color-uncommon)',
    rare: 'var(--color-rare)',
    epic: 'var(--color-epic)',
    legendary: 'var(--color-legendary)',
    mythic: 'var(--color-mythic)',
    divine: 'var(--color-divine)'
  };
  tooltip.style.borderColor = rarityColors[item.rarity] || 'var(--border-color)';

  // mark which item is shown (so we can update it later without needing the target element)
  tooltip.dataset.currentItemId = item.id;
  tooltip.dataset.isEquipped = !!isEquipped;

  // Temporarily show offscreen to measure
  tooltip.style.left = '-9999px';
  tooltip.style.top = '-9999px';
  tooltip.setAttribute('aria-hidden', 'false');
  
  // Force reflow
  tooltip.offsetHeight;

  // position tooltip near target
  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  const tooltipRect = tooltip.getBoundingClientRect();
  
  let left = rect.right + 8;
  let top = rect.top;

  // Better mobile handling
  if (vw < 768) {
    // On mobile, center the tooltip horizontally if it would go offscreen
    if (tooltipRect.width > vw - 16) {
      left = 8;
    } else {
      left = Math.max(8, Math.min(vw - tooltipRect.width - 8, rect.left));
    }
    // Position below the target element on mobile
    top = rect.bottom + 8;
  } else {
    // Desktop behavior
    if (left + tooltipRect.width > vw - 8) {
      left = rect.left - tooltipRect.width - 8;
    }
    // If still offscreen on left, center it
    if (left < 8) {
      left = Math.max(8, (vw - tooltipRect.width) / 2);
    }
  }
  
  // Vertical positioning
  if (top + tooltipRect.height > vh - 8) {
    top = Math.max(8, vh - tooltipRect.height - 8);
  }

  tooltip.style.left = `${left}px`;
  tooltip.style.top = `${top}px`;
}

// ========== World Progress & Boss ==========
function updateWorldProgress() {
  const wp = GameState.worldProgress;
  const p = GameState.player;

  wp.requiredEnemies = 25 * p.world;
  wp.requiredElites = Math.max(1, Math.floor(p.world / 2));
  wp.requiredLevel = Math.min(2 + p.world * 1, 100);

  const enemiesMet = wp.enemiesKilledThisWorld >= wp.requiredEnemies;
  const elitesMet = wp.elitesKilledThisWorld >= wp.requiredElites;
  const levelMet = p.level >= wp.requiredLevel;

  document.getElementById('req-enemies-text').textContent = `${wp.enemiesKilledThisWorld} / ${wp.requiredEnemies}`;
  document.getElementById('req-elites-text').textContent = `${wp.elitesKilledThisWorld} / ${wp.requiredElites}`;
  document.getElementById('req-level-text').textContent = `${p.level} / ${wp.requiredLevel}`;

  document.getElementById('req-enemies').className = enemiesMet ? 'requirement met' : 'requirement not-met';
  document.getElementById('req-elites').className = elitesMet ? 'requirement met' : 'requirement not-met';
  document.getElementById('req-level').className = levelMet ? 'requirement met' : 'requirement not-met';

    const allMet = enemiesMet && elitesMet && levelMet;
    document.getElementById('btn-challenge-world').disabled = !allMet;

    // Update world requirements title
    document.getElementById('world-requirements-title').textContent = `Challenge World ${p.world}`;

    // Show the requirements panel by default, but hide it while a challenge is active
    const panel = document.getElementById('world-requirements');
    if (GameState.suspendWaves) {
      // we are in a challenge (or waves suspended) â€” hide the panel
      panel.className = 'panel';
    } else {
      // not fighting â€” keep it visible even if requirements aren't met
      panel.className = 'panel visible';
    }

}

// ========== Wave-Based Challenge System ==========
const WAVE_CHALLENGE_TYPES = {
  DEFEAT_ENEMIES: { 
    name: 'Defeat Enemies',
    enemyTypes: ['normal'],
    hasTimer: false
  },
  DEFEAT_ENEMIES_TIMED: { 
    name: 'Speed Kill',
    enemyTypes: ['normal'],
    hasTimer: true
  },
  DEFEAT_ELITES: { 
    name: 'Elite Hunter',
    enemyTypes: ['elite'],
    hasTimer: false
  },
  DEFEAT_BOSS: { 
    name: 'Boss Battle',
    enemyTypes: ['boss'],
    hasTimer: false,
    bossCount: 1 // Can increase with world
  },
  DEFEAT_MIXED_ENEMIES_ELITES_BOSS: { 
    name: 'Mixed Battle',
    enemyTypes: ['normal', 'elite', 'boss'],
    hasTimer: false
  },
  DEFEAT_MIXED_ENEMIES_BOSS: { 
    name: 'Boss Rush',
    enemyTypes: ['normal', 'boss'],
    hasTimer: false
  },
  DEFEAT_MIXED_ENEMIES_ELITES_BOSS_TIMED: { 
    name: 'Ultimate Challenge',
    enemyTypes: ['normal', 'elite', 'boss'],
    hasTimer: true
  },
  DEFEAT_MIXED_ENEMIES_BOSS_TIMED: { 
    name: 'Timed Boss Rush',
    enemyTypes: ['normal', 'boss'],
    hasTimer: true
  }
};

function getWaveCount(world) {
  if (world === 1) return 1;
  if (world === 2 || world === 3) return 2;
  return 3;
}

function getEnemyCount(world, waveIndex) {
  // Base count starts at 15, increases by 5, 10, or 15 per world
  const increaseOptions = [5, 10, 15];
  const increase = increaseOptions[Math.floor(Math.random() * increaseOptions.length)];
  const baseCount = 15 + (world - 1) * increase;
  
  // Each wave in the same challenge gets progressively more enemies
  const waveMultiplier = 1 + (waveIndex * 0.3); // 0%, 30%, 60% more
  
  return Math.min(300, Math.floor(baseCount * waveMultiplier));
}

function getTimeLimit() {
  const options = [30, 45, 60];
  return options[Math.floor(Math.random() * options.length)];
}

function generateWaveChallenge(world, waveIndex, totalWaves) {
  const challengeTypes = Object.keys(WAVE_CHALLENGE_TYPES);
  
  // For final wave, increase chance of boss challenges
  let selectedType;
  if (waveIndex === totalWaves - 1) {
    // 60% chance of boss-related challenge on final wave
    const bossTypes = ['DEFEAT_BOSS', 'DEFEAT_MIXED_ENEMIES_BOSS', 'DEFEAT_MIXED_ENEMIES_ELITES_BOSS'];
    if (Math.random() < 0.6) {
      selectedType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
    } else {
      selectedType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];
    }
  } else {
    selectedType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];
  }
  
  const challengeData = WAVE_CHALLENGE_TYPES[selectedType];
  const enemyCount = getEnemyCount(world, waveIndex);
  const timeLimit = challengeData.hasTimer ? getTimeLimit() : 0;
  
  // Calculate enemy composition
  let composition = {};
  if (challengeData.enemyTypes.includes('boss')) {
    const bossCount = Math.max(1, Math.floor(world / 3)); // 1 boss per 3 worlds
    composition.boss = bossCount;
  }
  if (challengeData.enemyTypes.includes('elite')) {
    const eliteRatio = challengeData.enemyTypes.length === 1 ? 1.0 : 0.3; // 30% elites if mixed
    composition.elite = Math.max(1, Math.floor(enemyCount * eliteRatio));
  }
  if (challengeData.enemyTypes.includes('normal')) {
    const usedCount = (composition.elite || 0) + (composition.boss || 0);
    composition.normal = Math.max(5, enemyCount - usedCount);
  }
  
  // Calculate actual total enemies that will spawn
  const actualTotal = (composition.normal || 0) + (composition.elite || 0) + (composition.boss || 0);
  
  return {
    type: selectedType,
    name: challengeData.name,
    composition: composition,
    totalRequired: actualTotal,  // Use actual count, not enemyCount
    timeLimit: timeLimit,
    hasTimer: challengeData.hasTimer
  };
}

function generateWorldChallenge(world) {
  const waveCount = getWaveCount(world);
  const waves = [];
  
  for (let i = 0; i < waveCount; i++) {
    waves.push(generateWaveChallenge(world, i, waveCount));
  }
  
  return {
    world: world,
    waves: waves,
    currentWave: 0
  };
}

function selectOrCreateChallenge() {
  const world = GameState.player.world;
  
  // Check if this world already has an assigned challenge
  if (!GameState.worldProgress.assignedChallenges) {
    GameState.worldProgress.assignedChallenges = {};
  }
  
  const existingChallenge = GameState.worldProgress.assignedChallenges[world];
  
  // Validate existing challenge has the correct structure
  if (existingChallenge && existingChallenge.waves && Array.isArray(existingChallenge.waves)) {
    // Return the previously assigned challenge for this world
    return existingChallenge;
  }
  
  // No valid challenge assigned, generate a new one and save it
  const challenge = generateWorldChallenge(world);
  GameState.worldProgress.assignedChallenges[world] = challenge;
  
  return challenge;
}

function startChallenge() {
  const challenge = selectOrCreateChallenge();
  GameState.currentChallenge = challenge;
  GameState.currentChallenge.currentWave = 0;
  GameState.challengeFailed = false;
  
  // Initialize progress tracking
  GameState.challengeProgress = {
    enemiesKilled: 0,
    elitesKilled: 0,
    bossesKilled: 0,
    totalKilled: 0,
    died: false,
    startTime: Date.now(),
    waitingForNextWave: false,
    spawnedCount: 0,
    spawnIntervals: [],
    completionTime: null,
  };
}

function updateChallengeTimer() {
  if (!GameState.currentChallenge) return;
  
  const challenge = GameState.currentChallenge;
  
  // Validate challenge has waves array
  if (!challenge.waves || !Array.isArray(challenge.waves)) {
    console.error('Invalid challenge structure - missing waves array');
    return;
  }
  
  const currentWave = challenge.waves[challenge.currentWave];
  
  if (!currentWave || !currentWave.hasTimer) return;
  
  const timerEl = document.getElementById('timer-text');
  if (!timerEl) return;
  
  // If requirements are met, freeze timer and don't check for failure
  if (isCurrentWaveComplete()) {
    // Requirements met - stop the timer at current value
    return;
  }
  
  const elapsed = (Date.now() - GameState.challengeProgress.startTime) / 1000;
  const remaining = Math.max(0, currentWave.timeLimit - elapsed);
  const minutes = Math.floor(remaining / 60);
  const seconds = Math.floor(remaining % 60);
  
  timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  
  // Check if time ran out
  if (remaining <= 0 && !isCurrentWaveComplete()) {
    failChallenge('Time ran out!');
  }
}

function trackChallengeProgress(enemy) {
  if (!GameState.currentChallenge) return;
  
  GameState.challengeProgress.totalKilled++;
  
  if (enemy.type === 'elite') {
    GameState.challengeProgress.elitesKilled++;
  } else if (enemy.type === 'boss' || enemy.type === 'archboss') {
    GameState.challengeProgress.bossesKilled++;
  } else {
    GameState.challengeProgress.enemiesKilled++;
  }
  
  // Update the challenge UI
  updateChallengeDescription();
}

function isCurrentWaveComplete() {
  if (!GameState.currentChallenge) return false;
  
  const challenge = GameState.currentChallenge;
  const currentWave = challenge.waves[challenge.currentWave];
  
  // Validate challenge has waves array
  if (!challenge.waves || !Array.isArray(challenge.waves)) return false;

  const progress = GameState.challengeProgress;
  
  if (!currentWave) return false;
  if (progress.died) return false;
  
  // Check if required count is met OR EXCEEDED (37/35 should count as complete)
  const required = currentWave.totalRequired;
  const killed = progress.totalKilled;
  
  if (killed < required) return false;
  
  // Check timer if applicable - record completion time when requirements are met
  if (currentWave.hasTimer) {
    // If we haven't recorded the completion time yet, record it now
    if (!progress.completionTime) {
      const elapsed = (Date.now() - progress.startTime) / 1000;
      // Only record if we're still within the time limit
      if (elapsed <= currentWave.timeLimit) {
        progress.completionTime = Date.now();
        console.log(`[TIMER] Requirements met at ${elapsed.toFixed(2)}s (limit: ${currentWave.timeLimit}s)`);
      } else {
        // Requirements met but time already expired
        return false;
      }
    }
    // If completion time was recorded, we succeeded (even if checking after time limit)
  }
  
  return true;
}

function trackWaveCompletion() {
  if (!GameState.currentChallenge) return;
  if (GameState.isDead) return; // Player died
  
  const progress = GameState.challengeProgress;
  
  // If we're already waiting for next wave to spawn, don't do anything
  if (progress.waitingForNextWave) return;
  
  const challenge = GameState.currentChallenge;
  const currentWaveIndex = challenge.currentWave;
  
  // Validate challenge has waves array
  if (!challenge.waves || !Array.isArray(challenge.waves)) return;

  const totalWaves = challenge.waves.length;
  
  // Check if current wave is complete (requirements met, even if enemies remain)
  if (!isCurrentWaveComplete()) return;
  
  // Mark that we're processing this wave completion
  progress.waitingForNextWave = true;
  
  console.log(`[WAVE] Wave ${currentWaveIndex + 1}/${totalWaves} completed.`);
  
  // IMMEDIATELY stop all spawn intervals to prevent more enemies from spawning
  if (progress.spawnIntervals && progress.spawnIntervals.length > 0) {
    console.log(`[WAVE] Stopping ${progress.spawnIntervals.length} spawn intervals`);
    progress.spawnIntervals.forEach(intervalId => clearInterval(intervalId));
    progress.spawnIntervals = [];
  }
  
  // Kill any spare enemies with shockwave effect
  if (GameState.enemies.length > 0) {
    const spareEnemies = [...GameState.enemies];
    console.log(`[WAVE] Killing ${spareEnemies.length} spare enemies with shockwave`);
    
    spareEnemies.forEach(enemy => {
      // Create shockwave effect at enemy position
      createShockwaveEffect(enemy.position.x, enemy.position.y);
      
      // Remove enemy from the game
      const enemyEl = document.querySelector(`[data-enemy-id="${enemy.id}"]`) || 
                      document.querySelector(`[data-boss-id="${enemy.id}"]`) ||
                      document.querySelector(`[data-entity-id="${enemy.id}"]`);
      if (enemyEl && enemyEl.parentNode) {
        enemyEl.parentNode.removeChild(enemyEl);
      }
    });
    
    // Clear all enemies at once
    GameState.enemies = [];
  }
  
  if (currentWaveIndex + 1 < totalWaves) {
    // More waves to go
    showNotification(`âœ… Wave ${currentWaveIndex + 1}/${totalWaves} Complete!`, 'success');
    
    // Spawn next wave after delay
    setTimeout(() => {
      challenge.currentWave++;
      console.log(`[WAVE] Starting wave ${challenge.currentWave + 1}`);
      
      // Reset progress for new wave
      GameState.challengeProgress = {
        enemiesKilled: 0,
        elitesKilled: 0,
        bossesKilled: 0,
        totalKilled: 0,
        died: false,
        startTime: Date.now(),
        waitingForNextWave: false,
        spawnedCount: 0,
        spawnIntervals: [],
        completionTime: null,
      };
      
      spawnChallengeWave();
      updateChallengeDescription();
    }, 2000);
  } else {
    // All waves completed!
    // showNotification(`âœ… All ${totalWaves} waves completed!`, 'legendary');
    progress.waitingForNextWave = false;
    // Challenge completion will be checked in gameTick
  }
}

function createShockwaveEffect(x, y) {
  const stage = document.getElementById('stage');
  if (!stage) return;
  
  const shockwave = document.createElement('div');
  shockwave.style.position = 'absolute';
  shockwave.style.left = '0';
  shockwave.style.top = '0';
  shockwave.style.width = '100px';
  shockwave.style.height = '100px';
  shockwave.style.borderRadius = '50%';
  shockwave.style.border = '3px solid rgba(255, 215, 0, 0.8)';
  shockwave.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.6), inset 0 0 20px rgba(255, 215, 0, 0.4)';
  shockwave.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%) scale(0.1)`;
  shockwave.style.pointerEvents = 'none';
  shockwave.style.zIndex = '100';
  shockwave.style.opacity = '1';
  shockwave.style.transition = 'transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.6s ease-out';
  
  stage.appendChild(shockwave);
  
  // Trigger animation
  setTimeout(() => {
    shockwave.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%) scale(3)`;
    shockwave.style.opacity = '0';
  }, 10);
  
  // Remove element after animation
  setTimeout(() => {
    if (shockwave.parentNode) {
      shockwave.parentNode.removeChild(shockwave);
    }
  }, 650);
}

function trackDeath() {
  if (GameState.currentChallenge) {
    GameState.challengeProgress.died = true;
    failChallenge('You died!');
  }
}

function verifyChallengeComplete() {
  if (!GameState.currentChallenge) return false;
  
  const challenge = GameState.currentChallenge;
  const progress = GameState.challengeProgress;
  
  // Validate challenge has waves array
  if (!challenge.waves || !Array.isArray(challenge.waves)) return false;

  
  // Check if died
  if (progress.died) return false;
  
  // Check if all waves are completed
  const lastWaveIndex = challenge.waves.length - 1;
  if (challenge.currentWave !== lastWaveIndex) return false;
  
  // Check if the last wave is complete
  return isCurrentWaveComplete();
}

function completeChallenge() {
  if (!GameState.currentChallenge) return;
  
  // Clear any active spawn intervals
  if (GameState.challengeProgress && GameState.challengeProgress.spawnIntervals) {
    GameState.challengeProgress.spawnIntervals.forEach(intervalId => clearInterval(intervalId));
    GameState.challengeProgress.spawnIntervals = [];
  }
  
  showNotification(`âœ… World ${GameState.player.world} Challenge Complete!`, 'legendary');
  
  // Hide challenge overlay
  hideChallengeOverlay();
  
  // Reset challenge
  GameState.currentChallenge = null;
}

function failChallenge(reason) {
  if (!GameState.currentChallenge) return;
  
  // Prevent multiple failure calls
  if (GameState.challengeFailed) return;
  GameState.challengeFailed = true;

  console.log(`[CHALLENGE] Challenge failed: ${reason}`);
  
  // Clear any active spawn intervals
  if (GameState.challengeProgress && GameState.challengeProgress.spawnIntervals) {
    GameState.challengeProgress.spawnIntervals.forEach(intervalId => clearInterval(intervalId));
    GameState.challengeProgress.spawnIntervals = [];
  }
  
  // Hide challenge overlay
  hideChallengeOverlay();
  
  // Show challenge failure screen
  const challengeFailureScreen = document.getElementById('challenge-failure-screen');
  if (challengeFailureScreen) {
    challengeFailureScreen.classList.add('active');
  }
  
  // Update world display
  const worldSpan = document.getElementById('challenge-failure-world');
  if (worldSpan) {
    worldSpan.textContent = GameState.player.world;
  }
  
  // Remove all enemies
  GameState.enemies = [];
  
  // Set a timer to return from challenge after 3 seconds
  setTimeout(() => {
    returnFromChallengeFailed();
  }, 3000);
  
  showNotification(`âŒ Challenge Failed: ${reason}`, 'danger');
}

function returnFromChallengeFailed() {
  console.log('[CHALLENGE] Returning from failed challenge');
  
  // Hide challenge failure screen
  const challengeFailureScreen = document.getElementById('challenge-failure-screen');
  if (challengeFailureScreen) {
    challengeFailureScreen.classList.remove('active');
  }
  
  // Reset challenge
  GameState.currentChallenge = null;
  GameState.challengeFailed = false;
  
  // Reset game state flags
  GameState.suspendWaves = false;
  GameState.inBossChallenge = false;
  
  // Resume normal waves
  updateWorldProgress();
  
  showNotification(`ðŸ”„ Returned to World ${GameState.player.world}`, 'info');
}

function updateChallengeDescription() {
  if (!GameState.currentChallenge) return;
  
  const challenge = GameState.currentChallenge;
  const currentWave = challenge.waves[challenge.currentWave];
  
  // Validate challenge has waves array
  if (!challenge.waves || !Array.isArray(challenge.waves)) {
    console.error('Invalid challenge structure - missing waves array');
    return;
  }

  const progress = GameState.challengeProgress;
  
  if (!currentWave) return;
  
  const descEl = document.getElementById('challenge-description');
  const timerEl = document.getElementById('challenge-timer');
  
  if (!descEl) return;
  
  // Build description with progress using HTML structure
  let desc = `<div class="wave-title">Wave ${challenge.currentWave + 1}/${challenge.waves.length}: ${currentWave.name}</div>`;
  
  if (currentWave.hasTimer) {
    desc += `Defeat ${currentWave.totalRequired} enemies in ${currentWave.timeLimit} seconds (${progress.totalKilled}/${currentWave.totalRequired})`;
  } else {
    desc += `Defeat ${currentWave.totalRequired} enemies (${progress.totalKilled}/${currentWave.totalRequired})`;
  }
  
  descEl.innerHTML = desc;
  
  // Show/hide timer
  if (timerEl) {
    if (currentWave.hasTimer) {
      timerEl.style.display = 'inline-block';
    } else {
      timerEl.style.display = 'none';
    }
  }
}

function challengeWorld() {
  if (GameState.suspendWaves) return;

  // Start the wave-based challenge
  startChallenge();

  GameState.suspendWaves = true;
  GameState.inBossChallenge = true;
  GameState.enemies = [];

  // Show challenge overlay
  showChallengeOverlay();
  
  // Spawn first wave
  spawnChallengeWave();

  document.getElementById('world-requirements').className = 'panel';
}

function spawnChallengeWave() {
  if (!GameState.currentChallenge) return;
  
  const challenge = GameState.currentChallenge;
  const currentWave = challenge.waves[challenge.currentWave];
  
  // Validate challenge has waves array
  if (!challenge.waves || !Array.isArray(challenge.waves)) return;

  
  if (!currentWave) return;
  
  console.log(`[WAVE] Spawning wave ${challenge.currentWave + 1}: ${currentWave.name}`);
  console.log(`[WAVE] Composition:`, currentWave.composition);
  
  // Clear existing enemies and intervals
  GameState.enemies = [];
  
  // Clear any existing spawn intervals
  if (GameState.challengeProgress.spawnIntervals) {
    GameState.challengeProgress.spawnIntervals.forEach(intervalId => clearInterval(intervalId));
    GameState.challengeProgress.spawnIntervals = [];
  }
  
  // Calculate total enemies to spawn
  // Add 5-10 extra enemies as buffer (in case player kills more than required)
  const extraEnemies = 5 + Math.floor(Math.random() * 6); // Random 5-10 enemies
  const totalEnemies = (currentWave.composition.normal || 0) + 
                       (currentWave.composition.elite || 0) + 
                       (currentWave.composition.boss || 0) +
                       extraEnemies;
  
  console.log(`[WAVE] Total enemies to spawn: ${totalEnemies} (required: ${currentWave.totalRequired}, buffer: ${extraEnemies})`);
  
  // Build enemy queue with varied types based on world level
  const enemyQueue = [];
  const world = GameState.player.world;
  
  // Helper function to get a random enemy type from a category based on world
  function getRandomEnemyFromCategory(category) {
    const available = getAvailableEnemyTypes(category, world);
    if (available.length === 0) {
      // Fallback to base types
      return category === 'BOSS' ? 'boss' : 
             category === 'ELITE' ? 'elite' : 'normal';
    }
    return available[Math.floor(Math.random() * available.length)];
  }
  
  // Spawn normal enemies - mix of SMALL, NORMAL, and BIG categories
  if (currentWave.composition.normal) {
    for (let i = 0; i < currentWave.composition.normal; i++) {
      // Weighted distribution: 30% small, 50% normal, 20% big
      const roll = Math.random();
      let category;
      if (roll < 0.3) category = 'SMALL';
      else if (roll < 0.8) category = 'NORMAL';
      else category = 'BIG';
      
      const type = getRandomEnemyFromCategory(category);
      enemyQueue.push({ type, world });
    }
  }
  
  // Spawn elite enemies - from ELITE category
  if (currentWave.composition.elite) {
    for (let i = 0; i < currentWave.composition.elite; i++) {
      const type = getRandomEnemyFromCategory('ELITE');
      enemyQueue.push({ type, world });
    }
  }
  
  // Spawn boss enemies - from BOSS category
  if (currentWave.composition.boss) {
    for (let i = 0; i < currentWave.composition.boss; i++) {
      const type = getRandomEnemyFromCategory('BOSS');
      enemyQueue.push({ type, world });
    }
  }
  
  // Spawn extra buffer enemies - mix of normal types
  for (let i = 0; i < extraEnemies; i++) {
    const roll = Math.random();
    let category;
    if (roll < 0.3) category = 'SMALL';
    else if (roll < 0.8) category = 'NORMAL';
    else category = 'BIG';
    
    const type = getRandomEnemyFromCategory(category);
    enemyQueue.push({ type, world });
  }
  
  // Shuffle enemy queue for variety
  for (let i = enemyQueue.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [enemyQueue[i], enemyQueue[j]] = [enemyQueue[j], enemyQueue[i]];
  }
  
  // Calculate spawn timing - ALL challenges spawn the same way
  // Spawn like normal waves (fast and continuous)
  const spawnInterval = 300; // 0.3 seconds like CONFIG.WAVE_INTERVAL_SEC
  const spawnBatchSize = Math.min(3, Math.max(1, Math.floor(totalEnemies / 10))); // 1-3 enemies per batch
  
  const estimatedTime = (spawnInterval * Math.ceil(totalEnemies / spawnBatchSize)) / 1000;
  console.log(`[WAVE] Spawning ${totalEnemies} enemies in batches of ${spawnBatchSize} every ${spawnInterval}ms (~${estimatedTime.toFixed(1)}s total)`);
  
  // Reset spawn counter
  GameState.challengeProgress.spawnedCount = 0;
  
  // Spawn first batch immediately
  const firstBatchSize = Math.min(spawnBatchSize, enemyQueue.length);
  for (let i = 0; i < firstBatchSize; i++) {
    if (enemyQueue.length > 0) {
      const enemyData = enemyQueue.shift();
      const enemy = createEnemy(enemyData.type, enemyData.world);
      enemy.prevX = enemy.position.x;
      enemy.prevY = enemy.position.y;
      GameState.enemies.push(enemy);
      GameState.challengeProgress.spawnedCount++;
    }
  }
  
  // Schedule remaining enemies in batches
  if (enemyQueue.length > 0) {
    const intervalId = setInterval(() => {
      if (enemyQueue.length === 0 || !GameState.currentChallenge) {
        clearInterval(intervalId);
        console.log(`[WAVE] All ${totalEnemies} enemies spawned`);
        return;
      }
      
      // Spawn a batch of enemies
      const batchSize = Math.min(spawnBatchSize, enemyQueue.length);
      for (let i = 0; i < batchSize; i++) {
        if (enemyQueue.length > 0) {
          const enemyData = enemyQueue.shift();
          const enemy = createEnemy(enemyData.type, enemyData.world);
          enemy.prevX = enemy.position.x;
          enemy.prevY = enemy.position.y;
          GameState.enemies.push(enemy);
          GameState.challengeProgress.spawnedCount++;
        }
      }
    }, spawnInterval);
    
    GameState.challengeProgress.spawnIntervals.push(intervalId);
  }
  
  // Update the challenge description
  updateChallengeDescription();
}

function showChallengeOverlay() {
  const overlay = document.getElementById('challenge-overlay');
  overlay.style.display = 'block';
  
  // Initial description update
  updateChallengeDescription();
}

function hideChallengeOverlay() {
  document.getElementById('challenge-overlay').style.display = 'none';
}

function onChallengeComplete() {
  // Check if challenge was completed successfully
  if (GameState.currentChallenge && verifyChallengeComplete()) {
    // Success - complete the challenge
    completeChallenge();
    
    // Advance to next world
    GameState.player.world++;
    
    // Clear the challenge assignment for the OLD world (the one we just completed)
    const completedWorld = GameState.player.world - 1;
    if (GameState.worldProgress.assignedChallenges && GameState.worldProgress.assignedChallenges[completedWorld]) {
      delete GameState.worldProgress.assignedChallenges[completedWorld];
    }

    // Track world completion
    if (GameState.player.statistics) {
      GameState.player.statistics.worldsCompleted++;
    }

    GameState.worldProgress.enemiesKilledThisWorld = 0;
    GameState.worldProgress.elitesKilledThisWorld = 0;
    
    // Reset game state flags
    GameState.suspendWaves = false;
    GameState.inBossChallenge = false;

    showNotification(`ðŸŽ‰ Welcome to World ${GameState.player.world}!`, 'legendary');
    updateWorldProgress();
  } else if (GameState.currentChallenge) {
    // Failure - challenge requirements not met (failChallenge handles cleanup)
    failChallenge('Challenge requirements not met');
  }
}

// ========== Active Effects ==========
function updateActiveEffects() {
  const now = Date.now();
  GameState.player.activeEffects = GameState.player.activeEffects.filter(effect => {
    const elapsed = (now - effect.startedAtTs) / 1000;
    return elapsed < effect.durationSec;
  });

  // Render in inventory
  const iconsContainer = document.getElementById('active-effects-icons');
  if (!iconsContainer) return;

  if (GameState.player.activeEffects.length === 0) {
    iconsContainer.innerHTML = '<div class="no-effects-message">No active effects</div>';
  } else {
    // Map effect IDs to icons and names
    const effectData = {
      'exp_boost_200': { icon: 'ðŸ“š', name: 'EXP Boost x3', description: 'Experience gain multiplied by 3' },
      'dmg_boost_200': { icon: 'âš¡', name: 'Damage Boost x3', description: 'Damage output multiplied by 3' },
      'coins_boost_200': { icon: 'ðŸ’°', name: 'Coins Boost x3', description: 'Coin drops multiplied by 3' }
    };

    iconsContainer.innerHTML = GameState.player.activeEffects.map((effect, index) => {
      const elapsed = (now - effect.startedAtTs) / 1000;
      const remaining = Math.max(0, effect.durationSec - elapsed);
      const minutes = Math.floor(remaining / 60);
      const seconds = Math.floor(remaining % 60);
      const data = effectData[effect.id] || { icon: 'âœ¨', name: effect.id, description: 'Active effect' };

      return `
        <div class="effect-icon" data-effect-index="${index}" title="${data.name}">
          <div class="effect-icon-image">${data.icon}</div>
          <div class="effect-icon-timer">${minutes}:${seconds.toString().padStart(2, '0')}</div>
        </div>
      `;
    }).join('');

    // Add click handlers for tooltips and hover handlers for bounce animation
    iconsContainer.querySelectorAll('.effect-icon').forEach(iconEl => {
      // Bounce animation on hover (once per hover)
      iconEl.addEventListener('mouseenter', (e) => {
        const el = e.currentTarget;
        // Only add bounce if not already bouncing
        if (!el.classList.contains('bouncing')) {
          el.classList.add('bouncing');
          // Remove the class after animation completes
          setTimeout(() => {
            el.classList.remove('bouncing');
          }, 300);
        }
      });

      // Tooltip on click
      iconEl.addEventListener('click', (e) => {
        const effectIndex = parseInt(e.currentTarget.getAttribute('data-effect-index'));
        const effect = GameState.player.activeEffects[effectIndex];
        if (effect) {
          showEffectTooltip(effect, e.currentTarget);
        }
      });
    });
  }

  // Update coins and gems display in inventory
  const invCoinsEl = document.getElementById('inv-coins');
  const invGemsEl = document.getElementById('inv-gems');
  if (invCoinsEl) invCoinsEl.textContent = Math.floor(GameState.player.coins).toLocaleString();
  if (invGemsEl) invGemsEl.textContent = Math.floor(GameState.player.gems).toLocaleString();
}

// ========== Save/Load ==========
function calculateOfflineProgress(hours) {
  const p = GameState.player;
  
  // Calculate base rates per hour based on player's current stats
  // Offline earnings are at 50% efficiency
  const efficiencyMultiplier = 0.5;
  
  // Base earnings per hour (scaled by world and level)
  const baseCoinsPerHour = 1000 * p.world * (1 + p.level / 10);
  const baseGemsPerHour = 50 * Math.floor(p.world / 2);
  const baseExpPerHour = 500 * p.world * (1 + p.level / 20);
  
  // Calculate total offline earnings
  const coinsEarned = Math.floor(baseCoinsPerHour * hours * efficiencyMultiplier);
  const gemsEarned = Math.floor(baseGemsPerHour * hours * efficiencyMultiplier);
  const expEarned = Math.floor(baseExpPerHour * hours * efficiencyMultiplier);
  
  // Apply earnings
  p.coins += coinsEarned;
  p.gems += gemsEarned;
  p.exp += expEarned;
  
  // Update statistics
  if (p.statistics) {
    p.statistics.totalCoinsEarned += coinsEarned;
    p.statistics.totalGemsEarned += gemsEarned;
    p.statistics.totalExpGained += expEarned;
  }
  
  // Show notification
  const hoursText = hours < 1 ? `${Math.floor(hours * 60)} minutes` : `${hours.toFixed(1)} hours`;
  const message = `â° Welcome back! You were offline for ${hoursText}
ðŸ’° +${coinsEarned.toLocaleString()} coins
ðŸ’Ž +${gemsEarned.toLocaleString()} gems
â­ +${expEarned.toLocaleString()} XP`;
  
  setTimeout(() => {
    showNotification(message, 'success');
  }, 500);
}

function saveGame() {
  // Don't save if we're in the middle of resetting
  if (window.RESETTING_GAME) return;
  
  // Update total play time before saving
  if (GameState.player.statistics) {
    const currentSession = (Date.now() - GameState.player.statistics.sessionStartTime) / 1000;
    GameState.player.statistics.totalPlayTime += currentSession;
    GameState.player.statistics.sessionStartTime = Date.now(); // Reset session timer
  }

  const saveData = {
    saveVersion: 1,
    timestamp: Date.now(),
    lastOnlineTime: Date.now(), // Track when player was last online
    player: GameState.player,
    shop: GameState.shop,
    worldProgress: GameState.worldProgress
  };

  localStorage.setItem(CONFIG.SAVE_KEY, JSON.stringify(saveData));
  GameState.lastSaveTime = Date.now();
}

function loadGame() {
  const saved = localStorage.getItem(CONFIG.SAVE_KEY);
  if (!saved) return false;

  try {
    const data = JSON.parse(saved);
    GameState.player = data.player;
    GameState.shop = data.shop;
    GameState.worldProgress = data.worldProgress;

    // Calculate offline progression (up to 8 hours)
    if (data.lastOnlineTime) {
      const offlineTimeMs = Date.now() - data.lastOnlineTime;
      const offlineTimeSeconds = offlineTimeMs / 1000;
      const offlineTimeHours = offlineTimeSeconds / 3600;
      
      // Cap offline time at 8 hours
      const cappedOfflineHours = Math.min(offlineTimeHours, 8);
      
      if (cappedOfflineHours >= 0.016) { // At least 1 minute offline
        calculateOfflineProgress(cappedOfflineHours);
      }
    }

    // Ensure inventory is properly initialized as sparse array
    if (!GameState.player.inventory) {
      GameState.player.inventory = [];
    }

    // Initialize statistics if missing (for backward compatibility)
    if (!GameState.player.statistics) {
      GameState.player.statistics = {
        totalKills: 0,
        totalDamageDealt: 0,
        totalDamageTaken: 0,
        highestDamageDealt: 0,
        highestDamageTaken: 0,
        totalCoinsEarned: 0,
        totalGemsEarned: 0,
        totalExpGained: 0,
        bossesDefeated: 0,
        deaths: 0,
        criticalHits: 0,
        itemsFound: 0,
        itemsPurchased: 0,
        worldsCompleted: 0,
        totalPlayTime: 0,
        sessionStartTime: Date.now()
      };
    } else {
      // Add new statistics fields if they don't exist (for saves created before these fields were added)
      if (GameState.player.statistics.highestDamageDealt === undefined) {
        GameState.player.statistics.highestDamageDealt = 0;
      }
      if (GameState.player.statistics.highestDamageTaken === undefined) {
        GameState.player.statistics.highestDamageTaken = 0;
      }
      // Reset session start time for loaded game
      GameState.player.statistics.sessionStartTime = Date.now();
    }

    // Clean up invalid equipment data before computing stats
    try {
      cleanupInvalidEquipment();
    } catch (cleanupError) {
      console.error('Error during equipment cleanup:', cleanupError);
    }

    computeDerivedStats();
    return true;
  } catch (e) {
    console.error('Failed to load save:', e);
    showNotification('Error: Failed to load save: ' + e.message, 'danger');
    return false;
  }
}

// Clean up any invalid equipment data that might cause errors
function cleanupInvalidEquipment() {
  const p = GameState.player;
  if (!p || !p.equipment) return;

  // Check each equipment slot
  Object.keys(p.equipment).forEach(slot => {
    const item = p.equipment[slot];
    if (!item) return;

    // Ensure item has required properties
    if (!item.name) {
      console.warn(`Equipment in slot ${slot} has no name, removing:`, item);
      p.equipment[slot] = null;
      return;
    }

    // If item has a setId, validate it exists
    if (item.setId) {
      const setData = EQUIPMENT_SETS[item.setId];
      if (!setData) {
        console.warn(`Removing invalid setId "${item.setId}" from ${item.name}`);
        delete item.setId;
      }
    }
  });

  // Check inventory
  if (p.inventory) {
    for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
      const item = p.inventory[i];
      if (!item) continue;

      if (!item.name) {
        console.warn(`Inventory item at index ${i} has no name, removing:`, item);
        delete p.inventory[i];
        continue;
      }

      if (item.setId) {
        const setData = EQUIPMENT_SETS[item.setId];
        if (!setData) {
          console.warn(`Removing invalid setId "${item.setId}" from ${item.name}`);
          delete item.setId;
        }
      }
    }
  }

  // Check shop offers
  if (GameState.shop && GameState.shop.offers && GameState.shop.offers.equipment) {
    GameState.shop.offers.equipment = GameState.shop.offers.equipment.filter(item => {
      if (!item || !item.name) {
        console.warn('Removing invalid shop item:', item);
        return false;
      }
      if (item.setId && !EQUIPMENT_SETS[item.setId]) {
        console.warn(`Removing invalid setId "${item.setId}" from shop item ${item.name}`);
        delete item.setId;
      }
      return true;
    });
  }

  // Rebuild activeSets from scratch
  const setCounts = {};
  Object.keys(p.equipment || {}).forEach(slot => {
    const item = p.equipment[slot];
    if (item && item.setId && EQUIPMENT_SETS[item.setId]) {
      setCounts[item.setId] = (setCounts[item.setId] || 0) + 1;
    }
  });
  p.activeSets = setCounts;
}

// ========== Notifications ==========
function showNotification(message, type = 'info') {
  const container = document.getElementById('notification-container');
  if (!container) {
    console.log(`[${type.toUpperCase()}] ${message}`);
    return;
  }

  // Create notification element
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;

  // Add to container
  container.appendChild(notification);

  // Auto-remove after 3 seconds
  setTimeout(() => {
    notification.style.animation = 'fadeOut 0.3s ease-out';
    setTimeout(() => {
      if (notification.parentNode === container) {
        container.removeChild(notification);
      }
    }, 300);
  }, 3000);
}

function showFloatingChange(amount, kind) {
  if (!amount) return;

  const id = (kind === 'gems') ? 'gems' : 'coins';
  let el = document.getElementById(id);

  // If inventory is open, also show floating change on inventory resources
  const invOverlay = document.getElementById('inventory-overlay');
  if (invOverlay && invOverlay.getAttribute('aria-hidden') === 'false') {
    const invId = (kind === 'gems') ? 'inv-gems' : 'inv-coins';
    const invEl = document.getElementById(invId);
    if (invEl) {
      createFloatingChange(invEl, amount);
    }
  }

  if (!el) {
    console.warn('showFloatingChange: target element not found #' + id);
    return;
  }

  createFloatingChange(el, amount);
}

function createFloatingChange(el, amount) {
  // create node
  const node = document.createElement('div');
  node.className = 'floating-change ' + (amount > 0 ? 'positive' : 'negative');
  node.textContent = (amount > 0 ? `+${amount}` : `${amount}`);

  // append to body so it's positioned relative to viewport
  document.body.appendChild(node);

  // measure
  const rect = el.getBoundingClientRect();

  // place offscreen to force layout, then measure size
  node.style.position = 'absolute';
  node.style.left = '0px';
  node.style.top = '-9999px';
  node.style.pointerEvents = 'none';
  // force layout
  // eslint-disable-next-line no-unused-expressions
  node.offsetWidth;

  const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
  // Align right edge of popup with right edge of the element:
  // left = rect.right - node.offsetWidth
  let left = rect.right - node.offsetWidth;

  // clamp so it stays in viewport with 8px padding
  left = Math.min(Math.max(8, left), Math.max(8, vw - node.offsetWidth - 8));

  // position it just below the element (aligned to right)
  const top = rect.bottom - 4;

  Object.assign(node.style, {
    left: `${left}px`,
    top: `${top}px`,
    transform: 'translateY(0)', // start position (no offset)
    opacity: '1',
    position: 'absolute',
    zIndex: '9999'
  });

  // force reflow so transition runs
  // eslint-disable-next-line no-unused-expressions
  node.offsetHeight;

  // animate: move a bit down and fade out
  requestAnimationFrame(() => {
    node.style.transform = 'translateY(8px)'; // moves downward
    node.style.opacity = '0';
  });

  // cleanup
  setTimeout(() => {
    if (node && node.parentNode) node.parentNode.removeChild(node);
  }, 900);
}

// ========== Overlay Management ==========
function openOverlay(id) {
  const overlay = document.getElementById(id);
  overlay.setAttribute('aria-hidden', 'false');

  if (id === 'inventory-overlay') renderInventory();
  if (id === 'shop-overlay') renderShop();
}

function closeOverlay(id) {
  const overlay = document.getElementById(id);
  overlay.setAttribute('aria-hidden', 'true');
  hideTooltip();
}

// ========== SET BONUS IMPLEMENTATION ==========

function getSetCount(setId) {
  const p = GameState.player;
  return (p.activeSets && p.activeSets[setId]) || 0;
}

function initializeSetBonusTracking() {
  const p = GameState.player;
  if (!p.setBonusTracking) {
    p.setBonusTracking = {
      nightwing: { coinsCollected: 0, wealthStacks: 0, wealthStackExpiry: [] },
      shade: { hpLossAccumulator: 0, hpHealAccumulator: 0, bloodthirstStacks: 0, bloodthirstStackExpiry: [] },
      bastion: { shockRoarTimer: 0 },
      emberkin: { fireKillCount: 0, igniteAOEs: [] },
      glacier: { frozenEnemies: new Set() },
      aegis: { activeBalls: [] },
      zephyr: { activeStars: [] }
    };
  }
}

function updateSetBonusesPeriodic(dt) {
  const p = GameState.player;
  initializeSetBonusTracking();

  // BASTION 3-PIECE: Shock Roar every 2 seconds
  if (getSetCount('bastion') >= 3) {
    p.setBonusTracking.bastion.shockRoarTimer += dt;
    if (p.setBonusTracking.bastion.shockRoarTimer >= 1.5) {
      p.setBonusTracking.bastion.shockRoarTimer = 0;
      const stage = document.getElementById('stage');
      const playerX = stage.clientWidth / 2;
      const playerY = stage.clientHeight / 2;

      // 6-piece: Metal Fierce increases area and changes color
      const has6Piece = getSetCount('bastion') >= 6;
      const isLowHP = getPlayerHP(p) < (p.maxHp || p.HP_max || 1) * 0.50;

      let shockRadius = 150;
      if (has6Piece && isLowHP) {
        shockRadius = 250; // Increased area
      }

      const shockColor = (has6Piece && isLowHP) ? '#ffcccc' : '#d4af37'; // Light red when Metal Fierce active
      const shockDamage = Math.floor((p.maxHp || 0) * 0.5 * 1.80);

      const playerEl = document.getElementById('player-container');
      if (playerEl) {
        const rect = playerEl.getBoundingClientRect();
        spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, shockRadius, shockColor, 300);
      }
      GameState.enemies.forEach(enemy => {
        const dx = playerX - enemy.position.x;
        const dy = playerY - enemy.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= shockRadius) {
          applyCritDamage(enemy, shockDamage, { type: 'physical', source: 'shock_roar', setId: 'bastion'});
        }
      });
    }
  }

  // NIGHTWING 6-PIECE: Wealth stack decay
  if (getSetCount('nightwing') >= 6) {
    p.setBonusTracking.nightwing.wealthStackExpiry = p.setBonusTracking.nightwing.wealthStackExpiry.filter(expiry => {
      if (Date.now() >= expiry) {
        p.setBonusTracking.nightwing.wealthStacks = Math.max(0, p.setBonusTracking.nightwing.wealthStacks - 1);
        computeDerivedStats();
        return false;
      }
      return true;
    });
  }

  // SHADE 6-PIECE: Bloodthirst stack decay
  if (getSetCount('shade') >= 6) {
    p.setBonusTracking.shade.bloodthirstStackExpiry = p.setBonusTracking.shade.bloodthirstStackExpiry.filter(expiry => {
      if (Date.now() >= expiry) {
        p.setBonusTracking.shade.bloodthirstStacks = Math.max(0, p.setBonusTracking.shade.bloodthirstStacks - 1);
        computeDerivedStats();
        return false;
      }
      return true;
    });
  }

    // SHADE 3-PIECE: Bloodbath rain zone damage ticks
  if (getSetCount('shade') >= 3 && p.shadeRainZones) {
    p.shadeRainZones.forEach(zone => {
      if (Date.now() - zone.startTime <= zone.duration) {
        GameState.enemies.forEach(enemy => {
          const dx = zone.x - (enemy.position?.x || enemy.x || 0);
          const dy = zone.y - (enemy.position?.y || enemy.y || 0);
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= zone.radius) {
            applyDamageToEnemy(enemy, Math.floor(zone.damage), { type: 'physical', source: 'bloodbath_rain', setId: 'shade', isDoT: true });
          }
        });
      }
    });
  }

  // EMBERKIN: Fire zone damage ticks (same mechanics as Bloodbath)
  if (p.emberkinFireZones) {
    p.emberkinFireZones.forEach(zone => {
      const now = Date.now();
      if (now - zone.startTime <= zone.duration) {
        GameState.enemies.forEach(enemy => {
          const enemyX = enemy.position?.x || enemy.x || 0;
          const enemyY = enemy.position?.y || enemy.y || 0;
          const dist = Math.sqrt((zone.x - enemyX)**2 + (zone.y - enemyY)**2);

          if (dist <= zone.radius) {
            // Track when enemy entered zone
            if (!zone.affectedEnemies.has(enemy.id)) {
              zone.affectedEnemies.set(enemy.id, { enteredAt: now, lastTickAt: 0 });
            }

            const enemyData = zone.affectedEnemies.get(enemy.id);

            // Deal damage every tick if within burn duration and enough time has passed
            if (now - enemyData.enteredAt < zone.burnDuration && now - enemyData.lastTickAt >= 200) {
              // Calculate burn damage with 3-piece bonus
              let totalBurnDmg = zone.baseDamage;
              if (getSetCount('emberkin') >= 3) {
                totalBurnDmg += calculateWeaponDamage(p, 0.08);
              }

              applyDamageToEnemy(enemy, Math.floor(totalBurnDmg), { type: 'fire', source: 'weapon_zone', setId: 'emberkin', isDoT: true });
              enemyData.lastTickAt = now;
            }
          } else {
            // Enemy left zone
            zone.affectedEnemies.delete(enemy.id);
          }
        });

        // Clean up old entries
        for (const [enemyId, data] of zone.affectedEnemies.entries()) {
          if (now - data.enteredAt >= zone.burnDuration) {
            zone.affectedEnemies.delete(enemyId);
          }
        }
      }
    });
  }

  // EMBERKIN 6-PIECE: Ignite AOE damage ticks
  if (getSetCount('emberkin') >= 6 && p.setBonusTracking.emberkin.igniteAOEs) {
    p.setBonusTracking.emberkin.igniteAOEs = p.setBonusTracking.emberkin.igniteAOEs.filter(aoe => {
      const elapsed = Date.now() - aoe.startTime;
      if (elapsed > aoe.duration) {
        if (aoe.element && aoe.element.parentNode) aoe.element.remove();
        return false;
      }

      const now = Date.now();

      // Track which enemies are affected (similar to fire zones)
      if (!aoe.affectedEnemies) {
        aoe.affectedEnemies = new Map();
      }

      GameState.enemies.forEach(enemy => {
        const dx = aoe.x - (enemy.position?.x || enemy.x || 0);
        const dy = aoe.y - (enemy.position?.y || enemy.y || 0);
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= aoe.radius) {
          // Track when enemy entered zone
          if (!aoe.affectedEnemies.has(enemy.id)) {
            aoe.affectedEnemies.set(enemy.id, { enteredAt: now, lastTickAt: 0 });
          }

          const enemyData = aoe.affectedEnemies.get(enemy.id);

          // Deal damage every 200ms (same tick rate as regular fire zones) for 10 seconds after entering
          if (now - enemyData.enteredAt < 10000 && now - enemyData.lastTickAt >= 200) {
            const tickDmg = Math.floor((p.currentStats?.finalATK || 0) * 0.65);
            applyCritDamage(enemy, tickDmg, { type: 'fire', source: 'ignite_aoe', setId: 'emberkin', isDoT: true});
            enemyData.lastTickAt = now;
          }
        } else {
          // Enemy left zone
          aoe.affectedEnemies.delete(enemy.id);
        }
      });

      // Clean up old entries
      for (const [enemyId, data] of aoe.affectedEnemies.entries()) {
        if (now - data.enteredAt >= 10000) {
          aoe.affectedEnemies.delete(enemyId);
        }
      }

      return true;
    });
  }
}

function handleSetBonusOnKill(enemy) {
  const p = GameState.player;
  initializeSetBonusTracking();

  // NIGHTWING 6-PIECE: Wealth stacks
  if (getSetCount('nightwing') >= 6) {
    const coins = enemy.dropProfile?.coinBase || 0;
    p.setBonusTracking.nightwing.coinsCollected = (p.setBonusTracking.nightwing.coinsCollected || 0) + coins;
    while (p.setBonusTracking.nightwing.coinsCollected >= 10000 && p.setBonusTracking.nightwing.wealthStacks < 9) {
      p.setBonusTracking.nightwing.coinsCollected -= 10000;
      p.setBonusTracking.nightwing.wealthStacks++;
      p.setBonusTracking.nightwing.wealthStackExpiry.push(Date.now() + 30000);
      showNotification('ðŸ’° Wealth stack gained! (+20% DMG)', 'legendary');
      computeDerivedStats();
    }

  // NIGHTWING 6-PIECE: Wealth Rain - track coin kills
    if (getSetCount('nightwing') >= 6 && enemy.lastHit && enemy.lastHit.source && enemy.lastHit.source.includes('coin')) {
      if (!p.nightwingCoinKills) p.nightwingCoinKills = 0;

      // Don't count rain kills
      if (enemy.lastHit.source !== 'wealth_rain') {
        p.nightwingCoinKills++;

        if (p.nightwingCoinKills >= 20) {
          p.nightwingCoinKills = 0;

          // Rain coins visually on full screen for 5 seconds
          const rainDmg = Math.floor(p.coins * 0.0188);
          const rainDuration = 5000;
          const rainStartTime = Date.now();

          // Create full-screen coin rain effect
          const stage = document.getElementById('stage');
          if (stage) {
            const stageRect = stage.getBoundingClientRect();

            const rainInterval = setInterval(() => {
              if (Date.now() - rainStartTime >= rainDuration) {
                clearInterval(rainInterval);
                return;
              }

              // Create coins falling across the entire screen
              for (let i = 0; i < 15; i++) {
                const startX = Math.random() * stageRect.width;
                const startY = -50;
                const endY = stageRect.height + 50;

                const particle = document.createElement('div');
                particle.textContent = 'ðŸ’°';
                particle.style.cssText = `position:absolute;left:${startX}px;top:${startY}px;font-size:20px;transform:translate(-50%,0);pointer-events:none;z-index:55;transition:all 1.2s linear;opacity:1;`;
                stage.appendChild(particle);

                setTimeout(() => {
                  particle.style.top = `${endY}px`;
                  particle.style.opacity = '0.3';
                }, 10);

                setTimeout(() => particle.remove(), 1250);
              }

              // Deal damage to all enemies on field
              GameState.enemies.forEach(e => {
                if (e.hp > 0) {
                  applyCritDamage(e, rainDmg, { type: 'physical', source: 'wealth_rain', setId: 'nightwing'});
                }
              });
            }, 150); // Rain every 150ms for denser effect
          }

          showNotification('ðŸ’°ðŸ’°ðŸ’° Coin Rain! ðŸ’°ðŸ’°ðŸ’°', 'legendary');
        }
      }
    }

    // NIGHTWING 3-PIECE: Rich Man's Blow
  if (getSetCount('nightwing') >= 3 && enemy.lastHit && enemy.lastHit.source === 'weapon_coin') {
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;
    const coinDmg = Math.floor(p.coins * 0.0099);

    // Shoot 5 coins in star pattern
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const distance = 120;
      const toX = enemyX + Math.cos(angle) * distance;
      const toY = enemyY + Math.sin(angle) * distance;

      setTimeout(() => {
        const enemyElPos = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
        const stage = document.getElementById('stage');
        if (stage) {
          createProjectile({
            fromX: enemyX, fromY: enemyY, toX: toX, toY: toY,
            color: '#ffd700', size: 12, travelMs: 250,
            onArrive: () => {
              const hits = findEnemiesInRadius(toX, toY, 50);
              hits.forEach(hit => {
                applyCritDamage(hit, coinDmg, { type: 'physical', source: 'rich_mans_blow', setId: 'nightwing'});
              });
            }
          });
        }
      }, i * 50);
    }
  }
  }

  // EMBERKIN 6-PIECE: Ignite
  if (getSetCount('emberkin') >= 6 && enemy.lastHit && enemy.lastHit.type === 'fire') {
    p.setBonusTracking.emberkin.fireKillCount = (p.setBonusTracking.emberkin.fireKillCount || 0) + 1;
    if (p.setBonusTracking.emberkin.fireKillCount >= 10) {
      p.setBonusTracking.emberkin.fireKillCount = 0;
      const stage = document.getElementById('stage');
      const w = stage.clientWidth;
      const h = stage.clientHeight;

      // Create 3 giant red-pink fire zones around the player
      for (let i = 0; i < 3; i++) {
        const angle = (i / 3) * Math.PI * 2;
        const distance = 150 + Math.random() * 100;
        const playerX = w / 2;
        const playerY = h / 2;
        const x = playerX + Math.cos(angle) * distance;
        const y = playerY + Math.sin(angle) * distance;

        const fireAOE = document.createElement('div');
        fireAOE.className = 'fire-aoe-ignite';
        fireAOE.style.cssText = 'position:absolute;left:'+x+'px;top:'+y+'px;width:180px;height:180px;border-radius:50%;background:radial-gradient(circle,rgba(255,100,150,0.7),rgba(255,50,100,0.4),rgba(255,0,50,0.2));border:3px solid rgba(255,100,150,0.8);box-shadow:0 0 40px rgba(255,100,100,0.9), inset 0 0 30px rgba(255,50,100,0.5);transform:translate(-50%,-50%);pointer-events:none;z-index:40;animation:fire-pulse 1s infinite;';
        document.getElementById('enemy-layer').appendChild(fireAOE);
        p.setBonusTracking.emberkin.igniteAOEs.push({ x: x, y: y, radius: 90, startTime: Date.now(), duration: 10000, element: fireAOE });
      }
      showNotification('ðŸ”¥ Ignite! Created 3 giant fire zones!', 'legendary');
    }
  }

  // GLACIER 6-PIECE: Ice Storm
  if (getSetCount('glacier') >= 6 && enemy.lastHit && enemy.lastHit.type === 'cryo') {
    const now = Date.now();

    // Check if cooldown has passed (30 seconds)
    if (!p.glacierIceStormCooldown || now >= p.glacierIceStormCooldown) {
      p.glacierIceStormCooldown = now + 30000; // 30 second cooldown

      // Freeze ALL enemies on the field for 5 seconds
      GameState.enemies.forEach(e => {
        if (e.hp > 0) {
          e.frozen = true;
          e.frozenTimer = 5.0; // 5 second freeze
          e.frozenAt = now;
          e.originalSpeed = e.speed;
          e.speed = 0;
          // Don't set freezeCooldownUntil here as this is a special 6-piece effect

          // Visual effect
          const enemyEl = document.querySelector(`[data-enemy-id="${e.id}"]`);
          if (enemyEl) {
            const rect = enemyEl.getBoundingClientRect();
            spawnShockwave(rect.left + rect.width/2, rect.top + rect.height/2, 50, getElementColor('cryo'), 400);
            enemyEl.style.filter = 'brightness(1.5) saturate(0.3) hue-rotate(180deg)';
            setTimeout(() => {
              if (enemyEl) enemyEl.style.filter = '';
            }, 5000);
          }
        }
      });

      showNotification('â„ï¸ Ice Storm! All enemies frozen! â„ï¸', 'legendary');
    }
  }

  // SKYWARDEN 3-PIECE: Wind Storm - 3 explosions
  if (getSetCount('skywarden') >= 3 && enemy.lastHit && enemy.lastHit.type === 'wind') {
    const enemyX = enemy.position?.x || enemy.x || 0;
    const enemyY = enemy.position?.y || enemy.y || 0;

    // Create 3 small explosions nearby
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2;
      const distance = 80;
      const explX = enemyX + Math.cos(angle) * distance;
      const explY = enemyY + Math.sin(angle) * distance;

      setTimeout(() => {
        const explDmg = Math.floor((p.currentStats?.finalATK || 0) * 0.50);
        const nearbyEnemies = findEnemiesInRadius(explX, explY, 60);
        nearbyEnemies.forEach(e => {
          applyCritDamage(e, explDmg, { type: 'wind', source: 'wind_storm', setId: 'skywarden'});
        });

        const tornadoEl = document.createElement('div');
        tornadoEl.style.cssText = `position:absolute;left:${explX}px;top:${explY}px;width:80px;height:80px;border-radius:50%;background:radial-gradient(circle, transparent 20%, rgba(152,251,152,0.5) 50%, rgba(152,251,152,0.8) 70%, transparent 100%);transform:translate(-50%,-50%);pointer-events:none;z-index:45;animation:spin 0.5s linear, wind-pulse 0.4s ease-out;`;
        document.getElementById('enemy-layer').appendChild(tornadoEl);
        setTimeout(() => tornadoEl.remove(), 500);
      }, i * 150);
    }
  }

  // SKYWARDEN 6-PIECE: Aquila Tornado - every 20 wind kills
  if (getSetCount('skywarden') >= 6 && enemy.lastHit && enemy.lastHit.type === 'wind') {
    if (!p.skywardenWindKills) p.skywardenWindKills = 0;
    p.skywardenWindKills++;

    if (p.skywardenWindKills >= 20) {
      p.skywardenWindKills = 0;

      // Pick random enemy for tornado
      const availableEnemies = GameState.enemies.filter(e => e.hp > 0);
      if (availableEnemies.length > 0) {
        const tornadoTarget = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
        const tornadoX = tornadoTarget.position?.x || tornadoTarget.x || 0;
        const tornadoY = tornadoTarget.position?.y || tornadoTarget.y || 0;

        // Create giant tornado with improved visuals
        const tornadoEl = document.createElement('div');
        tornadoEl.style.cssText = `position:absolute;left:${tornadoX}px;top:${tornadoY}px;width:40px;height:40px;border-radius:50%;background:radial-gradient(circle, rgba(152,251,152,0.2) 0%, rgba(152,251,152,0.6) 40%, rgba(152,251,152,0.9) 70%, transparent 100%);box-shadow:0 0 30px rgba(152,251,152,0.8), inset 0 0 20px rgba(200,255,200,0.5);transform:translate(-50%,-50%);pointer-events:none;z-index:46;transition:all 1s ease-out;`;
        document.getElementById('enemy-layer').appendChild(tornadoEl);

        // Scale up tornado
        setTimeout(() => {
          tornadoEl.style.width = '200px';
          tornadoEl.style.height = '200px';
          tornadoEl.style.animation = 'spin 1s linear infinite, wind-pulse 2s ease-in-out infinite';
        }, 50);

        // Pull enemies and deal damage for 5 seconds
        const tornadoStart = Date.now();
        const tornadoDuration = 5000;
        const pullRadius = 200;
        const tornadoDmg = Math.floor((p.currentStats?.finalATK || 0) * 0.50);

        const tornadoInterval = setInterval(() => {
          const elapsed = Date.now() - tornadoStart;
          if (elapsed >= tornadoDuration) {
            clearInterval(tornadoInterval);

            // Scale down and remove
            tornadoEl.style.transition = 'all 0.5s ease-in';
            tornadoEl.style.width = '0px';
            tornadoEl.style.height = '0px';
            tornadoEl.style.opacity = '0';
            setTimeout(() => tornadoEl.remove(), 500);
            return;
          }

          // Pull enemies towards tornado and damage them
          GameState.enemies.forEach(e => {
            const dx = tornadoX - (e.position?.x || e.x || 0);
            const dy = tornadoY - (e.position?.y || e.y || 0);
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist <= pullRadius) {
              // Pull towards center
              const pullStrength = 0.15;
              e.position.x += (dx / dist) * pullStrength * 20;
              e.position.y += (dy / dist) * pullStrength * 20;

              // Deal damage each tick
              if (Math.random() < 0.5) { // 50% chance per tick to avoid spam
                applyCritDamage(e, tornadoDmg, { type: 'wind', source: 'aquila_tornado', setId: 'skywarden', isDoT: true});
              }
            }
          });
        }, 200); // Tick every 200ms

        showNotification('ðŸŒªï¸ Aquila Tornado summoned!', 'legendary');
      }
    }
  }
}

function trackShadeHPChange(amount) {
  const p = GameState.player;
  if (getSetCount('shade') < 6) return;
  initializeSetBonusTracking();
  if (amount < 0) {
    p.setBonusTracking.shade.hpLossAccumulator = (p.setBonusTracking.shade.hpLossAccumulator || 0) + Math.abs(amount);
  } else {
    p.setBonusTracking.shade.hpHealAccumulator = (p.setBonusTracking.shade.hpHealAccumulator || 0) + amount;
  }
  const totalChange = (p.setBonusTracking.shade.hpLossAccumulator || 0) + (p.setBonusTracking.shade.hpHealAccumulator || 0);
  while (totalChange >= 200 && p.setBonusTracking.shade.bloodthirstStacks < 99) {
    const toDeduct = Math.min(200, p.setBonusTracking.shade.hpLossAccumulator + p.setBonusTracking.shade.hpHealAccumulator);
    if (p.setBonusTracking.shade.hpLossAccumulator >= toDeduct) {
      p.setBonusTracking.shade.hpLossAccumulator -= toDeduct;
    } else {
      const remaining = toDeduct - p.setBonusTracking.shade.hpLossAccumulator;
      p.setBonusTracking.shade.hpLossAccumulator = 0;
      p.setBonusTracking.shade.hpHealAccumulator -= remaining;
    }
    p.setBonusTracking.shade.bloodthirstStacks++;
    p.setBonusTracking.shade.bloodthirstStackExpiry.push(Date.now() + 30000);
    showNotification('ðŸ’€ Bloodthirst stack gained! (+2% DMG)', 'legendary');
    computeDerivedStats();
  }
}

// ========== Game Loop ==========
function gameTick() {

  const dt = (CONFIG.TICK_INTERVAL_MS / 1000) * CONFIG.GAME_TIME_SCALE;

  updateEnemies(dt);
  
  // Update player burn effects
  updatePlayerBurns(dt);
  
  // Update player debuffs (from mage)
  updatePlayerDebuffs();

  // Process status effects (burn, slow, freeze, etc.)
  processEnemyStatusTicks(CONFIG.TICK_INTERVAL_MS);

  // Update death system
  updateDeathSystem(dt);

  // snapshot current positions for next frame's interpolation (AFTER update)
  if (GameState && GameState.enemies) GameState.enemies.forEach(e => { e.prevX = e.position.x; e.prevY = e.position.y; });
  GameState.lastPhysicsTs = performance.now();

  updateSetBonusesPeriodic(dt);

  // Process enchantment effects
  processEnchantmentBurns(dt);
  updateRageEnchantmentBonus();
  updateTimedEnchantments(dt);

  GameState.autoAttackTimer += dt;
  const attackInterval = getAttackInterval();
  if (GameState.autoAttackTimer >= attackInterval) {
    GameState.autoAttackTimer -= attackInterval;

    // Get player's auto-attack range (different from enemy engagement range)
    const weaponItem = GameState.player.equipment && GameState.player.equipment.weapon;
    let playerAttackRange = CONFIG.ENGAGE_RADIUS_PX;
    if (weaponItem) {
      // Weapon equipped - increase player's attack range
      if (weaponItem.setId) {
        // Set weapon - 50% increased range
        playerAttackRange = CONFIG.ENGAGE_RADIUS_PX * 1.5;
      } else {
        // Regular weapon - 25% increased range
        playerAttackRange = CONFIG.ENGAGE_RADIUS_PX * 1.25;
      }
    }

    // Find closest enemy within player's attack range
    const stage = document.getElementById('stage');
    const playerX = stage.clientWidth / 2;
    const playerY = stage.clientHeight / 2;

    let target = null;
    let minDistance = playerAttackRange;

    GameState.enemies.forEach(enemy => {
      const dx = playerX - enemy.position.x;
      const dy = playerY - enemy.position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance <= playerAttackRange && distance < minDistance) {
        minDistance = distance;
        target = enemy;
      }
    });

    if (target) {
      attackEnemy(target);
    }
  }

  if (!GameState.suspendWaves) {
    GameState.waveTimer += dt;
    if (GameState.waveTimer >= CONFIG.WAVE_INTERVAL_SEC) {
      GameState.waveTimer -= CONFIG.WAVE_INTERVAL_SEC;
      spawnWave();
    }
  }

  // Update challenge timer for timed challenges
  if (GameState.currentChallenge) {
    updateChallengeTimer();
  }

  // Track wave completion when requirements are met (not waiting for all enemies to die)
  if (GameState.currentChallenge && !GameState.isDead) {
    trackWaveCompletion();
  }

  // Check if challenge is complete when all enemies defeated
  if (GameState.suspendWaves && GameState.enemies.length === 0 && !GameState.isDead) {
    const isComplete = verifyChallengeComplete();
    if (isComplete) {
      console.log('[CHALLENGE] All waves complete! Ending challenge.');
      onChallengeComplete();
    }
  }

  if (Date.now() - GameState.lastSaveTime > CONFIG.SAVE_INTERVAL_MS) {
    saveGame();
  }
}

function uiTick() {
  renderUI();
  renderEnemies();
  renderPlayerStats();
  
  // Update challenge timer and description
  if (GameState.currentChallenge) {
    updateChallengeTimer();
    updateChallengeDescription();
  }

  const shop = GameState.shop;
  const timeUntilRefresh = CONFIG.SHOP_AUTO_REFRESH_SEC - Math.floor((Date.now() - shop.lastRefreshTs) / 1000);
  if (timeUntilRefresh <= 0) {
    refreshShop();
  }
  document.getElementById('shop-timer').textContent = `Auto refreshes in: ${Math.max(0, timeUntilRefresh)}s`;

  const canManualRefresh = Date.now() >= shop.manualCooldownEndTs;
  const btn = document.getElementById('btn-manual-refresh');
  btn.disabled = !canManualRefresh;
  if (!canManualRefresh) {
    const cooldown = Math.ceil((shop.manualCooldownEndTs - Date.now()) / 1000);
    btn.textContent = `Refresh (${cooldown}s)`;
  } else {
    btn.textContent = 'Refresh';
  }
}

// ========== Dev Tools ==========
const DevTools = {
  spawnEnemies(count, type) {
    for (let i = 0; i < count; i++) {
      const enemy = createEnemy(type, GameState.player.world);
      GameState.enemies.push(enemy);
    }
  },

  grantCoins(amount) {
    GameState.player.coins += amount;
    showFloatingChange(amount, 'coins');
  },

  grantGems(amount) {
    GameState.player.gems += amount;
    showFloatingChange(amount, 'gems');
  },

  levelUp() {
    GameState.player.level++;
    GameState.player.baseStats.ATK += 10;
    GameState.player.baseStats.HP += 20;
    GameState.player.baseStats.SPD += 1;
    computeDerivedStats();
    GameState.player.hp = GameState.player.maxHp;
  },

  clearSave() {
    if (confirm('Clear all save data?')) {
      localStorage.removeItem(CONFIG.SAVE_KEY);
      location.reload();
    }
  },

  grantSet(setId) {
    try {
      const p = GameState.player;
      if (!p) {
        console.error('GameState.player is undefined');
        showNotification('Error: Player not initialized', 'danger');
        return;
      }

      const setData = EQUIPMENT_SETS[setId];
      if (!setData) {
        console.error('Set not found:', setId);
        showNotification(`Unknown set: ${setId}`, 'danger');
        return;
      }

      console.log('Granting set:', setId, setData);

      // Initialize equipment and inventory if needed
      if (!p.equipment) p.equipment = {};
      if (!p.inventory) p.inventory = {};
      if (!GameState.itemIdCounter) GameState.itemIdCounter = 1000;

      // Clear current equipment and move to inventory if there's space
      Object.keys(p.equipment).forEach(slot => {
        const item = p.equipment[slot];
        if (item) {
          // Find first empty slot in inventory
          let placed = false;
          for (let i = 0; i < CONFIG.MAX_INVENTORY_SLOTS; i++) {
            if (p.inventory[i] == null) {
              p.inventory[i] = item;
              placed = true;
              break;
            }
          }
          // If inventory is full, just discard the old item
          if (!placed) {
            console.log('Inventory full, discarding old item:', item.name);
          }
        }
        p.equipment[slot] = null;
      });

      // Grant all items from the set at divine rarity with max stats
      if (!setData.items) {
        console.error('Set has no items:', setId);
        showNotification('Error: Set has no items', 'danger');
        return;
      }

      const divineBaseRanges = BASE_STAT_RANGES.divine;
      const divineAffixRanges = AFFIX_RANGES.divine;
      const divineLevel100Stats = BASE_STAT_LEVEL100.divine;

      Object.keys(setData.items).forEach(itemKey => {
        const itemTemplate = setData.items[itemKey];
        if (!itemTemplate) {
          console.error('Item template is undefined for key:', itemKey);
          return;
        }

        const slot = itemTemplate.slot;

        // Determine base attribute based on slot (matching generateEquipment)
        let baseAttrName;
        if (slot === 'helmet') baseAttrName = 'ATK';
        else if (slot === 'chestplate') baseAttrName = 'HP';
        else if (slot === 'leggings') baseAttrName = 'HP';
        else if (slot === 'boots') baseAttrName = 'SPD';
        else if (slot === 'ring') baseAttrName = 'DMG%';
        else if (slot === 'weapon') baseAttrName = 'ATK';

        // Create item with full structure matching generateEquipment
        const item = {
          id: `item_${GameState.itemIdCounter++}`,
          type: 'equipment',
          slot: slot,
          name: itemTemplate.name,
          icon: itemTemplate.icon,
          rarity: 'divine',
          level: 100,
          stars: 5,
          setId: setId,
          setName: setData.name,
          element: setData.element,
          baseAttribute: {
            name: baseAttrName,
            value: divineLevel100Stats[baseAttrName] // Level 100 value for divine base stat
          },
          initialBaseValue: divineBaseRanges[baseAttrName][1], // Store initial level 1 value for level scaling reference
          affixes: [
            {
              name: 'ATK%',
              value: divineAffixRanges['ATK%'][1], // 50 (max)
              locked: false, // Unlocked since we're giving them for testing
              unlockLevel: 10
            },
            {
              name: 'DMG%',
              value: divineAffixRanges['DMG%'][1], // 150 (max)
              locked: false,
              unlockLevel: 25
            },
            {
              name: 'Crit Rate',
              value: divineAffixRanges['Crit Rate'][1], // 50 (max)
              locked: false,
              unlockLevel: 50
            },
            {
              name: 'Crit Damage',
              value: divineAffixRanges['Crit Damage'][1], // 350 (max)
              locked: false,
              unlockLevel: 75
            }
          ],
          buyPrice: 0,
          sellPrice: 0,
          createdAtWorld: p.world || 1
        };

        // Set weapon properties if it's a weapon
        if (itemTemplate.isWeapon) {
          item.isWeapon = true;
          item.weaponMultiplier = itemTemplate.multiplier || 1.0;
        }

        console.log('Equipping item:', item);

        // Equip the item
        p.equipment[slot] = item;
      });

      // Recompute stats
      computeDerivedStats();
      renderInventory();
      renderPlayerStats();

      showNotification(`âœ¨ Granted full ${setData.name} set!`, 'success');
    } catch (error) {
      console.error('Error in grantSet:', error);
      showNotification(`Error: ${error.message}`, 'danger');
    }
  }
};

function updateDebugPanel() {
  const info = document.getElementById('debug-info');
  info.innerHTML = `
    <div style="font-size: 10px; margin-bottom: 8px;">
      Seed: ${CONFIG.AUTO_ATTACK_SEED || 'random'}<br>
      Enemies: ${GameState.enemies.length}<br>
      Wave: ${Math.floor(GameState.waveTimer)}s / ${CONFIG.WAVE_INTERVAL_SEC}s<br>
      ATK Interval: ${getAttackInterval().toFixed(2)}s<br>
      Luck: ${GameState.player.luck}
    </div>
  `;
}

// ========== Initialization ==========

// Clean up invalid setIds from equipment (for old save data compatibility)
function cleanupInvalidSetIds() {
  cleanupInvalidEquipment();
}

function init() {
  try {
    GameState.rng = new RNG(CONFIG.AUTO_ATTACK_SEED);

    const loaded = loadGame();
    if (!loaded) {
      GameState.player = createPlayer();
      GameState.shop = createShop();
      GameState.worldProgress = createWorldProgress();
      refreshShop();
    }

    // Clean up any invalid setIds from old save data
    cleanupInvalidSetIds();

    computeDerivedStats();
    renderUI();
    renderInventory();
    renderPlayerStats();
    renderShop();
    updateWorldProgress();

    setInterval(gameTick, CONFIG.TICK_INTERVAL_MS);
    setInterval(uiTick, CONFIG.UI_UPDATE_MS);
    
    // Auto-save every 30 seconds
    setInterval(() => {
      saveGame();
    }, 30000);
    
    if (CONFIG.DEV_MODE) {
      setInterval(updateDebugPanel, 500);
    }

    spawnWave();
  } catch (error) {
    console.error('Fatal error during initialization:', error);
    alert('Game failed to initialize. Check console for details. Error: ' + error.message);
    // Try to clear save and reload
    if (confirm('Would you like to clear your save data and restart?')) {
      localStorage.removeItem(CONFIG.SAVE_KEY);
      location.reload();
    }
  }
}

// ========== Event Listeners ==========
document.addEventListener('DOMContentLoaded', () => {
  init();
  
  // All event listeners below this point
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'd') {
      e.preventDefault();
      const panel = document.getElementById('debug-panel');
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }

    if (e.key === 'Escape') {
      hideTooltip();
      document.querySelectorAll('.overlay').forEach(overlay => {
        overlay.setAttribute('aria-hidden', 'true');
      });
      // Close custom modals
      const resetModal = document.getElementById('reset-modal');
      if (resetModal) {
        resetModal.setAttribute('aria-hidden', 'true');
      }
      const sellModal = document.getElementById('sell-modal');
      if (sellModal) {
        sellModal.setAttribute('aria-hidden', 'true');
      }
    }
  });

  document.getElementById('btn-challenge-world').addEventListener('click', challengeWorld);

  document.getElementById('btn-manual-refresh').addEventListener('click', () => {
    if (Date.now() >= GameState.shop.manualCooldownEndTs) {
      refreshShop();
      GameState.shop.manualCooldownEndTs = Date.now() + CONFIG.SHOP_MANUAL_COOLDOWN_SEC * 1000;
      renderShop();
    }
  });

  document.getElementById('btn-reset-progress').addEventListener('click', () => {
    const modal = document.getElementById('reset-modal');
    modal.setAttribute('aria-hidden', 'false');
  });

  document.getElementById('modal-cancel').addEventListener('click', () => {
    const modal = document.getElementById('reset-modal');
    modal.setAttribute('aria-hidden', 'true');
  });

  document.getElementById('modal-confirm').addEventListener('click', () => {
    // Set a flag to prevent any saves during reset
    window.RESETTING_GAME = true;
    
    // Stop all game loops immediately
    GameState.gameActive = false;
    
    // Clear all localStorage
    localStorage.clear();
    
    // Force reload after a small delay
    setTimeout(() => {
      window.location.href = window.location.href.split('?')[0]; // Remove any query params and reload
    }, 50);
  });

  // Close modal when clicking outside
  document.getElementById('reset-modal').addEventListener('click', (e) => {
    if (e.target.id === 'reset-modal') {
      e.target.setAttribute('aria-hidden', 'true');
    }
  });

  // Sell modal event listeners
  document.getElementById('sell-modal-cancel').addEventListener('click', () => {
    const modal = document.getElementById('sell-modal');
    modal.setAttribute('aria-hidden', 'true');
  });

  document.getElementById('sell-modal-confirm').addEventListener('click', () => {
    confirmSellItem();
  });

  // Close sell modal when clicking outside
  document.getElementById('sell-modal').addEventListener('click', (e) => {
    if (e.target.id === 'sell-modal') {
      e.target.setAttribute('aria-hidden', 'true');
    }
  });
});

document.addEventListener('click', (e) => {
  // Handle buy shop button clicks
  if (e.target.classList.contains('buy-shop-btn')) {
    const itemId = e.target.getAttribute('data-item-id');
    if (itemId) {
      buyShopItem(itemId);
    }
    return;
  }

  // Close tooltip when clicking outside
  if (!e.target.closest('.inv-slot') &&
      !e.target.closest('.equip-slot') &&
      !e.target.closest('.shop-item') &&
      !e.target.closest('.effect-icon') &&
      !e.target.closest('.tooltip')) {
    hideTooltip();
  }
});

document.addEventListener('contextmenu', (e) => {
  if (e.target.closest('.enemy') || e.target.closest('.inv-slot') || e.target.closest('.equip-slot')) {
    e.preventDefault();
  }
});

/* --- Smooth per-frame enemy renderer (added by assistant) --- */
if (!window.GameState) window.GameState = window.GameState || {};
if (!window.CONFIG) window.CONFIG = window.CONFIG || {};
// Fallback tick interval ms if CONFIG not defined
if (!CONFIG.TICK_INTERVAL_MS) CONFIG.TICK_INTERVAL_MS = 200;

GameState.lastPhysicsTs = GameState.lastPhysicsTs || performance.now();

function renderEnemiesPerFrame(){
  requestAnimationFrame(renderEnemiesPerFrame);
  const now = performance.now();
  const alpha = Math.min(1, (now - (GameState.lastPhysicsTs || now)) / CONFIG.TICK_INTERVAL_MS);

  GameState.enemies = GameState.enemies || [];
  GameState.enemies.forEach(enemy => {
    const px = (enemy.prevX !== undefined ? enemy.prevX : enemy.position.x);
    const py = (enemy.prevY !== undefined ? enemy.prevY : enemy.position.y);
    const rx = px + (enemy.position.x - px) * alpha;
    const ry = py + (enemy.position.y - py) * alpha;

    let el =
      document.querySelector(`[data-enemy-id="${enemy.id}"]`) ||
      document.querySelector(`[data-boss-id="${enemy.id}"]`) ||
      document.querySelector(`[data-entity-id="${enemy.id}"]`);
    if (el) {
      el.style.transform = `translate(${rx}px, ${ry}px)`;
      const hpFill = el.querySelector('.enemy-hp-fill');
      if (hpFill && enemy.maxHp) {
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);
        hpFill.style.width = `${hpPct}%`;
      }
    }
  });
}

// start the per-frame renderer after DOM ready or immediately if already ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(renderEnemiesPerFrame));
} else {
  requestAnimationFrame(renderEnemiesPerFrame);
}
/* --- end smooth renderer --- */


// ========== BUG FIX DOCUMENTATION ==========
// Fixed: When upgrading or selling items, the wrong item was being selected
// Solution: All tooltip button clicks now use event delegation and read the
// item ID from tooltip.dataset.currentItemId, which is set correctly when
// showItemTooltip() is called. This prevents closure-based item ID capture bugs.
// ===========================================

// ========== Tooltip Button Event Delegation ==========
// Handle all tooltip button clicks to fix the wrong-item bug
document.addEventListener('click', (e) => {
  const button = e.target.closest('.tooltip-btn, .reroll-btn');
  if (!button) return;

  const tooltip = document.getElementById('inventory-tooltip');
  if (!tooltip || !tooltip.contains(button)) return;
  if (tooltip.getAttribute('aria-hidden') === 'true') return;

  const action = button.getAttribute('data-action');
  if (!action) return;

  // Get item ID from tooltip dataset (this is the correct item ID)
  const itemId = tooltip.dataset.currentItemId;
  if (!itemId) return;

  // Prevent default and stop propagation
  e.preventDefault();
  e.stopPropagation();

  // Execute the appropriate action with the correct item ID
  switch (action) {
    case 'equip':
      equipItem(itemId);
      break;
    case 'unequip':
      const slot = button.getAttribute('data-slot');
      if (slot) unequipItem(slot);
      break;
    case 'upgrade':
      upgradeItem(itemId);
      break;
    case 'enhance':
      enhanceItem(itemId);
      break;
    case 'quick-enhance':
      quickEnhanceItem(itemId);
      break;
    case 'quick-upgrade':
      const targetLevel = parseInt(button.getAttribute('data-target-level'));
      if (!isNaN(targetLevel)) quickUpgradeItem(itemId, targetLevel);
      break;
    case 'sell':
      sellItem(itemId);
      break;
    case 'use-consumable':
      useConsumable(itemId);
      break;
    case 'reroll-affix':
      const affixIndex1 = parseInt(button.getAttribute('data-affix-index'));
      if (!isNaN(affixIndex1)) rerollAffix(itemId, affixIndex1);
      break;
    case 'reroll-affix-value':
      const affixIndex2 = parseInt(button.getAttribute('data-affix-index'));
      if (!isNaN(affixIndex2)) rerollAffixValue(itemId, affixIndex2);
      break;
    case 'unlock-enchantment':
      const enchIndex1 = parseInt(button.getAttribute('data-ench-index'));
      if (!isNaN(enchIndex1)) unlockEnchantment(itemId, enchIndex1);
      break;
    case 'reroll-enchantment':
      const enchIndex2 = parseInt(button.getAttribute('data-ench-index'));
      if (!isNaN(enchIndex2)) rerollEnchantment(itemId, enchIndex2);
      break;
  }
});

// Save game before page unload
window.addEventListener('beforeunload', () => {
  saveGame();
});

// Save game when page becomes hidden (tab switch, minimize, etc.)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    saveGame();
  }
});

</script>
</body>
</html>
